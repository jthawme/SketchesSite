// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"../node_modules/three/build/three.module.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AmbientLight = AmbientLight;
exports.AmbientLightProbe = AmbientLightProbe;
exports.AnimationClip = AnimationClip;
exports.AnimationLoader = AnimationLoader;
exports.AnimationMixer = AnimationMixer;
exports.AnimationObjectGroup = AnimationObjectGroup;
exports.ArcCurve = ArcCurve;
exports.ArrayCamera = ArrayCamera;
exports.ArrowHelper = ArrowHelper;
exports.Audio = Audio;
exports.AudioAnalyser = AudioAnalyser;
exports.AudioListener = AudioListener;
exports.AudioLoader = AudioLoader;
exports.AxesHelper = AxesHelper;
exports.AxisHelper = AxisHelper;
exports.BinaryTextureLoader = BinaryTextureLoader;
exports.Bone = Bone;
exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
exports.BoundingBoxHelper = BoundingBoxHelper;
exports.Box2 = Box2;
exports.Box3 = Box3;
exports.Box3Helper = Box3Helper;
exports.BoxBufferGeometry = BoxBufferGeometry;
exports.CubeGeometry = exports.BoxGeometry = BoxGeometry;
exports.BoxHelper = BoxHelper;
exports.BufferAttribute = BufferAttribute;
exports.BufferGeometry = BufferGeometry;
exports.BufferGeometryLoader = BufferGeometryLoader;
exports.Camera = Camera;
exports.CameraHelper = CameraHelper;
exports.CanvasRenderer = CanvasRenderer;
exports.CanvasTexture = CanvasTexture;
exports.CatmullRomCurve3 = CatmullRomCurve3;
exports.CircleBufferGeometry = CircleBufferGeometry;
exports.CircleGeometry = CircleGeometry;
exports.Clock = Clock;
exports.ClosedSplineCurve3 = ClosedSplineCurve3;
exports.Color = Color;
exports.ColorKeyframeTrack = ColorKeyframeTrack;
exports.CompressedTexture = CompressedTexture;
exports.CompressedTextureLoader = CompressedTextureLoader;
exports.ConeBufferGeometry = ConeBufferGeometry;
exports.ConeGeometry = ConeGeometry;
exports.CubeCamera = CubeCamera;
exports.CubeTexture = CubeTexture;
exports.CubeTextureLoader = CubeTextureLoader;
exports.CubicBezierCurve = CubicBezierCurve;
exports.CubicBezierCurve3 = CubicBezierCurve3;
exports.CubicInterpolant = CubicInterpolant;
exports.Curve = Curve;
exports.CurvePath = CurvePath;
exports.CylinderBufferGeometry = CylinderBufferGeometry;
exports.CylinderGeometry = CylinderGeometry;
exports.Cylindrical = Cylindrical;
exports.DataTexture = DataTexture;
exports.DataTexture2DArray = DataTexture2DArray;
exports.DataTexture3D = DataTexture3D;
exports.DataTextureLoader = DataTextureLoader;
exports.DepthTexture = DepthTexture;
exports.DirectionalLight = DirectionalLight;
exports.DirectionalLightHelper = DirectionalLightHelper;
exports.DirectionalLightShadow = DirectionalLightShadow;
exports.DiscreteInterpolant = DiscreteInterpolant;
exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
exports.DodecahedronGeometry = DodecahedronGeometry;
exports.DynamicBufferAttribute = DynamicBufferAttribute;
exports.EdgesGeometry = EdgesGeometry;
exports.EdgesHelper = EdgesHelper;
exports.EllipseCurve = EllipseCurve;
exports.Euler = Euler;
exports.EventDispatcher = EventDispatcher;
exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
exports.ExtrudeGeometry = ExtrudeGeometry;
exports.Face3 = Face3;
exports.Face4 = Face4;
exports.FaceNormalsHelper = FaceNormalsHelper;
exports.FileLoader = FileLoader;
exports.Float32Attribute = Float32Attribute;
exports.Float32BufferAttribute = Float32BufferAttribute;
exports.Float64Attribute = Float64Attribute;
exports.Float64BufferAttribute = Float64BufferAttribute;
exports.Fog = Fog;
exports.FogExp2 = FogExp2;
exports.Font = Font;
exports.FontLoader = FontLoader;
exports.Frustum = Frustum;
exports.Geometry = Geometry;
exports.GridHelper = GridHelper;
exports.Group = Group;
exports.HemisphereLight = HemisphereLight;
exports.HemisphereLightHelper = HemisphereLightHelper;
exports.HemisphereLightProbe = HemisphereLightProbe;
exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
exports.IcosahedronGeometry = IcosahedronGeometry;
exports.ImageBitmapLoader = ImageBitmapLoader;
exports.ImageLoader = ImageLoader;
exports.ImmediateRenderObject = ImmediateRenderObject;
exports.InstancedBufferAttribute = InstancedBufferAttribute;
exports.InstancedBufferGeometry = InstancedBufferGeometry;
exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
exports.Int16Attribute = Int16Attribute;
exports.Int16BufferAttribute = Int16BufferAttribute;
exports.Int32Attribute = Int32Attribute;
exports.Int32BufferAttribute = Int32BufferAttribute;
exports.Int8Attribute = Int8Attribute;
exports.Int8BufferAttribute = Int8BufferAttribute;
exports.InterleavedBuffer = InterleavedBuffer;
exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
exports.Interpolant = Interpolant;
exports.JSONLoader = JSONLoader;
exports.KeyframeTrack = KeyframeTrack;
exports.LOD = LOD;
exports.LatheBufferGeometry = LatheBufferGeometry;
exports.LatheGeometry = LatheGeometry;
exports.Layers = Layers;
exports.LensFlare = LensFlare;
exports.Light = Light;
exports.LightProbe = LightProbe;
exports.LightProbeHelper = LightProbeHelper;
exports.LightShadow = LightShadow;
exports.Line = Line;
exports.Line3 = Line3;
exports.LineBasicMaterial = LineBasicMaterial;
exports.LineCurve = LineCurve;
exports.LineCurve3 = LineCurve3;
exports.LineDashedMaterial = LineDashedMaterial;
exports.LineLoop = LineLoop;
exports.LineSegments = LineSegments;
exports.LinearInterpolant = LinearInterpolant;
exports.Loader = Loader;
exports.LoadingManager = LoadingManager;
exports.Material = Material;
exports.MaterialLoader = MaterialLoader;
exports.Matrix3 = Matrix3;
exports.Matrix4 = Matrix4;
exports.Mesh = Mesh;
exports.MeshBasicMaterial = MeshBasicMaterial;
exports.MeshDepthMaterial = MeshDepthMaterial;
exports.MeshDistanceMaterial = MeshDistanceMaterial;
exports.MeshFaceMaterial = MeshFaceMaterial;
exports.MeshLambertMaterial = MeshLambertMaterial;
exports.MeshMatcapMaterial = MeshMatcapMaterial;
exports.MeshNormalMaterial = MeshNormalMaterial;
exports.MeshPhongMaterial = MeshPhongMaterial;
exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
exports.MeshStandardMaterial = MeshStandardMaterial;
exports.MeshToonMaterial = MeshToonMaterial;
exports.MultiMaterial = MultiMaterial;
exports.NumberKeyframeTrack = NumberKeyframeTrack;
exports.Object3D = Object3D;
exports.ObjectLoader = ObjectLoader;
exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
exports.OctahedronGeometry = OctahedronGeometry;
exports.OrthographicCamera = OrthographicCamera;
exports.ParametricBufferGeometry = ParametricBufferGeometry;
exports.ParametricGeometry = ParametricGeometry;
exports.Particle = Particle;
exports.ParticleBasicMaterial = ParticleBasicMaterial;
exports.ParticleSystem = ParticleSystem;
exports.ParticleSystemMaterial = ParticleSystemMaterial;
exports.Path = Path;
exports.PerspectiveCamera = PerspectiveCamera;
exports.Plane = Plane;
exports.PlaneBufferGeometry = PlaneBufferGeometry;
exports.PlaneGeometry = PlaneGeometry;
exports.PlaneHelper = PlaneHelper;
exports.PointCloud = PointCloud;
exports.PointCloudMaterial = PointCloudMaterial;
exports.PointLight = PointLight;
exports.PointLightHelper = PointLightHelper;
exports.Points = Points;
exports.PointsMaterial = PointsMaterial;
exports.PolarGridHelper = PolarGridHelper;
exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
exports.PolyhedronGeometry = PolyhedronGeometry;
exports.PositionalAudio = PositionalAudio;
exports.PositionalAudioHelper = PositionalAudioHelper;
exports.PropertyBinding = PropertyBinding;
exports.PropertyMixer = PropertyMixer;
exports.QuadraticBezierCurve = QuadraticBezierCurve;
exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
exports.Quaternion = Quaternion;
exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
exports.RawShaderMaterial = RawShaderMaterial;
exports.Ray = Ray;
exports.Raycaster = Raycaster;
exports.RectAreaLight = RectAreaLight;
exports.RectAreaLightHelper = RectAreaLightHelper;
exports.RingBufferGeometry = RingBufferGeometry;
exports.RingGeometry = RingGeometry;
exports.Scene = Scene;
exports.ShaderMaterial = ShaderMaterial;
exports.ShadowMaterial = ShadowMaterial;
exports.Shape = Shape;
exports.ShapeBufferGeometry = ShapeBufferGeometry;
exports.ShapeGeometry = ShapeGeometry;
exports.ShapePath = ShapePath;
exports.Skeleton = Skeleton;
exports.SkeletonHelper = SkeletonHelper;
exports.SkinnedMesh = SkinnedMesh;
exports.Sphere = Sphere;
exports.SphereBufferGeometry = SphereBufferGeometry;
exports.SphereGeometry = SphereGeometry;
exports.Spherical = Spherical;
exports.SphericalHarmonics3 = SphericalHarmonics3;
exports.Spline = Spline;
exports.SplineCurve = SplineCurve;
exports.SplineCurve3 = SplineCurve3;
exports.SpotLight = SpotLight;
exports.SpotLightHelper = SpotLightHelper;
exports.SpotLightShadow = SpotLightShadow;
exports.Sprite = Sprite;
exports.SpriteMaterial = SpriteMaterial;
exports.StereoCamera = StereoCamera;
exports.StringKeyframeTrack = StringKeyframeTrack;
exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
exports.TetrahedronGeometry = TetrahedronGeometry;
exports.TextBufferGeometry = TextBufferGeometry;
exports.TextGeometry = TextGeometry;
exports.Texture = Texture;
exports.TextureLoader = TextureLoader;
exports.TorusBufferGeometry = TorusBufferGeometry;
exports.TorusGeometry = TorusGeometry;
exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
exports.TorusKnotGeometry = TorusKnotGeometry;
exports.Triangle = Triangle;
exports.TubeBufferGeometry = TubeBufferGeometry;
exports.TubeGeometry = TubeGeometry;
exports.Uint16Attribute = Uint16Attribute;
exports.Uint16BufferAttribute = Uint16BufferAttribute;
exports.Uint32Attribute = Uint32Attribute;
exports.Uint32BufferAttribute = Uint32BufferAttribute;
exports.Uint8Attribute = Uint8Attribute;
exports.Uint8BufferAttribute = Uint8BufferAttribute;
exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
exports.Uniform = Uniform;
exports.Vector2 = Vector2;
exports.Vector3 = Vector3;
exports.Vector4 = Vector4;
exports.VectorKeyframeTrack = VectorKeyframeTrack;
exports.Vertex = Vertex;
exports.VertexNormalsHelper = VertexNormalsHelper;
exports.VideoTexture = VideoTexture;
exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
exports.WebGLRenderTarget = WebGLRenderTarget;
exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
exports.WebGLRenderer = WebGLRenderer;
exports.WebGLUtils = WebGLUtils;
exports.WireframeGeometry = WireframeGeometry;
exports.WireframeHelper = WireframeHelper;
exports.XHRLoader = XHRLoader;
exports.NotEqualStencilFunc = exports.NotEqualDepth = exports.NormalBlending = exports.NoToneMapping = exports.NoColors = exports.NoBlending = exports.NeverStencilFunc = exports.NeverDepth = exports.NearestMipmapNearestFilter = exports.NearestMipmapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestMipMapLinearFilter = exports.NearestFilter = exports.MultiplyOperation = exports.MultiplyBlending = exports.MixOperation = exports.MirroredRepeatWrapping = exports.MinEquation = exports.MaxEquation = exports.Math = exports.MOUSE = exports.LuminanceFormat = exports.LuminanceAlphaFormat = exports.LoopRepeat = exports.LoopPingPong = exports.LoopOnce = exports.LogLuvEncoding = exports.LoaderUtils = exports.LinearToneMapping = exports.LinearMipmapNearestFilter = exports.LinearMipmapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearMipMapLinearFilter = exports.LinearFilter = exports.LinearEncoding = exports.LineStrip = exports.LinePieces = exports.LessStencilFunc = exports.LessEqualStencilFunc = exports.LessEqualDepth = exports.LessDepth = exports.KeepStencilOp = exports.InvertStencilOp = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = exports.IntType = exports.IncrementWrapStencilOp = exports.IncrementStencilOp = exports.ImageUtils = exports.HalfFloatType = exports.GreaterStencilFunc = exports.GreaterEqualStencilFunc = exports.GreaterEqualDepth = exports.GreaterDepth = exports.GeometryUtils = exports.GammaEncoding = exports.FrontSide = exports.FrontFaceDirectionCW = exports.FrontFaceDirectionCCW = exports.FloatType = exports.FlatShading = exports.FaceColors = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.EqualStencilFunc = exports.EqualDepth = exports.DstColorFactor = exports.DstAlphaFactor = exports.DoubleSide = exports.DepthStencilFormat = exports.DepthFormat = exports.DefaultLoadingManager = exports.DecrementWrapStencilOp = exports.DecrementStencilOp = exports.CustomBlending = exports.CullFaceNone = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = exports.CubeUVRefractionMapping = exports.CubeUVReflectionMapping = exports.CubeRefractionMapping = exports.CubeReflectionMapping = exports.ClampToEdgeWrapping = exports.CineonToneMapping = exports.Cache = exports.ByteType = exports.BasicShadowMap = exports.BasicDepthPacking = exports.BackSide = exports.AudioContext = exports.AnimationUtils = exports.AlwaysStencilFunc = exports.AlwaysDepth = exports.AlphaFormat = exports.AdditiveBlending = exports.AddOperation = exports.AddEquation = exports.ACESFilmicToneMapping = void 0;
exports.sRGBEncoding = exports.ZeroStencilOp = exports.ZeroSlopeEnding = exports.ZeroFactor = exports.ZeroCurvatureEnding = exports.WrapAroundEnding = exports.VertexColors = exports.VSMShadowMap = exports.UnsignedShortType = exports.UnsignedShort565Type = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.UnsignedIntType = exports.UnsignedInt248Type = exports.UnsignedByteType = exports.UniformsUtils = exports.UniformsLib = exports.Uncharted2ToneMapping = exports.UVMapping = exports.TrianglesDrawMode = exports.TriangleStripDrawMode = exports.TriangleFanDrawMode = exports.TangentSpaceNormalMap = exports.TOUCH = exports.SubtractiveBlending = exports.SubtractEquation = exports.SrcColorFactor = exports.SrcAlphaSaturateFactor = exports.SrcAlphaFactor = exports.SphericalReflectionMapping = exports.SmoothShading = exports.ShortType = exports.ShapeUtils = exports.ShaderLib = exports.ShaderChunk = exports.SceneUtils = exports.ReverseSubtractEquation = exports.ReplaceStencilOp = exports.RepeatWrapping = exports.ReinhardToneMapping = exports.RedFormat = exports.RGB_S3TC_DXT1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_ETC1_Format = exports.RGBM7Encoding = exports.RGBM16Encoding = exports.RGBFormat = exports.RGBEFormat = exports.RGBEEncoding = exports.RGBDEncoding = exports.RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBAFormat = exports.RGBADepthPacking = exports.REVISION = exports.PCFSoftShadowMap = exports.PCFShadowMap = exports.OneMinusSrcColorFactor = exports.OneMinusSrcAlphaFactor = exports.OneMinusDstColorFactor = exports.OneMinusDstAlphaFactor = exports.OneFactor = exports.ObjectSpaceNormalMap = void 0;

// Polyfills
if (Number.EPSILON === undefined) {
  Number.EPSILON = Math.pow(2, -52);
}

if (Number.isInteger === undefined) {
  // Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
  Number.isInteger = function (value) {
    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
  };
} //


if (Math.sign === undefined) {
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
  Math.sign = function (x) {
    return x < 0 ? -1 : x > 0 ? 1 : +x;
  };
}

if ('name' in Function.prototype === false) {
  // Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
  Object.defineProperty(Function.prototype, 'name', {
    get: function () {
      return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
    }
  });
}

if (Object.assign === undefined) {
  // Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
  Object.assign = function (target) {
    if (target === undefined || target === null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var output = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      var source = arguments[index];

      if (source !== undefined && source !== null) {
        for (var nextKey in source) {
          if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
            output[nextKey] = source[nextKey];
          }
        }
      }
    }

    return output;
  };
}
/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */


function EventDispatcher() {}

Object.assign(EventDispatcher.prototype, {
  addEventListener: function (type, listener) {
    if (this._listeners === undefined) this._listeners = {};
    var listeners = this._listeners;

    if (listeners[type] === undefined) {
      listeners[type] = [];
    }

    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  },
  hasEventListener: function (type, listener) {
    if (this._listeners === undefined) return false;
    var listeners = this._listeners;
    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
  },
  removeEventListener: function (type, listener) {
    if (this._listeners === undefined) return;
    var listeners = this._listeners;
    var listenerArray = listeners[type];

    if (listenerArray !== undefined) {
      var index = listenerArray.indexOf(listener);

      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  },
  dispatchEvent: function (event) {
    if (this._listeners === undefined) return;
    var listeners = this._listeners;
    var listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {
      event.target = this;
      var array = listenerArray.slice(0);

      for (var i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }
  }
});
var REVISION = '108';
exports.REVISION = REVISION;
var MOUSE = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2
};
exports.MOUSE = MOUSE;
var TOUCH = {
  ROTATE: 0,
  PAN: 1,
  DOLLY_PAN: 2,
  DOLLY_ROTATE: 3
};
exports.TOUCH = TOUCH;
var CullFaceNone = 0;
exports.CullFaceNone = CullFaceNone;
var CullFaceBack = 1;
exports.CullFaceBack = CullFaceBack;
var CullFaceFront = 2;
exports.CullFaceFront = CullFaceFront;
var CullFaceFrontBack = 3;
exports.CullFaceFrontBack = CullFaceFrontBack;
var FrontFaceDirectionCW = 0;
exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
var FrontFaceDirectionCCW = 1;
exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
var BasicShadowMap = 0;
exports.BasicShadowMap = BasicShadowMap;
var PCFShadowMap = 1;
exports.PCFShadowMap = PCFShadowMap;
var PCFSoftShadowMap = 2;
exports.PCFSoftShadowMap = PCFSoftShadowMap;
var VSMShadowMap = 3;
exports.VSMShadowMap = VSMShadowMap;
var FrontSide = 0;
exports.FrontSide = FrontSide;
var BackSide = 1;
exports.BackSide = BackSide;
var DoubleSide = 2;
exports.DoubleSide = DoubleSide;
var FlatShading = 1;
exports.FlatShading = FlatShading;
var SmoothShading = 2;
exports.SmoothShading = SmoothShading;
var NoColors = 0;
exports.NoColors = NoColors;
var FaceColors = 1;
exports.FaceColors = FaceColors;
var VertexColors = 2;
exports.VertexColors = VertexColors;
var NoBlending = 0;
exports.NoBlending = NoBlending;
var NormalBlending = 1;
exports.NormalBlending = NormalBlending;
var AdditiveBlending = 2;
exports.AdditiveBlending = AdditiveBlending;
var SubtractiveBlending = 3;
exports.SubtractiveBlending = SubtractiveBlending;
var MultiplyBlending = 4;
exports.MultiplyBlending = MultiplyBlending;
var CustomBlending = 5;
exports.CustomBlending = CustomBlending;
var AddEquation = 100;
exports.AddEquation = AddEquation;
var SubtractEquation = 101;
exports.SubtractEquation = SubtractEquation;
var ReverseSubtractEquation = 102;
exports.ReverseSubtractEquation = ReverseSubtractEquation;
var MinEquation = 103;
exports.MinEquation = MinEquation;
var MaxEquation = 104;
exports.MaxEquation = MaxEquation;
var ZeroFactor = 200;
exports.ZeroFactor = ZeroFactor;
var OneFactor = 201;
exports.OneFactor = OneFactor;
var SrcColorFactor = 202;
exports.SrcColorFactor = SrcColorFactor;
var OneMinusSrcColorFactor = 203;
exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
var SrcAlphaFactor = 204;
exports.SrcAlphaFactor = SrcAlphaFactor;
var OneMinusSrcAlphaFactor = 205;
exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
var DstAlphaFactor = 206;
exports.DstAlphaFactor = DstAlphaFactor;
var OneMinusDstAlphaFactor = 207;
exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
var DstColorFactor = 208;
exports.DstColorFactor = DstColorFactor;
var OneMinusDstColorFactor = 209;
exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
var SrcAlphaSaturateFactor = 210;
exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
var NeverDepth = 0;
exports.NeverDepth = NeverDepth;
var AlwaysDepth = 1;
exports.AlwaysDepth = AlwaysDepth;
var LessDepth = 2;
exports.LessDepth = LessDepth;
var LessEqualDepth = 3;
exports.LessEqualDepth = LessEqualDepth;
var EqualDepth = 4;
exports.EqualDepth = EqualDepth;
var GreaterEqualDepth = 5;
exports.GreaterEqualDepth = GreaterEqualDepth;
var GreaterDepth = 6;
exports.GreaterDepth = GreaterDepth;
var NotEqualDepth = 7;
exports.NotEqualDepth = NotEqualDepth;
var MultiplyOperation = 0;
exports.MultiplyOperation = MultiplyOperation;
var MixOperation = 1;
exports.MixOperation = MixOperation;
var AddOperation = 2;
exports.AddOperation = AddOperation;
var NoToneMapping = 0;
exports.NoToneMapping = NoToneMapping;
var LinearToneMapping = 1;
exports.LinearToneMapping = LinearToneMapping;
var ReinhardToneMapping = 2;
exports.ReinhardToneMapping = ReinhardToneMapping;
var Uncharted2ToneMapping = 3;
exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
var CineonToneMapping = 4;
exports.CineonToneMapping = CineonToneMapping;
var ACESFilmicToneMapping = 5;
exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
var UVMapping = 300;
exports.UVMapping = UVMapping;
var CubeReflectionMapping = 301;
exports.CubeReflectionMapping = CubeReflectionMapping;
var CubeRefractionMapping = 302;
exports.CubeRefractionMapping = CubeRefractionMapping;
var EquirectangularReflectionMapping = 303;
exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
var EquirectangularRefractionMapping = 304;
exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
var SphericalReflectionMapping = 305;
exports.SphericalReflectionMapping = SphericalReflectionMapping;
var CubeUVReflectionMapping = 306;
exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
var CubeUVRefractionMapping = 307;
exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
var RepeatWrapping = 1000;
exports.RepeatWrapping = RepeatWrapping;
var ClampToEdgeWrapping = 1001;
exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
var MirroredRepeatWrapping = 1002;
exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
var NearestFilter = 1003;
exports.NearestFilter = NearestFilter;
var NearestMipmapNearestFilter = 1004;
exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
var NearestMipMapNearestFilter = 1004;
exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
var NearestMipmapLinearFilter = 1005;
exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
var NearestMipMapLinearFilter = 1005;
exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
var LinearFilter = 1006;
exports.LinearFilter = LinearFilter;
var LinearMipmapNearestFilter = 1007;
exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
var LinearMipMapNearestFilter = 1007;
exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
var LinearMipmapLinearFilter = 1008;
exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
var LinearMipMapLinearFilter = 1008;
exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
var UnsignedByteType = 1009;
exports.UnsignedByteType = UnsignedByteType;
var ByteType = 1010;
exports.ByteType = ByteType;
var ShortType = 1011;
exports.ShortType = ShortType;
var UnsignedShortType = 1012;
exports.UnsignedShortType = UnsignedShortType;
var IntType = 1013;
exports.IntType = IntType;
var UnsignedIntType = 1014;
exports.UnsignedIntType = UnsignedIntType;
var FloatType = 1015;
exports.FloatType = FloatType;
var HalfFloatType = 1016;
exports.HalfFloatType = HalfFloatType;
var UnsignedShort4444Type = 1017;
exports.UnsignedShort4444Type = UnsignedShort4444Type;
var UnsignedShort5551Type = 1018;
exports.UnsignedShort5551Type = UnsignedShort5551Type;
var UnsignedShort565Type = 1019;
exports.UnsignedShort565Type = UnsignedShort565Type;
var UnsignedInt248Type = 1020;
exports.UnsignedInt248Type = UnsignedInt248Type;
var AlphaFormat = 1021;
exports.AlphaFormat = AlphaFormat;
var RGBFormat = 1022;
exports.RGBFormat = RGBFormat;
var RGBAFormat = 1023;
exports.RGBAFormat = RGBAFormat;
var LuminanceFormat = 1024;
exports.LuminanceFormat = LuminanceFormat;
var LuminanceAlphaFormat = 1025;
exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
var RGBEFormat = RGBAFormat;
exports.RGBEFormat = RGBEFormat;
var DepthFormat = 1026;
exports.DepthFormat = DepthFormat;
var DepthStencilFormat = 1027;
exports.DepthStencilFormat = DepthStencilFormat;
var RedFormat = 1028;
exports.RedFormat = RedFormat;
var RGB_S3TC_DXT1_Format = 33776;
exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
var RGBA_S3TC_DXT1_Format = 33777;
exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
var RGBA_S3TC_DXT3_Format = 33778;
exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
var RGBA_S3TC_DXT5_Format = 33779;
exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
var RGB_PVRTC_4BPPV1_Format = 35840;
exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
var RGB_PVRTC_2BPPV1_Format = 35841;
exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
var RGBA_PVRTC_4BPPV1_Format = 35842;
exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
var RGBA_PVRTC_2BPPV1_Format = 35843;
exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
var RGB_ETC1_Format = 36196;
exports.RGB_ETC1_Format = RGB_ETC1_Format;
var RGBA_ASTC_4x4_Format = 37808;
exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
var RGBA_ASTC_5x4_Format = 37809;
exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
var RGBA_ASTC_5x5_Format = 37810;
exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
var RGBA_ASTC_6x5_Format = 37811;
exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
var RGBA_ASTC_6x6_Format = 37812;
exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
var RGBA_ASTC_8x5_Format = 37813;
exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
var RGBA_ASTC_8x6_Format = 37814;
exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
var RGBA_ASTC_8x8_Format = 37815;
exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
var RGBA_ASTC_10x5_Format = 37816;
exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
var RGBA_ASTC_10x6_Format = 37817;
exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
var RGBA_ASTC_10x8_Format = 37818;
exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
var RGBA_ASTC_10x10_Format = 37819;
exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
var RGBA_ASTC_12x10_Format = 37820;
exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
var RGBA_ASTC_12x12_Format = 37821;
exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
var LoopOnce = 2200;
exports.LoopOnce = LoopOnce;
var LoopRepeat = 2201;
exports.LoopRepeat = LoopRepeat;
var LoopPingPong = 2202;
exports.LoopPingPong = LoopPingPong;
var InterpolateDiscrete = 2300;
exports.InterpolateDiscrete = InterpolateDiscrete;
var InterpolateLinear = 2301;
exports.InterpolateLinear = InterpolateLinear;
var InterpolateSmooth = 2302;
exports.InterpolateSmooth = InterpolateSmooth;
var ZeroCurvatureEnding = 2400;
exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
var ZeroSlopeEnding = 2401;
exports.ZeroSlopeEnding = ZeroSlopeEnding;
var WrapAroundEnding = 2402;
exports.WrapAroundEnding = WrapAroundEnding;
var TrianglesDrawMode = 0;
exports.TrianglesDrawMode = TrianglesDrawMode;
var TriangleStripDrawMode = 1;
exports.TriangleStripDrawMode = TriangleStripDrawMode;
var TriangleFanDrawMode = 2;
exports.TriangleFanDrawMode = TriangleFanDrawMode;
var LinearEncoding = 3000;
exports.LinearEncoding = LinearEncoding;
var sRGBEncoding = 3001;
exports.sRGBEncoding = sRGBEncoding;
var GammaEncoding = 3007;
exports.GammaEncoding = GammaEncoding;
var RGBEEncoding = 3002;
exports.RGBEEncoding = RGBEEncoding;
var LogLuvEncoding = 3003;
exports.LogLuvEncoding = LogLuvEncoding;
var RGBM7Encoding = 3004;
exports.RGBM7Encoding = RGBM7Encoding;
var RGBM16Encoding = 3005;
exports.RGBM16Encoding = RGBM16Encoding;
var RGBDEncoding = 3006;
exports.RGBDEncoding = RGBDEncoding;
var BasicDepthPacking = 3200;
exports.BasicDepthPacking = BasicDepthPacking;
var RGBADepthPacking = 3201;
exports.RGBADepthPacking = RGBADepthPacking;
var TangentSpaceNormalMap = 0;
exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
var ObjectSpaceNormalMap = 1;
exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
var ZeroStencilOp = 0;
exports.ZeroStencilOp = ZeroStencilOp;
var KeepStencilOp = 7680;
exports.KeepStencilOp = KeepStencilOp;
var ReplaceStencilOp = 7681;
exports.ReplaceStencilOp = ReplaceStencilOp;
var IncrementStencilOp = 7682;
exports.IncrementStencilOp = IncrementStencilOp;
var DecrementStencilOp = 7683;
exports.DecrementStencilOp = DecrementStencilOp;
var IncrementWrapStencilOp = 34055;
exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
var DecrementWrapStencilOp = 34056;
exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
var InvertStencilOp = 5386;
exports.InvertStencilOp = InvertStencilOp;
var NeverStencilFunc = 512;
exports.NeverStencilFunc = NeverStencilFunc;
var LessStencilFunc = 513;
exports.LessStencilFunc = LessStencilFunc;
var EqualStencilFunc = 514;
exports.EqualStencilFunc = EqualStencilFunc;
var LessEqualStencilFunc = 515;
exports.LessEqualStencilFunc = LessEqualStencilFunc;
var GreaterStencilFunc = 516;
exports.GreaterStencilFunc = GreaterStencilFunc;
var NotEqualStencilFunc = 517;
exports.NotEqualStencilFunc = NotEqualStencilFunc;
var GreaterEqualStencilFunc = 518;
exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
var AlwaysStencilFunc = 519;
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

exports.AlwaysStencilFunc = AlwaysStencilFunc;
var _lut = [];

for (var i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? '0' : '') + i.toString(16);
}

var _Math = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function () {
    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
    var d0 = Math.random() * 0xffffffff | 0;
    var d1 = Math.random() * 0xffffffff | 0;
    var d2 = Math.random() * 0xffffffff | 0;
    var d3 = Math.random() * 0xffffffff | 0;
    var uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.

    return uuid.toUpperCase();
  },
  clamp: function (value, min, max) {
    return Math.max(min, Math.min(max, value));
  },
  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  euclideanModulo: function (n, m) {
    return (n % m + m) % m;
  },
  // Linear mapping from range <a1, a2> to range <b1, b2>
  mapLinear: function (x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  },
  // https://en.wikipedia.org/wiki/Linear_interpolation
  lerp: function (x, y, t) {
    return (1 - t) * x + t * y;
  },
  // http://en.wikipedia.org/wiki/Smoothstep
  smoothstep: function (x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  },
  smootherstep: function (x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  },
  // Random integer from <low, high> interval
  randInt: function (low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  // Random float from <low, high> interval
  randFloat: function (low, high) {
    return low + Math.random() * (high - low);
  },
  // Random float from <-range/2, range/2> interval
  randFloatSpread: function (range) {
    return range * (0.5 - Math.random());
  },
  degToRad: function (degrees) {
    return degrees * _Math.DEG2RAD;
  },
  radToDeg: function (radians) {
    return radians * _Math.RAD2DEG;
  },
  isPowerOfTwo: function (value) {
    return (value & value - 1) === 0 && value !== 0;
  },
  ceilPowerOfTwo: function (value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  },
  floorPowerOfTwo: function (value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  }
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

exports.Math = _Math;

function Vector2(x, y) {
  this.x = x || 0;
  this.y = y || 0;
}

Object.defineProperties(Vector2.prototype, {
  "width": {
    get: function () {
      return this.x;
    },
    set: function (value) {
      this.x = value;
    }
  },
  "height": {
    get: function () {
      return this.y;
    },
    set: function (value) {
      this.y = value;
    }
  }
});
Object.assign(Vector2.prototype, {
  isVector2: true,
  set: function (x, y) {
    this.x = x;
    this.y = y;
    return this;
  },
  setScalar: function (scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  },
  getComponent: function (index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      default:
        throw new Error('index is out of range: ' + index);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y);
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  },
  addScaledVector: function (v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    return this;
  },
  subScalar: function (s) {
    this.x -= s;
    this.y -= s;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  },
  multiply: function (v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  },
  multiplyScalar: function (scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  },
  divide: function (v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  },
  divideScalar: function (scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  applyMatrix3: function (m) {
    var x = this.x,
        y = this.y;
    var e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  },
  min: function (v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  },
  max: function (v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  },
  clamp: function (min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  },
  clampScalar: function (minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  },
  clampLength: function (min, max) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  },
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  },
  roundToZero: function () {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  },
  negate: function () {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y;
  },
  cross: function (v) {
    return this.x * v.y - this.y * v.x;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  manhattanLength: function () {
    return Math.abs(this.x) + Math.abs(this.y);
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  angle: function () {
    // computes the angle in radians with respect to the positive x-axis
    var angle = Math.atan2(this.y, this.x);
    if (angle < 0) angle += 2 * Math.PI;
    return angle;
  },
  distanceTo: function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function (v) {
    var dx = this.x - v.x,
        dy = this.y - v.y;
    return dx * dx + dy * dy;
  },
  manhattanDistanceTo: function (v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  },
  setLength: function (length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  },
  lerpVectors: function (v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  },
  fromBufferAttribute: function (attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  },
  rotateAround: function (center, angle) {
    var c = Math.cos(angle),
        s = Math.sin(angle);
    var x = this.x - center.x;
    var y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Quaternion(x, y, z, w) {
  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._w = w !== undefined ? w : 1;
}

Object.assign(Quaternion, {
  slerp: function (qa, qb, qm, t) {
    return qm.copy(qa).slerp(qb, t);
  },
  slerpFlat: function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    // fuzz-free, array-based Quaternion SLERP operation
    var x0 = src0[srcOffset0 + 0],
        y0 = src0[srcOffset0 + 1],
        z0 = src0[srcOffset0 + 2],
        w0 = src0[srcOffset0 + 3],
        x1 = src1[srcOffset1 + 0],
        y1 = src1[srcOffset1 + 1],
        z1 = src1[srcOffset1 + 2],
        w1 = src1[srcOffset1 + 3];

    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      var s = 1 - t,
          cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
          dir = cos >= 0 ? 1 : -1,
          sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

      if (sqrSin > Number.EPSILON) {
        var sin = Math.sqrt(sqrSin),
            len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }

      var tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

      if (s === 1 - t) {
        var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }

    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
});
Object.defineProperties(Quaternion.prototype, {
  x: {
    get: function () {
      return this._x;
    },
    set: function (value) {
      this._x = value;

      this._onChangeCallback();
    }
  },
  y: {
    get: function () {
      return this._y;
    },
    set: function (value) {
      this._y = value;

      this._onChangeCallback();
    }
  },
  z: {
    get: function () {
      return this._z;
    },
    set: function (value) {
      this._z = value;

      this._onChangeCallback();
    }
  },
  w: {
    get: function () {
      return this._w;
    },
    set: function (value) {
      this._w = value;

      this._onChangeCallback();
    }
  }
});
Object.assign(Quaternion.prototype, {
  isQuaternion: true,
  set: function (x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;

    this._onChangeCallback();

    return this;
  },
  clone: function () {
    return new this.constructor(this._x, this._y, this._z, this._w);
  },
  copy: function (quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;

    this._onChangeCallback();

    return this;
  },
  setFromEuler: function (euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
    }

    var x = euler._x,
        y = euler._y,
        z = euler._z,
        order = euler.order; // http://www.mathworks.com/matlabcentral/fileexchange/
    // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //	content/SpinCalc.m

    var cos = Math.cos;
    var sin = Math.sin;
    var c1 = cos(x / 2);
    var c2 = cos(y / 2);
    var c3 = cos(z / 2);
    var s1 = sin(x / 2);
    var s2 = sin(y / 2);
    var s3 = sin(z / 2);

    if (order === 'XYZ') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'YXZ') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === 'ZXY') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'ZYX') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === 'YZX') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'XZY') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    }

    if (update !== false) this._onChangeCallback();
    return this;
  },
  setFromAxisAngle: function (axis, angle) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
    // assumes axis is normalized
    var halfAngle = angle / 2,
        s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);

    this._onChangeCallback();

    return this;
  },
  setFromRotationMatrix: function (m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    var te = m.elements,
        m11 = te[0],
        m12 = te[4],
        m13 = te[8],
        m21 = te[1],
        m22 = te[5],
        m23 = te[9],
        m31 = te[2],
        m32 = te[6],
        m33 = te[10],
        trace = m11 + m22 + m33,
        s;

    if (trace > 0) {
      s = 0.5 / Math.sqrt(trace + 1.0);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }

    this._onChangeCallback();

    return this;
  },
  setFromUnitVectors: function (vFrom, vTo) {
    // assumes direction vectors vFrom and vTo are normalized
    var EPS = 0.000001;
    var r = vFrom.dot(vTo) + 1;

    if (r < EPS) {
      r = 0;

      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }

    return this.normalize();
  },
  angleTo: function (q) {
    return 2 * Math.acos(Math.abs(_Math.clamp(this.dot(q), -1, 1)));
  },
  rotateTowards: function (q, step) {
    var angle = this.angleTo(q);
    if (angle === 0) return this;
    var t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  },
  inverse: function () {
    // quaternion is assumed to have unit length
    return this.conjugate();
  },
  conjugate: function () {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;

    this._onChangeCallback();

    return this;
  },
  dot: function (v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  },
  lengthSq: function () {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function () {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function () {
    var l = this.length();

    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }

    this._onChangeCallback();

    return this;
  },
  multiply: function (q, p) {
    if (p !== undefined) {
      console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
      return this.multiplyQuaternions(q, p);
    }

    return this.multiplyQuaternions(this, q);
  },
  premultiply: function (q) {
    return this.multiplyQuaternions(q, this);
  },
  multiplyQuaternions: function (a, b) {
    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
    var qax = a._x,
        qay = a._y,
        qaz = a._z,
        qaw = a._w;
    var qbx = b._x,
        qby = b._y,
        qbz = b._z,
        qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    this._onChangeCallback();

    return this;
  },
  slerp: function (qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    var x = this._x,
        y = this._y,
        z = this._z,
        w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }

    if (cosHalfTheta >= 1.0) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }

    var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

    if (sqrSinHalfTheta <= Number.EPSILON) {
      var s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();

      this._onChangeCallback();

      return this;
    }

    var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
        ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;

    this._onChangeCallback();

    return this;
  },
  equals: function (quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];

    this._onChangeCallback();

    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  },
  _onChange: function (callback) {
    this._onChangeCallback = callback;
    return this;
  },
  _onChangeCallback: function () {}
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

var _vector = new Vector3();

var _quaternion = new Quaternion();

function Vector3(x, y, z) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
}

Object.assign(Vector3.prototype, {
  isVector3: true,
  set: function (x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  },
  setScalar: function (scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setZ: function (z) {
    this.z = z;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      case 2:
        this.z = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  },
  getComponent: function (index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      default:
        throw new Error('index is out of range: ' + index);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y, this.z);
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  },
  addScaledVector: function (v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  },
  subScalar: function (s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  },
  multiply: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
      return this.multiplyVectors(v, w);
    }

    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  },
  multiplyScalar: function (scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  },
  multiplyVectors: function (a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  },
  applyEuler: function (euler) {
    if (!(euler && euler.isEuler)) {
      console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
    }

    return this.applyQuaternion(_quaternion.setFromEuler(euler));
  },
  applyAxisAngle: function (axis, angle) {
    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
  },
  applyMatrix3: function (m) {
    var x = this.x,
        y = this.y,
        z = this.z;
    var e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  },
  applyMatrix4: function (m) {
    var x = this.x,
        y = this.y,
        z = this.z;
    var e = m.elements;
    var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  },
  applyQuaternion: function (q) {
    var x = this.x,
        y = this.y,
        z = this.z;
    var qx = q.x,
        qy = q.y,
        qz = q.z,
        qw = q.w; // calculate quat * vector

    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  },
  project: function (camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  },
  unproject: function (camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  },
  transformDirection: function (m) {
    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction
    var x = this.x,
        y = this.y,
        z = this.z;
    var e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  },
  divide: function (v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  },
  divideScalar: function (scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  min: function (v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  },
  max: function (v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  },
  clamp: function (min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  },
  clampScalar: function (minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  },
  clampLength: function (min, max) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  },
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  },
  roundToZero: function () {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  },
  negate: function () {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  },
  // TODO lengthSquared?
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  manhattanLength: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function (length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  },
  lerpVectors: function (v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },
  cross: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
      return this.crossVectors(v, w);
    }

    return this.crossVectors(this, v);
  },
  crossVectors: function (a, b) {
    var ax = a.x,
        ay = a.y,
        az = a.z;
    var bx = b.x,
        by = b.y,
        bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  },
  projectOnVector: function (vector) {
    var scalar = vector.dot(this) / vector.lengthSq();
    return this.copy(vector).multiplyScalar(scalar);
  },
  projectOnPlane: function (planeNormal) {
    _vector.copy(this).projectOnVector(planeNormal);

    return this.sub(_vector);
  },
  reflect: function (normal) {
    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length
    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
  },
  angleTo: function (v) {
    var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq()); // clamp, to handle numerical problems

    return Math.acos(_Math.clamp(theta, -1, 1));
  },
  distanceTo: function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function (v) {
    var dx = this.x - v.x,
        dy = this.y - v.y,
        dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  },
  manhattanDistanceTo: function (v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  },
  setFromSpherical: function (s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  },
  setFromSphericalCoords: function (radius, phi, theta) {
    var sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  },
  setFromCylindrical: function (c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  },
  setFromCylindricalCoords: function (radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  },
  setFromMatrixPosition: function (m) {
    var e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  },
  setFromMatrixScale: function (m) {
    var sx = this.setFromMatrixColumn(m, 0).length();
    var sy = this.setFromMatrixColumn(m, 1).length();
    var sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  },
  setFromMatrixColumn: function (m, index) {
    return this.fromArray(m.elements, index * 4);
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  },
  fromBufferAttribute: function (attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */

var _vector$1 = new Vector3();

function Matrix3() {
  this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

  if (arguments.length > 0) {
    console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
  }
}

Object.assign(Matrix3.prototype, {
  isMatrix3: true,
  set: function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    var te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  },
  clone: function () {
    return new this.constructor().fromArray(this.elements);
  },
  copy: function (m) {
    var te = this.elements;
    var me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  },
  setFromMatrix4: function (m) {
    var me = m.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  },
  applyToBufferAttribute: function (attribute) {
    for (var i = 0, l = attribute.count; i < l; i++) {
      _vector$1.x = attribute.getX(i);
      _vector$1.y = attribute.getY(i);
      _vector$1.z = attribute.getZ(i);

      _vector$1.applyMatrix3(this);

      attribute.setXYZ(i, _vector$1.x, _vector$1.y, _vector$1.z);
    }

    return attribute;
  },
  multiply: function (m) {
    return this.multiplyMatrices(this, m);
  },
  premultiply: function (m) {
    return this.multiplyMatrices(m, this);
  },
  multiplyMatrices: function (a, b) {
    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;
    var a11 = ae[0],
        a12 = ae[3],
        a13 = ae[6];
    var a21 = ae[1],
        a22 = ae[4],
        a23 = ae[7];
    var a31 = ae[2],
        a32 = ae[5],
        a33 = ae[8];
    var b11 = be[0],
        b12 = be[3],
        b13 = be[6];
    var b21 = be[1],
        b22 = be[4],
        b23 = be[7];
    var b31 = be[2],
        b32 = be[5],
        b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  },
  multiplyScalar: function (s) {
    var te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  },
  determinant: function () {
    var te = this.elements;
    var a = te[0],
        b = te[1],
        c = te[2],
        d = te[3],
        e = te[4],
        f = te[5],
        g = te[6],
        h = te[7],
        i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  },
  getInverse: function (matrix, throwOnDegenerate) {
    if (matrix && matrix.isMatrix4) {
      console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
    }

    var me = matrix.elements,
        te = this.elements,
        n11 = me[0],
        n21 = me[1],
        n31 = me[2],
        n12 = me[3],
        n22 = me[4],
        n32 = me[5],
        n13 = me[6],
        n23 = me[7],
        n33 = me[8],
        t11 = n33 * n22 - n32 * n23,
        t12 = n32 * n13 - n33 * n12,
        t13 = n23 * n12 - n22 * n13,
        det = n11 * t11 + n21 * t12 + n31 * t13;

    if (det === 0) {
      var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

      if (throwOnDegenerate === true) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }

      return this.identity();
    }

    var detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  },
  transpose: function () {
    var tmp,
        m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  },
  getNormalMatrix: function (matrix4) {
    return this.setFromMatrix4(matrix4).getInverse(this).transpose();
  },
  transposeIntoArray: function (r) {
    var m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  },
  setUvTransform: function (tx, ty, sx, sy, rotation, cx, cy) {
    var c = Math.cos(rotation);
    var s = Math.sin(rotation);
    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
  },
  scale: function (sx, sy) {
    var te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  },
  rotate: function (theta) {
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var te = this.elements;
    var a11 = te[0],
        a12 = te[3],
        a13 = te[6];
    var a21 = te[1],
        a22 = te[4],
        a23 = te[7];
    te[0] = c * a11 + s * a21;
    te[3] = c * a12 + s * a22;
    te[6] = c * a13 + s * a23;
    te[1] = -s * a11 + c * a21;
    te[4] = -s * a12 + c * a22;
    te[7] = -s * a13 + c * a23;
    return this;
  },
  translate: function (tx, ty) {
    var te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  },
  equals: function (matrix) {
    var te = this.elements;
    var me = matrix.elements;

    for (var i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;

    for (var i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    var te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

var _canvas;

var ImageUtils = {
  getDataURL: function (image) {
    var canvas;

    if (typeof HTMLCanvasElement == 'undefined') {
      return image.src;
    } else if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
      _canvas.width = image.width;
      _canvas.height = image.height;

      var context = _canvas.getContext('2d');

      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }

      canvas = _canvas;
    }

    if (canvas.width > 2048 || canvas.height > 2048) {
      return canvas.toDataURL('image/jpeg', 0.6);
    } else {
      return canvas.toDataURL('image/png');
    }
  }
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

exports.ImageUtils = ImageUtils;
var textureId = 0;

function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
  Object.defineProperty(this, 'id', {
    value: textureId++
  });
  this.uuid = _Math.generateUUID();
  this.name = '';
  this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
  this.mipmaps = [];
  this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
  this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
  this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
  this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
  this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;
  this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
  this.format = format !== undefined ? format : RGBAFormat;
  this.type = type !== undefined ? type : UnsignedByteType;
  this.offset = new Vector2(0, 0);
  this.repeat = new Vector2(1, 1);
  this.center = new Vector2(0, 0);
  this.rotation = 0;
  this.matrixAutoUpdate = true;
  this.matrix = new Matrix3();
  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
  // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
  //
  // Also changing the encoding after already used by a Material will not automatically make the Material
  // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.

  this.encoding = encoding !== undefined ? encoding : LinearEncoding;
  this.version = 0;
  this.onUpdate = null;
}

Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Texture,
  isTexture: true,
  updateMatrix: function () {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  },
  toJSON: function (meta) {
    var isRootObject = meta === undefined || typeof meta === 'string';

    if (!isRootObject && meta.textures[this.uuid] !== undefined) {
      return meta.textures[this.uuid];
    }

    var output = {
      metadata: {
        version: 4.5,
        type: 'Texture',
        generator: 'Texture.toJSON'
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };

    if (this.image !== undefined) {
      // TODO: Move to THREE.Image
      var image = this.image;

      if (image.uuid === undefined) {
        image.uuid = _Math.generateUUID(); // UGH
      }

      if (!isRootObject && meta.images[image.uuid] === undefined) {
        var url;

        if (Array.isArray(image)) {
          // process array of images e.g. CubeTexture
          url = [];

          for (var i = 0, l = image.length; i < l; i++) {
            url.push(ImageUtils.getDataURL(image[i]));
          }
        } else {
          // process single image
          url = ImageUtils.getDataURL(image);
        }

        meta.images[image.uuid] = {
          uuid: image.uuid,
          url: url
        };
      }

      output.image = image.uuid;
    }

    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }

    return output;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  },
  transformUv: function (uv) {
    if (this.mapping !== UVMapping) return uv;
    uv.applyMatrix3(this.matrix);

    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;

        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;

        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }

          break;
      }
    }

    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;

        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;

        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }

          break;
      }
    }

    if (this.flipY) {
      uv.y = 1 - uv.y;
    }

    return uv;
  }
});
Object.defineProperty(Texture.prototype, "needsUpdate", {
  set: function (value) {
    if (value === true) this.version++;
  }
});
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector4(x, y, z, w) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = w !== undefined ? w : 1;
}

Object.defineProperties(Vector4.prototype, {
  "width": {
    get: function () {
      return this.z;
    },
    set: function (value) {
      this.z = value;
    }
  },
  "height": {
    get: function () {
      return this.w;
    },
    set: function (value) {
      this.w = value;
    }
  }
});
Object.assign(Vector4.prototype, {
  isVector4: true,
  set: function (x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  },
  setScalar: function (scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setZ: function (z) {
    this.z = z;
    return this;
  },
  setW: function (w) {
    this.w = w;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      case 2:
        this.z = value;
        break;

      case 3:
        this.w = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  },
  getComponent: function (index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      case 3:
        return this.w;

      default:
        throw new Error('index is out of range: ' + index);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y, this.z, this.w);
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== undefined ? v.w : 1;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  },
  addScaledVector: function (v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  },
  subScalar: function (s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  },
  multiplyScalar: function (scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  },
  applyMatrix4: function (m) {
    var x = this.x,
        y = this.y,
        z = this.z,
        w = this.w;
    var e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  },
  divideScalar: function (scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  setAxisAngleFromQuaternion: function (q) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
    // q is assumed to be normalized
    this.w = 2 * Math.acos(q.w);
    var s = Math.sqrt(1 - q.w * q.w);

    if (s < 0.0001) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }

    return this;
  },
  setAxisAngleFromRotationMatrix: function (m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    var angle,
        x,
        y,
        z,
        // variables for result
    epsilon = 0.01,
        // margin to allow for rounding errors
    epsilon2 = 0.1,
        // margin to distinguish between 0 and 180 degrees
    te = m.elements,
        m11 = te[0],
        m12 = te[4],
        m13 = te[8],
        m21 = te[1],
        m22 = te[5],
        m23 = te[9],
        m31 = te[2],
        m32 = te[6],
        m33 = te[10];

    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      // singularity found
      // first check for identity matrix which must have +1 for all terms
      // in leading diagonal and zero in other terms
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        // this singularity is identity matrix so angle = 0
        this.set(1, 0, 0, 0);
        return this; // zero angle, arbitrary axis
      } // otherwise this singularity is angle = 180


      angle = Math.PI;
      var xx = (m11 + 1) / 2;
      var yy = (m22 + 1) / 2;
      var zz = (m33 + 1) / 2;
      var xy = (m12 + m21) / 4;
      var xz = (m13 + m31) / 4;
      var yz = (m23 + m32) / 4;

      if (xx > yy && xx > zz) {
        // m11 is the largest diagonal term
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        // m22 is the largest diagonal term
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        // m33 is the largest diagonal term so base result on this
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }

      this.set(x, y, z, angle);
      return this; // return 180 deg rotation
    } // as we have reached here there are no singularities so we can handle normally


    var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

    if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be
    // caught by singularity test above, but I've left it in just in case

    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  },
  min: function (v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  },
  max: function (v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  },
  clamp: function (min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  },
  clampScalar: function (minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  },
  clampLength: function (min, max) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  },
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  },
  roundToZero: function () {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  },
  negate: function () {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  manhattanLength: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function (length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  },
  lerpVectors: function (v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  },
  fromBufferAttribute: function (attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
});
/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/

function WebGLRenderTarget(width, height, options) {
  this.width = width;
  this.height = height;
  this.scissor = new Vector4(0, 0, width, height);
  this.scissorTest = false;
  this.viewport = new Vector4(0, 0, width, height);
  options = options || {};
  this.texture = new Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
  this.texture.image = {};
  this.texture.image.width = width;
  this.texture.image.height = height;
  this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
  this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
  this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
  this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
}

WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: WebGLRenderTarget,
  isWebGLRenderTarget: true,
  setSize: function (width, height) {
    if (this.width !== width || this.height !== height) {
      this.width = width;
      this.height = height;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.dispose();
    }

    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.width = source.width;
    this.height = source.height;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
/**
 * @author Mugen87 / https://github.com/Mugen87
 * @author Matt DesLauriers / @mattdesl
 */

function WebGLMultisampleRenderTarget(width, height, options) {
  WebGLRenderTarget.call(this, width, height, options);
  this.samples = 4;
}

WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
  constructor: WebGLMultisampleRenderTarget,
  isWebGLMultisampleRenderTarget: true,
  copy: function (source) {
    WebGLRenderTarget.prototype.copy.call(this, source);
    this.samples = source.samples;
    return this;
  }
});

var _v1 = new Vector3();

var _m1 = new Matrix4();

var _zero = new Vector3(0, 0, 0);

var _one = new Vector3(1, 1, 1);

var _x = new Vector3();

var _y = new Vector3();

var _z = new Vector3();
/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */


function Matrix4() {
  this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

  if (arguments.length > 0) {
    console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
  }
}

Object.assign(Matrix4.prototype, {
  isMatrix4: true,
  set: function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    var te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  clone: function () {
    return new Matrix4().fromArray(this.elements);
  },
  copy: function (m) {
    var te = this.elements;
    var me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  },
  copyPosition: function (m) {
    var te = this.elements,
        me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  },
  extractBasis: function (xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  },
  makeBasis: function (xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  },
  extractRotation: function (m) {
    // this method does not support reflection matrices
    var te = this.elements;
    var me = m.elements;

    var scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();

    var scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();

    var scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();

    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  },
  makeRotationFromEuler: function (euler) {
    if (!(euler && euler.isEuler)) {
      console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
    }

    var te = this.elements;
    var x = euler.x,
        y = euler.y,
        z = euler.z;
    var a = Math.cos(x),
        b = Math.sin(x);
    var c = Math.cos(y),
        d = Math.sin(y);
    var e = Math.cos(z),
        f = Math.sin(z);

    if (euler.order === 'XYZ') {
      var ae = a * e,
          af = a * f,
          be = b * e,
          bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === 'YXZ') {
      var ce = c * e,
          cf = c * f,
          de = d * e,
          df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === 'ZXY') {
      var ce = c * e,
          cf = c * f,
          de = d * e,
          df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === 'ZYX') {
      var ae = a * e,
          af = a * f,
          be = b * e,
          bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === 'YZX') {
      var ac = a * c,
          ad = a * d,
          bc = b * c,
          bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === 'XZY') {
      var ac = a * c,
          ad = a * d,
          bc = b * c,
          bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    } // bottom row


    te[3] = 0;
    te[7] = 0;
    te[11] = 0; // last column

    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  },
  makeRotationFromQuaternion: function (q) {
    return this.compose(_zero, q, _one);
  },
  lookAt: function (eye, target, up) {
    var te = this.elements;

    _z.subVectors(eye, target);

    if (_z.lengthSq() === 0) {
      // eye and target are in the same position
      _z.z = 1;
    }

    _z.normalize();

    _x.crossVectors(up, _z);

    if (_x.lengthSq() === 0) {
      // up and z are parallel
      if (Math.abs(up.z) === 1) {
        _z.x += 0.0001;
      } else {
        _z.z += 0.0001;
      }

      _z.normalize();

      _x.crossVectors(up, _z);
    }

    _x.normalize();

    _y.crossVectors(_z, _x);

    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  },
  multiply: function (m, n) {
    if (n !== undefined) {
      console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
      return this.multiplyMatrices(m, n);
    }

    return this.multiplyMatrices(this, m);
  },
  premultiply: function (m) {
    return this.multiplyMatrices(m, this);
  },
  multiplyMatrices: function (a, b) {
    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;
    var a11 = ae[0],
        a12 = ae[4],
        a13 = ae[8],
        a14 = ae[12];
    var a21 = ae[1],
        a22 = ae[5],
        a23 = ae[9],
        a24 = ae[13];
    var a31 = ae[2],
        a32 = ae[6],
        a33 = ae[10],
        a34 = ae[14];
    var a41 = ae[3],
        a42 = ae[7],
        a43 = ae[11],
        a44 = ae[15];
    var b11 = be[0],
        b12 = be[4],
        b13 = be[8],
        b14 = be[12];
    var b21 = be[1],
        b22 = be[5],
        b23 = be[9],
        b24 = be[13];
    var b31 = be[2],
        b32 = be[6],
        b33 = be[10],
        b34 = be[14];
    var b41 = be[3],
        b42 = be[7],
        b43 = be[11],
        b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  },
  multiplyScalar: function (s) {
    var te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  },
  applyToBufferAttribute: function (attribute) {
    for (var i = 0, l = attribute.count; i < l; i++) {
      _v1.x = attribute.getX(i);
      _v1.y = attribute.getY(i);
      _v1.z = attribute.getZ(i);

      _v1.applyMatrix4(this);

      attribute.setXYZ(i, _v1.x, _v1.y, _v1.z);
    }

    return attribute;
  },
  determinant: function () {
    var te = this.elements;
    var n11 = te[0],
        n12 = te[4],
        n13 = te[8],
        n14 = te[12];
    var n21 = te[1],
        n22 = te[5],
        n23 = te[9],
        n24 = te[13];
    var n31 = te[2],
        n32 = te[6],
        n33 = te[10],
        n34 = te[14];
    var n41 = te[3],
        n42 = te[7],
        n43 = te[11],
        n44 = te[15]; //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  },
  transpose: function () {
    var te = this.elements;
    var tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  },
  setPosition: function (x, y, z) {
    var te = this.elements;

    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }

    return this;
  },
  getInverse: function (m, throwOnDegenerate) {
    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    var te = this.elements,
        me = m.elements,
        n11 = me[0],
        n21 = me[1],
        n31 = me[2],
        n41 = me[3],
        n12 = me[4],
        n22 = me[5],
        n32 = me[6],
        n42 = me[7],
        n13 = me[8],
        n23 = me[9],
        n33 = me[10],
        n43 = me[11],
        n14 = me[12],
        n24 = me[13],
        n34 = me[14],
        n44 = me[15],
        t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
        t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
        t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
        t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

    if (det === 0) {
      var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

      if (throwOnDegenerate === true) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }

      return this.identity();
    }

    var detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  },
  scale: function (v) {
    var te = this.elements;
    var x = v.x,
        y = v.y,
        z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  },
  getMaxScaleOnAxis: function () {
    var te = this.elements;
    var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  },
  makeTranslation: function (x, y, z) {
    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    return this;
  },
  makeRotationX: function (theta) {
    var c = Math.cos(theta),
        s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationY: function (theta) {
    var c = Math.cos(theta),
        s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationZ: function (theta) {
    var c = Math.cos(theta),
        s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationAxis: function (axis, angle) {
    // Based on http://www.gamedev.net/reference/articles/article1199.asp
    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var t = 1 - c;
    var x = axis.x,
        y = axis.y,
        z = axis.z;
    var tx = t * x,
        ty = t * y;
    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    return this;
  },
  makeScale: function (x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  },
  makeShear: function (x, y, z) {
    this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
    return this;
  },
  compose: function (position, quaternion, scale) {
    var te = this.elements;
    var x = quaternion._x,
        y = quaternion._y,
        z = quaternion._z,
        w = quaternion._w;
    var x2 = x + x,
        y2 = y + y,
        z2 = z + z;
    var xx = x * x2,
        xy = x * y2,
        xz = x * z2;
    var yy = y * y2,
        yz = y * z2,
        zz = z * z2;
    var wx = w * x2,
        wy = w * y2,
        wz = w * z2;
    var sx = scale.x,
        sy = scale.y,
        sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  },
  decompose: function (position, quaternion, scale) {
    var te = this.elements;

    var sx = _v1.set(te[0], te[1], te[2]).length();

    var sy = _v1.set(te[4], te[5], te[6]).length();

    var sz = _v1.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale


    var det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14]; // scale the rotation part

    _m1.copy(this);

    var invSX = 1 / sx;
    var invSY = 1 / sy;
    var invSZ = 1 / sz;
    _m1.elements[0] *= invSX;
    _m1.elements[1] *= invSX;
    _m1.elements[2] *= invSX;
    _m1.elements[4] *= invSY;
    _m1.elements[5] *= invSY;
    _m1.elements[6] *= invSY;
    _m1.elements[8] *= invSZ;
    _m1.elements[9] *= invSZ;
    _m1.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  },
  makePerspective: function (left, right, top, bottom, near, far) {
    if (far === undefined) {
      console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
    }

    var te = this.elements;
    var x = 2 * near / (right - left);
    var y = 2 * near / (top - bottom);
    var a = (right + left) / (right - left);
    var b = (top + bottom) / (top - bottom);
    var c = -(far + near) / (far - near);
    var d = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  },
  makeOrthographic: function (left, right, top, bottom, near, far) {
    var te = this.elements;
    var w = 1.0 / (right - left);
    var h = 1.0 / (top - bottom);
    var p = 1.0 / (far - near);
    var x = (right + left) * w;
    var y = (top + bottom) * h;
    var z = (far + near) * p;
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  },
  equals: function (matrix) {
    var te = this.elements;
    var me = matrix.elements;

    for (var i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;

    for (var i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    var te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

var _matrix = new Matrix4();

var _quaternion$1 = new Quaternion();

function Euler(x, y, z, order) {
  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._order = order || Euler.DefaultOrder;
}

Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
Euler.DefaultOrder = 'XYZ';
Object.defineProperties(Euler.prototype, {
  x: {
    get: function () {
      return this._x;
    },
    set: function (value) {
      this._x = value;

      this._onChangeCallback();
    }
  },
  y: {
    get: function () {
      return this._y;
    },
    set: function (value) {
      this._y = value;

      this._onChangeCallback();
    }
  },
  z: {
    get: function () {
      return this._z;
    },
    set: function (value) {
      this._z = value;

      this._onChangeCallback();
    }
  },
  order: {
    get: function () {
      return this._order;
    },
    set: function (value) {
      this._order = value;

      this._onChangeCallback();
    }
  }
});
Object.assign(Euler.prototype, {
  isEuler: true,
  set: function (x, y, z, order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;

    this._onChangeCallback();

    return this;
  },
  clone: function () {
    return new this.constructor(this._x, this._y, this._z, this._order);
  },
  copy: function (euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;

    this._onChangeCallback();

    return this;
  },
  setFromRotationMatrix: function (m, order, update) {
    var clamp = _Math.clamp; // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var te = m.elements;
    var m11 = te[0],
        m12 = te[4],
        m13 = te[8];
    var m21 = te[1],
        m22 = te[5],
        m23 = te[9];
    var m31 = te[2],
        m32 = te[6],
        m33 = te[10];
    order = order || this._order;

    if (order === 'XYZ') {
      this._y = Math.asin(clamp(m13, -1, 1));

      if (Math.abs(m13) < 0.9999999) {
        this._x = Math.atan2(-m23, m33);
        this._z = Math.atan2(-m12, m11);
      } else {
        this._x = Math.atan2(m32, m22);
        this._z = 0;
      }
    } else if (order === 'YXZ') {
      this._x = Math.asin(-clamp(m23, -1, 1));

      if (Math.abs(m23) < 0.9999999) {
        this._y = Math.atan2(m13, m33);
        this._z = Math.atan2(m21, m22);
      } else {
        this._y = Math.atan2(-m31, m11);
        this._z = 0;
      }
    } else if (order === 'ZXY') {
      this._x = Math.asin(clamp(m32, -1, 1));

      if (Math.abs(m32) < 0.9999999) {
        this._y = Math.atan2(-m31, m33);
        this._z = Math.atan2(-m12, m22);
      } else {
        this._y = 0;
        this._z = Math.atan2(m21, m11);
      }
    } else if (order === 'ZYX') {
      this._y = Math.asin(-clamp(m31, -1, 1));

      if (Math.abs(m31) < 0.9999999) {
        this._x = Math.atan2(m32, m33);
        this._z = Math.atan2(m21, m11);
      } else {
        this._x = 0;
        this._z = Math.atan2(-m12, m22);
      }
    } else if (order === 'YZX') {
      this._z = Math.asin(clamp(m21, -1, 1));

      if (Math.abs(m21) < 0.9999999) {
        this._x = Math.atan2(-m23, m22);
        this._y = Math.atan2(-m31, m11);
      } else {
        this._x = 0;
        this._y = Math.atan2(m13, m33);
      }
    } else if (order === 'XZY') {
      this._z = Math.asin(-clamp(m12, -1, 1));

      if (Math.abs(m12) < 0.9999999) {
        this._x = Math.atan2(m32, m22);
        this._y = Math.atan2(m13, m11);
      } else {
        this._x = Math.atan2(-m23, m33);
        this._y = 0;
      }
    } else {
      console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
    }

    this._order = order;
    if (update !== false) this._onChangeCallback();
    return this;
  },
  setFromQuaternion: function (q, order, update) {
    _matrix.makeRotationFromQuaternion(q);

    return this.setFromRotationMatrix(_matrix, order, update);
  },
  setFromVector3: function (v, order) {
    return this.set(v.x, v.y, v.z, order || this._order);
  },
  reorder: function (newOrder) {
    // WARNING: this discards revolution information -bhouston
    _quaternion$1.setFromEuler(this);

    return this.setFromQuaternion(_quaternion$1, newOrder);
  },
  equals: function (euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  },
  fromArray: function (array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== undefined) this._order = array[3];

    this._onChangeCallback();

    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  },
  toVector3: function (optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  },
  _onChange: function (callback) {
    this._onChangeCallback = callback;
    return this;
  },
  _onChangeCallback: function () {}
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function Layers() {
  this.mask = 1 | 0;
}

Object.assign(Layers.prototype, {
  set: function (channel) {
    this.mask = 1 << channel | 0;
  },
  enable: function (channel) {
    this.mask |= 1 << channel | 0;
  },
  enableAll: function () {
    this.mask = 0xffffffff | 0;
  },
  toggle: function (channel) {
    this.mask ^= 1 << channel | 0;
  },
  disable: function (channel) {
    this.mask &= ~(1 << channel | 0);
  },
  disableAll: function () {
    this.mask = 0;
  },
  test: function (layers) {
    return (this.mask & layers.mask) !== 0;
  }
});
var _object3DId = 0;

var _v1$1 = new Vector3();

var _q1 = new Quaternion();

var _m1$1 = new Matrix4();

var _target = new Vector3();

var _position = new Vector3();

var _scale = new Vector3();

var _quaternion$2 = new Quaternion();

var _xAxis = new Vector3(1, 0, 0);

var _yAxis = new Vector3(0, 1, 0);

var _zAxis = new Vector3(0, 0, 1);

var _addedEvent = {
  type: 'added'
};
var _removedEvent = {
  type: 'removed'
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

function Object3D() {
  Object.defineProperty(this, 'id', {
    value: _object3DId++
  });
  this.uuid = _Math.generateUUID();
  this.name = '';
  this.type = 'Object3D';
  this.parent = null;
  this.children = [];
  this.up = Object3D.DefaultUp.clone();
  var position = new Vector3();
  var rotation = new Euler();
  var quaternion = new Quaternion();
  var scale = new Vector3(1, 1, 1);

  function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
  }

  function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, undefined, false);
  }

  rotation._onChange(onRotationChange);

  quaternion._onChange(onQuaternionChange);

  Object.defineProperties(this, {
    position: {
      configurable: true,
      enumerable: true,
      value: position
    },
    rotation: {
      configurable: true,
      enumerable: true,
      value: rotation
    },
    quaternion: {
      configurable: true,
      enumerable: true,
      value: quaternion
    },
    scale: {
      configurable: true,
      enumerable: true,
      value: scale
    },
    modelViewMatrix: {
      value: new Matrix4()
    },
    normalMatrix: {
      value: new Matrix3()
    }
  });
  this.matrix = new Matrix4();
  this.matrixWorld = new Matrix4();
  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;
  this.layers = new Layers();
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.renderOrder = 0;
  this.userData = {};
}

Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Object3D,
  isObject3D: true,
  onBeforeRender: function () {},
  onAfterRender: function () {},
  applyMatrix: function (matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function (q) {
    this.quaternion.premultiply(q);
    return this;
  },
  setRotationFromAxisAngle: function (axis, angle) {
    // assumes axis is normalized
    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function (euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function (m) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    this.quaternion.setFromRotationMatrix(m);
  },
  setRotationFromQuaternion: function (q) {
    // assumes q is normalized
    this.quaternion.copy(q);
  },
  rotateOnAxis: function (axis, angle) {
    // rotate object on axis in object space
    // axis is assumed to be normalized
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.multiply(_q1);
    return this;
  },
  rotateOnWorldAxis: function (axis, angle) {
    // rotate object on axis in world space
    // axis is assumed to be normalized
    // method assumes no rotated parent
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.premultiply(_q1);
    return this;
  },
  rotateX: function (angle) {
    return this.rotateOnAxis(_xAxis, angle);
  },
  rotateY: function (angle) {
    return this.rotateOnAxis(_yAxis, angle);
  },
  rotateZ: function (angle) {
    return this.rotateOnAxis(_zAxis, angle);
  },
  translateOnAxis: function (axis, distance) {
    // translate object by distance along axis in object space
    // axis is assumed to be normalized
    _v1$1.copy(axis).applyQuaternion(this.quaternion);

    this.position.add(_v1$1.multiplyScalar(distance));
    return this;
  },
  translateX: function (distance) {
    return this.translateOnAxis(_xAxis, distance);
  },
  translateY: function (distance) {
    return this.translateOnAxis(_yAxis, distance);
  },
  translateZ: function (distance) {
    return this.translateOnAxis(_zAxis, distance);
  },
  localToWorld: function (vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function (vector) {
    return vector.applyMatrix4(_m1$1.getInverse(this.matrixWorld));
  },
  lookAt: function (x, y, z) {
    // This method does not support objects having non-uniformly-scaled parent(s)
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }

    var parent = this.parent;
    this.updateWorldMatrix(true, false);

    _position.setFromMatrixPosition(this.matrixWorld);

    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position, this.up);
    }

    this.quaternion.setFromRotationMatrix(_m1$1);

    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);

      _q1.setFromRotationMatrix(_m1$1);

      this.quaternion.premultiply(_q1.inverse());
    }
  },
  add: function (object) {
    if (arguments.length > 1) {
      for (var i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }

      return this;
    }

    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }

    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }

      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }

    return this;
  },
  remove: function (object) {
    if (arguments.length > 1) {
      for (var i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }

      return this;
    }

    var index = this.children.indexOf(object);

    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }

    return this;
  },
  attach: function (object) {
    // adds object as a child of this, while maintaining the object's world transform
    this.updateWorldMatrix(true, false);

    _m1$1.getInverse(this.matrixWorld);

    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);

      _m1$1.multiply(object.parent.matrixWorld);
    }

    object.applyMatrix(_m1$1);
    object.updateWorldMatrix(false, false);
    this.add(object);
    return this;
  },
  getObjectById: function (id) {
    return this.getObjectByProperty('id', id);
  },
  getObjectByName: function (name) {
    return this.getObjectByProperty('name', name);
  },
  getObjectByProperty: function (name, value) {
    if (this[name] === value) return this;

    for (var i = 0, l = this.children.length; i < l; i++) {
      var child = this.children[i];
      var object = child.getObjectByProperty(name, value);

      if (object !== undefined) {
        return object;
      }
    }

    return undefined;
  },
  getWorldPosition: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldPosition() target is now required');
      target = new Vector3();
    }

    this.updateMatrixWorld(true);
    return target.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
      target = new Quaternion();
    }

    this.updateMatrixWorld(true);
    this.matrixWorld.decompose(_position, target, _scale);
    return target;
  },
  getWorldScale: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldScale() target is now required');
      target = new Vector3();
    }

    this.updateMatrixWorld(true);
    this.matrixWorld.decompose(_position, _quaternion$2, target);
    return target;
  },
  getWorldDirection: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldDirection() target is now required');
      target = new Vector3();
    }

    this.updateMatrixWorld(true);
    var e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  },
  raycast: function () {},
  traverse: function (callback) {
    callback(this);
    var children = this.children;

    for (var i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  },
  traverseVisible: function (callback) {
    if (this.visible === false) return;
    callback(this);
    var children = this.children;

    for (var i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  },
  traverseAncestors: function (callback) {
    var parent = this.parent;

    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  },
  updateMatrix: function () {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function (force) {
    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }

      this.matrixWorldNeedsUpdate = false;
      force = true;
    } // update children


    var children = this.children;

    for (var i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(force);
    }
  },
  updateWorldMatrix: function (updateParents, updateChildren) {
    var parent = this.parent;

    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }

    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    } // update children


    if (updateChildren === true) {
      var children = this.children;

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].updateWorldMatrix(false, true);
      }
    }
  },
  toJSON: function (meta) {
    // meta is a string when called from JSON.stringify
    var isRootObject = meta === undefined || typeof meta === 'string';
    var output = {}; // meta is a hash used to collect geometries, materials.
    // not providing it implies that this is the root object
    // being serialized.

    if (isRootObject) {
      // initialize meta obj
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {}
      };
      output.metadata = {
        version: 4.5,
        type: 'Object',
        generator: 'Object3D.toJSON'
      };
    } // standard Object3D serialization


    var object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== '') object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

    if (this.isMesh && this.drawMode !== TrianglesDrawMode) object.drawMode = this.drawMode; //

    function serialize(library, element) {
      if (library[element.uuid] === undefined) {
        library[element.uuid] = element.toJSON(meta);
      }

      return element.uuid;
    }

    if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      var parameters = this.geometry.parameters;

      if (parameters !== undefined && parameters.shapes !== undefined) {
        var shapes = parameters.shapes;

        if (Array.isArray(shapes)) {
          for (var i = 0, l = shapes.length; i < l; i++) {
            var shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }

    if (this.material !== undefined) {
      if (Array.isArray(this.material)) {
        var uuids = [];

        for (var i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }

        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    } //


    if (this.children.length > 0) {
      object.children = [];

      for (var i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }

    if (isRootObject) {
      var geometries = extractFromCache(meta.geometries);
      var materials = extractFromCache(meta.materials);
      var textures = extractFromCache(meta.textures);
      var images = extractFromCache(meta.images);
      var shapes = extractFromCache(meta.shapes);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
    }

    output.object = object;
    return output; // extract data from the cache hash
    // remove metadata on each item
    // and return as array

    function extractFromCache(cache) {
      var values = [];

      for (var key in cache) {
        var data = cache[key];
        delete data.metadata;
        values.push(data);
      }

      return values;
    }
  },
  clone: function (recursive) {
    return new this.constructor().copy(this, recursive);
  },
  copy: function (source, recursive) {
    if (recursive === undefined) recursive = true;
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));

    if (recursive === true) {
      for (var i = 0; i < source.children.length; i++) {
        var child = source.children[i];
        this.add(child.clone());
      }
    }

    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function Scene() {
  Object3D.call(this);
  this.type = 'Scene';
  this.background = null;
  this.fog = null;
  this.overrideMaterial = null;
  this.autoUpdate = true; // checked by the renderer

  if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
      detail: this
    })); // eslint-disable-line no-undef

  }
}

Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Scene,
  isScene: true,
  copy: function (source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  },
  toJSON: function (meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    if (this.background !== null) data.object.background = this.background.toJSON(meta);
    if (this.fog !== null) data.object.fog = this.fog.toJSON();
    return data;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
var _points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];

var _vector$2 = new Vector3(); // triangle centered vertices


var _v0 = new Vector3();

var _v1$2 = new Vector3();

var _v2 = new Vector3(); // triangle edge vectors


var _f0 = new Vector3();

var _f1 = new Vector3();

var _f2 = new Vector3();

var _center = new Vector3();

var _extents = new Vector3();

var _triangleNormal = new Vector3();

var _testAxis = new Vector3();
/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */


function Box3(min, max) {
  this.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);
  this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
}

Object.assign(Box3.prototype, {
  isBox3: true,
  set: function (min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  },
  setFromArray: function (array) {
    var minX = +Infinity;
    var minY = +Infinity;
    var minZ = +Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    var maxZ = -Infinity;

    for (var i = 0, l = array.length; i < l; i += 3) {
      var x = array[i];
      var y = array[i + 1];
      var z = array[i + 2];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }

    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  },
  setFromBufferAttribute: function (attribute) {
    var minX = +Infinity;
    var minY = +Infinity;
    var minZ = +Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    var maxZ = -Infinity;

    for (var i = 0, l = attribute.count; i < l; i++) {
      var x = attribute.getX(i);
      var y = attribute.getY(i);
      var z = attribute.getZ(i);
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }

    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  },
  setFromPoints: function (points) {
    this.makeEmpty();

    for (var i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }

    return this;
  },
  setFromCenterAndSize: function (center, size) {
    var halfSize = _vector$2.copy(size).multiplyScalar(0.5);

    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  },
  setFromObject: function (object) {
    this.makeEmpty();
    return this.expandByObject(object);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = this.min.z = +Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  },
  isEmpty: function () {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  getCenter: function (target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .getCenter() target is now required');
      target = new Vector3();
    }

    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function (target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .getSize() target is now required');
      target = new Vector3();
    }

    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  },
  expandByPoint: function (point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function (vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function (scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  },
  expandByObject: function (object) {
    var i, l; // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and children's, world transforms

    object.updateWorldMatrix(false, false);
    var geometry = object.geometry;

    if (geometry !== undefined) {
      if (geometry.isGeometry) {
        var vertices = geometry.vertices;

        for (i = 0, l = vertices.length; i < l; i++) {
          _vector$2.copy(vertices[i]);

          _vector$2.applyMatrix4(object.matrixWorld);

          this.expandByPoint(_vector$2);
        }
      } else if (geometry.isBufferGeometry) {
        var attribute = geometry.attributes.position;

        if (attribute !== undefined) {
          for (i = 0, l = attribute.count; i < l; i++) {
            _vector$2.fromBufferAttribute(attribute, i).applyMatrix4(object.matrixWorld);

            this.expandByPoint(_vector$2);
          }
        }
      }
    } //


    var children = object.children;

    for (i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i]);
    }

    return this;
  },
  containsPoint: function (point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  },
  containsBox: function (box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  },
  getParameter: function (point, target) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.
    if (target === undefined) {
      console.warn('THREE.Box3: .getParameter() target is now required');
      target = new Vector3();
    }

    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  },
  intersectsBox: function (box) {
    // using 6 splitting planes to rule out intersections.
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  },
  intersectsSphere: function (sphere) {
    // Find the point on the AABB closest to the sphere center.
    this.clampPoint(sphere.center, _vector$2); // If that point is inside the sphere, the AABB and sphere intersect.

    return _vector$2.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  },
  intersectsPlane: function (plane) {
    // We compute the minimum and maximum dot product values. If those values
    // are on the same side (back or front) of the plane, then there is no intersection.
    var min, max;

    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }

    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }

    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }

    return min <= -plane.constant && max >= -plane.constant;
  },
  intersectsTriangle: function (triangle) {
    if (this.isEmpty()) {
      return false;
    } // compute box center and extents


    this.getCenter(_center);

    _extents.subVectors(this.max, _center); // translate triangle to aabb origin


    _v0.subVectors(triangle.a, _center);

    _v1$2.subVectors(triangle.b, _center);

    _v2.subVectors(triangle.c, _center); // compute edge vectors for triangle


    _f0.subVectors(_v1$2, _v0);

    _f1.subVectors(_v2, _v1$2);

    _f2.subVectors(_v0, _v2); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)


    var axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];

    if (!satForAxes(axes, _v0, _v1$2, _v2, _extents)) {
      return false;
    } // test 3 face normals from the aabb


    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    if (!satForAxes(axes, _v0, _v1$2, _v2, _extents)) {
      return false;
    } // finally testing the face normal of the triangle
    // use already existing triangle edge vectors here


    _triangleNormal.crossVectors(_f0, _f1);

    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0, _v1$2, _v2, _extents);
  },
  clampPoint: function (point, target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .clampPoint() target is now required');
      target = new Vector3();
    }

    return target.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function (point) {
    var clampedPoint = _vector$2.copy(point).clamp(this.min, this.max);

    return clampedPoint.sub(point).length();
  },
  getBoundingSphere: function (target) {
    if (target === undefined) {
      console.error('THREE.Box3: .getBoundingSphere() target is now required'); //target = new Sphere(); // removed to avoid cyclic dependency
    }

    this.getCenter(target.center);
    target.radius = this.getSize(_vector$2).length() * 0.5;
    return target;
  },
  intersect: function (box) {
    this.min.max(box.min);
    this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

    if (this.isEmpty()) this.makeEmpty();
    return this;
  },
  union: function (box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  applyMatrix4: function (matrix) {
    // transform of empty box is an empty box.
    if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000


    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001


    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010


    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011


    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100


    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101


    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110


    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111


    this.setFromPoints(_points);
    return this;
  },
  translate: function (offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  },
  equals: function (box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
});

function satForAxes(axes, v0, v1, v2, extents) {
  var i, j;

  for (i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i); // project the aabb onto the seperating axis


    var r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the seperating axis

    var p0 = v0.dot(_testAxis);
    var p1 = v1.dot(_testAxis);
    var p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      // points of the projected triangle are outside the projected half-length of the aabb
      // the axis is seperating and we can exit
      return false;
    }
  }

  return true;
}

var _box = new Box3();
/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */


function Sphere(center, radius) {
  this.center = center !== undefined ? center : new Vector3();
  this.radius = radius !== undefined ? radius : 0;
}

Object.assign(Sphere.prototype, {
  set: function (center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  },
  setFromPoints: function (points, optionalCenter) {
    var center = this.center;

    if (optionalCenter !== undefined) {
      center.copy(optionalCenter);
    } else {
      _box.setFromPoints(points).getCenter(center);
    }

    var maxRadiusSq = 0;

    for (var i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }

    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  },
  empty: function () {
    return this.radius <= 0;
  },
  containsPoint: function (point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function (point) {
    return point.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function (sphere) {
    var radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  },
  intersectsBox: function (box) {
    return box.intersectsSphere(this);
  },
  intersectsPlane: function (plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  },
  clampPoint: function (point, target) {
    var deltaLengthSq = this.center.distanceToSquared(point);

    if (target === undefined) {
      console.warn('THREE.Sphere: .clampPoint() target is now required');
      target = new Vector3();
    }

    target.copy(point);

    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }

    return target;
  },
  getBoundingBox: function (target) {
    if (target === undefined) {
      console.warn('THREE.Sphere: .getBoundingBox() target is now required');
      target = new Box3();
    }

    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  },
  applyMatrix4: function (matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  },
  translate: function (offset) {
    this.center.add(offset);
    return this;
  },
  equals: function (sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
});

var _vector$3 = new Vector3();

var _segCenter = new Vector3();

var _segDir = new Vector3();

var _diff = new Vector3();

var _edge1 = new Vector3();

var _edge2 = new Vector3();

var _normal = new Vector3();
/**
 * @author bhouston / http://clara.io
 */


function Ray(origin, direction) {
  this.origin = origin !== undefined ? origin : new Vector3();
  this.direction = direction !== undefined ? direction : new Vector3();
}

Object.assign(Ray.prototype, {
  set: function (origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  },
  at: function (t, target) {
    if (target === undefined) {
      console.warn('THREE.Ray: .at() target is now required');
      target = new Vector3();
    }

    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
  },
  lookAt: function (v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  },
  recast: function (t) {
    this.origin.copy(this.at(t, _vector$3));
    return this;
  },
  closestPointToPoint: function (point, target) {
    if (target === undefined) {
      console.warn('THREE.Ray: .closestPointToPoint() target is now required');
      target = new Vector3();
    }

    target.subVectors(point, this.origin);
    var directionDistance = target.dot(this.direction);

    if (directionDistance < 0) {
      return target.copy(this.origin);
    }

    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  },
  distanceToPoint: function (point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  },
  distanceSqToPoint: function (point) {
    var directionDistance = _vector$3.subVectors(point, this.origin).dot(this.direction); // point behind the ray


    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }

    _vector$3.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

    return _vector$3.distanceToSquared(point);
  },
  distanceSqToSegment: function (v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
    // It returns the min distance between the ray and the segment
    // defined by v0 and v1
    // It can also set two optional targets :
    // - The closest point on the ray
    // - The closest point on the segment
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);

    _segDir.copy(v1).sub(v0).normalize();

    _diff.copy(this.origin).sub(_segCenter);

    var segExtent = v0.distanceTo(v1) * 0.5;
    var a01 = -this.direction.dot(_segDir);

    var b0 = _diff.dot(this.direction);

    var b1 = -_diff.dot(_segDir);

    var c = _diff.lengthSq();

    var det = Math.abs(1 - a01 * a01);
    var s0, s1, sqrDist, extDet;

    if (det > 0) {
      // The ray and segment are not parallel.
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;

      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            // region 0
            // Minimum at interior points of ray and segment.
            var invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            // region 1
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          // region 5
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          // region 4
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          // region 3
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          // region 2
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      // Ray and segment are parallel.
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }

    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }

    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }

    return sqrDist;
  },
  intersectSphere: function (sphere, target) {
    _vector$3.subVectors(sphere.center, this.origin);

    var tca = _vector$3.dot(this.direction);

    var d2 = _vector$3.dot(_vector$3) - tca * tca;
    var radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2) return null;
    var thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere

    var t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere

    var t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null

    if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:
    // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
    // in order to always return an intersect point that is in front of the ray.

    if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0

    return this.at(t0, target);
  },
  intersectsSphere: function (sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  },
  distanceToPlane: function (plane) {
    var denominator = plane.normal.dot(this.direction);

    if (denominator === 0) {
      // line is coplanar, return origin
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      } // Null is preferable to undefined since undefined means.... it is undefined


      return null;
    }

    var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane

    return t >= 0 ? t : null;
  },
  intersectPlane: function (plane, target) {
    var t = this.distanceToPlane(plane);

    if (t === null) {
      return null;
    }

    return this.at(t, target);
  },
  intersectsPlane: function (plane) {
    // check if the ray lies on the plane first
    var distToPoint = plane.distanceToPoint(this.origin);

    if (distToPoint === 0) {
      return true;
    }

    var denominator = plane.normal.dot(this.direction);

    if (denominator * distToPoint < 0) {
      return true;
    } // ray origin is behind the plane (and is pointing behind it)


    return false;
  },
  intersectBox: function (box, target) {
    var tmin, tmax, tymin, tymax, tzmin, tzmax;
    var invdirx = 1 / this.direction.x,
        invdiry = 1 / this.direction.y,
        invdirz = 1 / this.direction.z;
    var origin = this.origin;

    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }

    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }

    if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN
    // (result of 0 * Infinity). x !== x returns true if x is NaN

    if (tymin > tmin || tmin !== tmin) tmin = tymin;
    if (tymax < tmax || tmax !== tmax) tmax = tymax;

    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }

    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)

    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  },
  intersectsBox: function (box) {
    return this.intersectBox(box, _vector$3) !== null;
  },
  intersectTriangle: function (a, b, c, backfaceCulling, target) {
    // Compute the offset origin, edges, and normal.
    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
    _edge1.subVectors(b, a);

    _edge2.subVectors(c, a);

    _normal.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
    // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
    //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
    //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
    //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)


    var DdN = this.direction.dot(_normal);
    var sign;

    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign = 1;
    } else if (DdN < 0) {
      sign = -1;
      DdN = -DdN;
    } else {
      return null;
    }

    _diff.subVectors(this.origin, a);

    var DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection

    if (DdQxE2 < 0) {
      return null;
    }

    var DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection

    if (DdE1xQ < 0) {
      return null;
    } // b1+b2 > 1, no intersection


    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    } // Line intersects triangle, check if ray does.


    var QdN = -sign * _diff.dot(_normal); // t < 0, no intersection


    if (QdN < 0) {
      return null;
    } // Ray intersects triangle.


    return this.at(QdN / DdN, target);
  },
  applyMatrix4: function (matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  },
  equals: function (ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
});
/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

var _v0$1 = new Vector3();

var _v1$3 = new Vector3();

var _v2$1 = new Vector3();

var _v3 = new Vector3();

var _vab = new Vector3();

var _vac = new Vector3();

var _vbc = new Vector3();

var _vap = new Vector3();

var _vbp = new Vector3();

var _vcp = new Vector3();

function Triangle(a, b, c) {
  this.a = a !== undefined ? a : new Vector3();
  this.b = b !== undefined ? b : new Vector3();
  this.c = c !== undefined ? c : new Vector3();
}

Object.assign(Triangle, {
  getNormal: function (a, b, c, target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getNormal() target is now required');
      target = new Vector3();
    }

    target.subVectors(c, b);

    _v0$1.subVectors(a, b);

    target.cross(_v0$1);
    var targetLengthSq = target.lengthSq();

    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }

    return target.set(0, 0, 0);
  },
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  getBarycoord: function (point, a, b, c, target) {
    _v0$1.subVectors(c, a);

    _v1$3.subVectors(b, a);

    _v2$1.subVectors(point, a);

    var dot00 = _v0$1.dot(_v0$1);

    var dot01 = _v0$1.dot(_v1$3);

    var dot02 = _v0$1.dot(_v2$1);

    var dot11 = _v1$3.dot(_v1$3);

    var dot12 = _v1$3.dot(_v2$1);

    var denom = dot00 * dot11 - dot01 * dot01;

    if (target === undefined) {
      console.warn('THREE.Triangle: .getBarycoord() target is now required');
      target = new Vector3();
    } // collinear or singular triangle


    if (denom === 0) {
      // arbitrary location outside of triangle?
      // not sure if this is the best idea, maybe should be returning undefined
      return target.set(-2, -1, -1);
    }

    var invDenom = 1 / denom;
    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    var v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1

    return target.set(1 - u - v, v, u);
  },
  containsPoint: function (point, a, b, c) {
    Triangle.getBarycoord(point, a, b, c, _v3);
    return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
  },
  getUV: function (point, p1, p2, p3, uv1, uv2, uv3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3.x);
    target.addScaledVector(uv2, _v3.y);
    target.addScaledVector(uv3, _v3.z);
    return target;
  },
  isFrontFacing: function (a, b, c, direction) {
    _v0$1.subVectors(c, b);

    _v1$3.subVectors(a, b); // strictly front facing


    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
});
Object.assign(Triangle.prototype, {
  set: function (a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  },
  setFromPointsAndIndices: function (points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  },
  getArea: function () {
    _v0$1.subVectors(this.c, this.b);

    _v1$3.subVectors(this.a, this.b);

    return _v0$1.cross(_v1$3).length() * 0.5;
  },
  getMidpoint: function (target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getMidpoint() target is now required');
      target = new Vector3();
    }

    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  getNormal: function (target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  },
  getPlane: function (target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getPlane() target is now required');
      target = new Vector3();
    }

    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  },
  getBarycoord: function (point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  },
  getUV: function (point, uv1, uv2, uv3, target) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  },
  containsPoint: function (point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  },
  isFrontFacing: function (direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  },
  intersectsBox: function (box) {
    return box.intersectsTriangle(this);
  },
  closestPointToPoint: function (p, target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
      target = new Vector3();
    }

    var a = this.a,
        b = this.b,
        c = this.c;
    var v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
    // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
    // under the accompanying license; see chapter 5.1.5 for detailed explanation.
    // basically, we're distinguishing which of the voronoi regions of the triangle
    // the point lies in with the minimum amount of redundant computation.

    _vab.subVectors(b, a);

    _vac.subVectors(c, a);

    _vap.subVectors(p, a);

    var d1 = _vab.dot(_vap);

    var d2 = _vac.dot(_vap);

    if (d1 <= 0 && d2 <= 0) {
      // vertex region of A; barycentric coords (1, 0, 0)
      return target.copy(a);
    }

    _vbp.subVectors(p, b);

    var d3 = _vab.dot(_vbp);

    var d4 = _vac.dot(_vbp);

    if (d3 >= 0 && d4 <= d3) {
      // vertex region of B; barycentric coords (0, 1, 0)
      return target.copy(b);
    }

    var vc = d1 * d4 - d3 * d2;

    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)

      return target.copy(a).addScaledVector(_vab, v);
    }

    _vcp.subVectors(p, c);

    var d5 = _vab.dot(_vcp);

    var d6 = _vac.dot(_vcp);

    if (d6 >= 0 && d5 <= d6) {
      // vertex region of C; barycentric coords (0, 0, 1)
      return target.copy(c);
    }

    var vb = d5 * d2 - d1 * d6;

    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)

      return target.copy(a).addScaledVector(_vac, w);
    }

    var va = d3 * d6 - d5 * d4;

    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);

      w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)

      return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
    } // face region


    var denom = 1 / (va + vb + vc); // u = va * denom

    v = vb * denom;
    w = vc * denom;
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
  },
  equals: function (triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

var _colorKeywords = {
  'aliceblue': 0xF0F8FF,
  'antiquewhite': 0xFAEBD7,
  'aqua': 0x00FFFF,
  'aquamarine': 0x7FFFD4,
  'azure': 0xF0FFFF,
  'beige': 0xF5F5DC,
  'bisque': 0xFFE4C4,
  'black': 0x000000,
  'blanchedalmond': 0xFFEBCD,
  'blue': 0x0000FF,
  'blueviolet': 0x8A2BE2,
  'brown': 0xA52A2A,
  'burlywood': 0xDEB887,
  'cadetblue': 0x5F9EA0,
  'chartreuse': 0x7FFF00,
  'chocolate': 0xD2691E,
  'coral': 0xFF7F50,
  'cornflowerblue': 0x6495ED,
  'cornsilk': 0xFFF8DC,
  'crimson': 0xDC143C,
  'cyan': 0x00FFFF,
  'darkblue': 0x00008B,
  'darkcyan': 0x008B8B,
  'darkgoldenrod': 0xB8860B,
  'darkgray': 0xA9A9A9,
  'darkgreen': 0x006400,
  'darkgrey': 0xA9A9A9,
  'darkkhaki': 0xBDB76B,
  'darkmagenta': 0x8B008B,
  'darkolivegreen': 0x556B2F,
  'darkorange': 0xFF8C00,
  'darkorchid': 0x9932CC,
  'darkred': 0x8B0000,
  'darksalmon': 0xE9967A,
  'darkseagreen': 0x8FBC8F,
  'darkslateblue': 0x483D8B,
  'darkslategray': 0x2F4F4F,
  'darkslategrey': 0x2F4F4F,
  'darkturquoise': 0x00CED1,
  'darkviolet': 0x9400D3,
  'deeppink': 0xFF1493,
  'deepskyblue': 0x00BFFF,
  'dimgray': 0x696969,
  'dimgrey': 0x696969,
  'dodgerblue': 0x1E90FF,
  'firebrick': 0xB22222,
  'floralwhite': 0xFFFAF0,
  'forestgreen': 0x228B22,
  'fuchsia': 0xFF00FF,
  'gainsboro': 0xDCDCDC,
  'ghostwhite': 0xF8F8FF,
  'gold': 0xFFD700,
  'goldenrod': 0xDAA520,
  'gray': 0x808080,
  'green': 0x008000,
  'greenyellow': 0xADFF2F,
  'grey': 0x808080,
  'honeydew': 0xF0FFF0,
  'hotpink': 0xFF69B4,
  'indianred': 0xCD5C5C,
  'indigo': 0x4B0082,
  'ivory': 0xFFFFF0,
  'khaki': 0xF0E68C,
  'lavender': 0xE6E6FA,
  'lavenderblush': 0xFFF0F5,
  'lawngreen': 0x7CFC00,
  'lemonchiffon': 0xFFFACD,
  'lightblue': 0xADD8E6,
  'lightcoral': 0xF08080,
  'lightcyan': 0xE0FFFF,
  'lightgoldenrodyellow': 0xFAFAD2,
  'lightgray': 0xD3D3D3,
  'lightgreen': 0x90EE90,
  'lightgrey': 0xD3D3D3,
  'lightpink': 0xFFB6C1,
  'lightsalmon': 0xFFA07A,
  'lightseagreen': 0x20B2AA,
  'lightskyblue': 0x87CEFA,
  'lightslategray': 0x778899,
  'lightslategrey': 0x778899,
  'lightsteelblue': 0xB0C4DE,
  'lightyellow': 0xFFFFE0,
  'lime': 0x00FF00,
  'limegreen': 0x32CD32,
  'linen': 0xFAF0E6,
  'magenta': 0xFF00FF,
  'maroon': 0x800000,
  'mediumaquamarine': 0x66CDAA,
  'mediumblue': 0x0000CD,
  'mediumorchid': 0xBA55D3,
  'mediumpurple': 0x9370DB,
  'mediumseagreen': 0x3CB371,
  'mediumslateblue': 0x7B68EE,
  'mediumspringgreen': 0x00FA9A,
  'mediumturquoise': 0x48D1CC,
  'mediumvioletred': 0xC71585,
  'midnightblue': 0x191970,
  'mintcream': 0xF5FFFA,
  'mistyrose': 0xFFE4E1,
  'moccasin': 0xFFE4B5,
  'navajowhite': 0xFFDEAD,
  'navy': 0x000080,
  'oldlace': 0xFDF5E6,
  'olive': 0x808000,
  'olivedrab': 0x6B8E23,
  'orange': 0xFFA500,
  'orangered': 0xFF4500,
  'orchid': 0xDA70D6,
  'palegoldenrod': 0xEEE8AA,
  'palegreen': 0x98FB98,
  'paleturquoise': 0xAFEEEE,
  'palevioletred': 0xDB7093,
  'papayawhip': 0xFFEFD5,
  'peachpuff': 0xFFDAB9,
  'peru': 0xCD853F,
  'pink': 0xFFC0CB,
  'plum': 0xDDA0DD,
  'powderblue': 0xB0E0E6,
  'purple': 0x800080,
  'rebeccapurple': 0x663399,
  'red': 0xFF0000,
  'rosybrown': 0xBC8F8F,
  'royalblue': 0x4169E1,
  'saddlebrown': 0x8B4513,
  'salmon': 0xFA8072,
  'sandybrown': 0xF4A460,
  'seagreen': 0x2E8B57,
  'seashell': 0xFFF5EE,
  'sienna': 0xA0522D,
  'silver': 0xC0C0C0,
  'skyblue': 0x87CEEB,
  'slateblue': 0x6A5ACD,
  'slategray': 0x708090,
  'slategrey': 0x708090,
  'snow': 0xFFFAFA,
  'springgreen': 0x00FF7F,
  'steelblue': 0x4682B4,
  'tan': 0xD2B48C,
  'teal': 0x008080,
  'thistle': 0xD8BFD8,
  'tomato': 0xFF6347,
  'turquoise': 0x40E0D0,
  'violet': 0xEE82EE,
  'wheat': 0xF5DEB3,
  'white': 0xFFFFFF,
  'whitesmoke': 0xF5F5F5,
  'yellow': 0xFFFF00,
  'yellowgreen': 0x9ACD32
};
var _hslA = {
  h: 0,
  s: 0,
  l: 0
};
var _hslB = {
  h: 0,
  s: 0,
  l: 0
};

function Color(r, g, b) {
  if (g === undefined && b === undefined) {
    // r is THREE.Color, hex or string
    return this.set(r);
  }

  return this.setRGB(r, g, b);
}

function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}

function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}

function LinearToSRGB(c) {
  return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}

Object.assign(Color.prototype, {
  isColor: true,
  r: 1,
  g: 1,
  b: 1,
  set: function (value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === 'number') {
      this.setHex(value);
    } else if (typeof value === 'string') {
      this.setStyle(value);
    }

    return this;
  },
  setScalar: function (scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  },
  setHex: function (hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  },
  setRGB: function (r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  },
  setHSL: function (h, s, l) {
    // h,s,l ranges are in 0.0 - 1.0
    h = _Math.euclideanModulo(h, 1);
    s = _Math.clamp(s, 0, 1);
    l = _Math.clamp(l, 0, 1);

    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      var q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }

    return this;
  },
  setStyle: function (style) {
    function handleAlpha(string) {
      if (string === undefined) return;

      if (parseFloat(string) < 1) {
        console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
      }
    }

    var m;

    if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
      // rgb / hsl
      var color;
      var name = m[1];
      var components = m[2];

      switch (name) {
        case 'rgb':
        case 'rgba':
          if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            // rgb(255,0,0) rgba(255,0,0,0.5)
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[5]);
            return this;
          }

          if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[5]);
            return this;
          }

          break;

        case 'hsl':
        case 'hsla':
          if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
            var h = parseFloat(color[1]) / 360;
            var s = parseInt(color[2], 10) / 100;
            var l = parseInt(color[3], 10) / 100;
            handleAlpha(color[5]);
            return this.setHSL(h, s, l);
          }

          break;
      }
    } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
      // hex color
      var hex = m[1];
      var size = hex.length;

      if (size === 3) {
        // #ff0
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        // #ff0000
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }

    if (style && style.length > 0) {
      // color keywords
      var hex = _colorKeywords[style];

      if (hex !== undefined) {
        // red
        this.setHex(hex);
      } else {
        // unknown color
        console.warn('THREE.Color: Unknown color ' + style);
      }
    }

    return this;
  },
  clone: function () {
    return new this.constructor(this.r, this.g, this.b);
  },
  copy: function (color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  },
  copyGammaToLinear: function (color, gammaFactor) {
    if (gammaFactor === undefined) gammaFactor = 2.0;
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  },
  copyLinearToGamma: function (color, gammaFactor) {
    if (gammaFactor === undefined) gammaFactor = 2.0;
    var safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  },
  convertGammaToLinear: function (gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  },
  convertLinearToGamma: function (gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  },
  copySRGBToLinear: function (color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  },
  copyLinearToSRGB: function (color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  },
  convertSRGBToLinear: function () {
    this.copySRGBToLinear(this);
    return this;
  },
  convertLinearToSRGB: function () {
    this.copyLinearToSRGB(this);
    return this;
  },
  getHex: function () {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  },
  getHexString: function () {
    return ('000000' + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function (target) {
    // h,s,l ranges are in 0.0 - 1.0
    if (target === undefined) {
      console.warn('THREE.Color: .getHSL() target is now required');
      target = {
        h: 0,
        s: 0,
        l: 0
      };
    }

    var r = this.r,
        g = this.g,
        b = this.b;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var hue, saturation;
    var lightness = (min + max) / 2.0;

    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      var delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;

        case g:
          hue = (b - r) / delta + 2;
          break;

        case b:
          hue = (r - g) / delta + 4;
          break;
      }

      hue /= 6;
    }

    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  },
  getStyle: function () {
    return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
  },
  offsetHSL: function (h, s, l) {
    this.getHSL(_hslA);
    _hslA.h += h;
    _hslA.s += s;
    _hslA.l += l;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  },
  add: function (color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  },
  addColors: function (color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  },
  addScalar: function (s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  },
  sub: function (color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  },
  multiply: function (color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  },
  multiplyScalar: function (s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  },
  lerp: function (color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  },
  lerpHSL: function (color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);

    var h = _Math.lerp(_hslA.h, _hslB.h, alpha);

    var s = _Math.lerp(_hslA.s, _hslB.s, alpha);

    var l = _Math.lerp(_hslA.l, _hslB.l, alpha);

    this.setHSL(h, s, l);
    return this;
  },
  equals: function (c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  },
  toJSON: function () {
    return this.getHex();
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Face3(a, b, c, normal, color, materialIndex) {
  this.a = a;
  this.b = b;
  this.c = c;
  this.normal = normal && normal.isVector3 ? normal : new Vector3();
  this.vertexNormals = Array.isArray(normal) ? normal : [];
  this.color = color && color.isColor ? color : new Color();
  this.vertexColors = Array.isArray(color) ? color : [];
  this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
}

Object.assign(Face3.prototype, {
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.a = source.a;
    this.b = source.b;
    this.c = source.c;
    this.normal.copy(source.normal);
    this.color.copy(source.color);
    this.materialIndex = source.materialIndex;

    for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
      this.vertexNormals[i] = source.vertexNormals[i].clone();
    }

    for (var i = 0, il = source.vertexColors.length; i < il; i++) {
      this.vertexColors[i] = source.vertexColors[i].clone();
    }

    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

var materialId = 0;

function Material() {
  Object.defineProperty(this, 'id', {
    value: materialId++
  });
  this.uuid = _Math.generateUUID();
  this.name = '';
  this.type = 'Material';
  this.fog = true;
  this.lights = true;
  this.blending = NormalBlending;
  this.side = FrontSide;
  this.flatShading = false;
  this.vertexTangents = false;
  this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

  this.opacity = 1;
  this.transparent = false;
  this.blendSrc = SrcAlphaFactor;
  this.blendDst = OneMinusSrcAlphaFactor;
  this.blendEquation = AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;
  this.depthFunc = LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;
  this.stencilFunc = AlwaysStencilFunc;
  this.stencilRef = 0;
  this.stencilMask = 0xff;
  this.stencilFail = KeepStencilOp;
  this.stencilZFail = KeepStencilOp;
  this.stencilZPass = KeepStencilOp;
  this.stencilWrite = false;
  this.clippingPlanes = null;
  this.clipIntersection = false;
  this.clipShadows = false;
  this.shadowSide = null;
  this.colorWrite = true;
  this.precision = null; // override the renderer's default precision for this material

  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.dithering = false;
  this.alphaTest = 0;
  this.premultipliedAlpha = false;
  this.visible = true;
  this.toneMapped = true;
  this.userData = {};
  this.needsUpdate = true;
}

Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Material,
  isMaterial: true,
  onBeforeCompile: function () {},
  setValues: function (values) {
    if (values === undefined) return;

    for (var key in values) {
      var newValue = values[key];

      if (newValue === undefined) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      } // for backward compatability if shading is set in the constructor


      if (key === 'shading') {
        console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }

      var currentValue = this[key];

      if (currentValue === undefined) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }

      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  },
  toJSON: function (meta) {
    var isRoot = meta === undefined || typeof meta === 'string';

    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }

    var data = {
      metadata: {
        version: 4.5,
        type: 'Material',
        generator: 'Material.toJSON'
      }
    }; // standard Material serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== undefined) data.roughness = this.roughness;
    if (this.metalness !== undefined) data.metalness = this.metalness;
    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
    if (this.shininess !== undefined) data.shininess = this.shininess;
    if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;

    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }

    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;

    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }

    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }

    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }

    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }

    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;

    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      data.reflectivity = this.reflectivity; // Scale behind envMap

      data.refractionRatio = this.refractionRatio;
      if (this.combine !== undefined) data.combine = this.combine;
      if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
    }

    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }

    if (this.size !== undefined) data.size = this.size;
    if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending) data.blending = this.blending;
    if (this.flatShading === true) data.flatShading = this.flatShading;
    if (this.side !== FrontSide) data.side = this.side;
    if (this.vertexColors !== NoColors) data.vertexColors = this.vertexColors;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilMask = this.stencilMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)

    if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
    if (this.dashSize !== undefined) data.dashSize = this.dashSize;
    if (this.gapSize !== undefined) data.gapSize = this.gapSize;
    if (this.scale !== undefined) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true) data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.morphTargets === true) data.morphTargets = true;
    if (this.morphNormals === true) data.morphNormals = true;
    if (this.skinning === true) data.skinning = true;
    if (this.visible === false) data.visible = false;
    if (this.toneMapped === false) data.toneMapped = false;
    if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON

    function extractFromCache(cache) {
      var values = [];

      for (var key in cache) {
        var data = cache[key];
        delete data.metadata;
        values.push(data);
      }

      return values;
    }

    if (isRoot) {
      var textures = extractFromCache(meta.textures);
      var images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }

    return data;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.name = source.name;
    this.fog = source.fog;
    this.lights = source.lights;
    this.blending = source.blending;
    this.side = source.side;
    this.flatShading = source.flatShading;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWrite = source.stencilWrite;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilMask = source.stencilMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.clipShadows = source.clipShadows;
    this.clipIntersection = source.clipIntersection;
    var srcPlanes = source.clippingPlanes,
        dstPlanes = null;

    if (srcPlanes !== null) {
      var n = srcPlanes.length;
      dstPlanes = new Array(n);

      for (var i = 0; i !== n; ++i) dstPlanes[i] = srcPlanes[i].clone();
    }

    this.clippingPlanes = dstPlanes;
    this.shadowSide = source.shadowSide;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

function MeshBasicMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshBasicMaterial';
  this.color = new Color(0xffffff); // emissive

  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.lights = false;
  this.setValues(parameters);
}

MeshBasicMaterial.prototype = Object.create(Material.prototype);
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

MeshBasicMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */


function BufferAttribute(array, itemSize, normalized) {
  if (Array.isArray(array)) {
    throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
  }

  this.name = '';
  this.array = array;
  this.itemSize = itemSize;
  this.count = array !== undefined ? array.length / itemSize : 0;
  this.normalized = normalized === true;
  this.dynamic = false;
  this.updateRange = {
    offset: 0,
    count: -1
  };
  this.version = 0;
}

Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {
  set: function (value) {
    if (value === true) this.version++;
  }
});
Object.assign(BufferAttribute.prototype, {
  isBufferAttribute: true,
  onUploadCallback: function () {},
  setArray: function (array) {
    if (Array.isArray(array)) {
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    }

    this.count = array !== undefined ? array.length / this.itemSize : 0;
    this.array = array;
    return this;
  },
  setDynamic: function (value) {
    this.dynamic = value;
    return this;
  },
  copy: function (source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.dynamic = source.dynamic;
    return this;
  },
  copyAt: function (index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;

    for (var i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }

    return this;
  },
  copyArray: function (array) {
    this.array.set(array);
    return this;
  },
  copyColorsArray: function (colors) {
    var array = this.array,
        offset = 0;

    for (var i = 0, l = colors.length; i < l; i++) {
      var color = colors[i];

      if (color === undefined) {
        console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
        color = new Color();
      }

      array[offset++] = color.r;
      array[offset++] = color.g;
      array[offset++] = color.b;
    }

    return this;
  },
  copyVector2sArray: function (vectors) {
    var array = this.array,
        offset = 0;

    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
        vector = new Vector2();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }

    return this;
  },
  copyVector3sArray: function (vectors) {
    var array = this.array,
        offset = 0;

    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
        vector = new Vector3();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }

    return this;
  },
  copyVector4sArray: function (vectors) {
    var array = this.array,
        offset = 0;

    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
        vector = new Vector4();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }

    return this;
  },
  set: function (value, offset) {
    if (offset === undefined) offset = 0;
    this.array.set(value, offset);
    return this;
  },
  getX: function (index) {
    return this.array[index * this.itemSize];
  },
  setX: function (index, x) {
    this.array[index * this.itemSize] = x;
    return this;
  },
  getY: function (index) {
    return this.array[index * this.itemSize + 1];
  },
  setY: function (index, y) {
    this.array[index * this.itemSize + 1] = y;
    return this;
  },
  getZ: function (index) {
    return this.array[index * this.itemSize + 2];
  },
  setZ: function (index, z) {
    this.array[index * this.itemSize + 2] = z;
    return this;
  },
  getW: function (index) {
    return this.array[index * this.itemSize + 3];
  },
  setW: function (index, w) {
    this.array[index * this.itemSize + 3] = w;
    return this;
  },
  setXY: function (index, x, y) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  },
  setXYZ: function (index, x, y, z) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  },
  setXYZW: function (index, x, y, z, w) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  },
  onUpload: function (callback) {
    this.onUploadCallback = callback;
    return this;
  },
  clone: function () {
    return new this.constructor(this.array, this.itemSize).copy(this);
  },
  toJSON: function () {
    return {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
  }
}); //

function Int8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}

Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;

function Uint8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}

Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;

function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}

Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;

function Int16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}

Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;

function Uint16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}

Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;

function Int32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}

Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;

function Uint32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}

Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

function Float32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}

Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;

function Float64BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}

Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectGeometry() {
  this.vertices = [];
  this.normals = [];
  this.colors = [];
  this.uvs = [];
  this.uvs2 = [];
  this.groups = [];
  this.morphTargets = {};
  this.skinWeights = [];
  this.skinIndices = []; // this.lineDistances = [];

  this.boundingBox = null;
  this.boundingSphere = null; // update flags

  this.verticesNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.groupsNeedUpdate = false;
}

Object.assign(DirectGeometry.prototype, {
  computeGroups: function (geometry) {
    var group;
    var groups = [];
    var materialIndex = undefined;
    var faces = geometry.faces;

    for (var i = 0; i < faces.length; i++) {
      var face = faces[i]; // materials

      if (face.materialIndex !== materialIndex) {
        materialIndex = face.materialIndex;

        if (group !== undefined) {
          group.count = i * 3 - group.start;
          groups.push(group);
        }

        group = {
          start: i * 3,
          materialIndex: materialIndex
        };
      }
    }

    if (group !== undefined) {
      group.count = i * 3 - group.start;
      groups.push(group);
    }

    this.groups = groups;
  },
  fromGeometry: function (geometry) {
    var faces = geometry.faces;
    var vertices = geometry.vertices;
    var faceVertexUvs = geometry.faceVertexUvs;
    var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
    var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs

    var morphTargets = geometry.morphTargets;
    var morphTargetsLength = morphTargets.length;
    var morphTargetsPosition;

    if (morphTargetsLength > 0) {
      morphTargetsPosition = [];

      for (var i = 0; i < morphTargetsLength; i++) {
        morphTargetsPosition[i] = {
          name: morphTargets[i].name,
          data: []
        };
      }

      this.morphTargets.position = morphTargetsPosition;
    }

    var morphNormals = geometry.morphNormals;
    var morphNormalsLength = morphNormals.length;
    var morphTargetsNormal;

    if (morphNormalsLength > 0) {
      morphTargetsNormal = [];

      for (var i = 0; i < morphNormalsLength; i++) {
        morphTargetsNormal[i] = {
          name: morphNormals[i].name,
          data: []
        };
      }

      this.morphTargets.normal = morphTargetsNormal;
    } // skins


    var skinIndices = geometry.skinIndices;
    var skinWeights = geometry.skinWeights;
    var hasSkinIndices = skinIndices.length === vertices.length;
    var hasSkinWeights = skinWeights.length === vertices.length; //

    if (vertices.length > 0 && faces.length === 0) {
      console.error('THREE.DirectGeometry: Faceless geometries are not supported.');
    }

    for (var i = 0; i < faces.length; i++) {
      var face = faces[i];
      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
      var vertexNormals = face.vertexNormals;

      if (vertexNormals.length === 3) {
        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
      } else {
        var normal = face.normal;
        this.normals.push(normal, normal, normal);
      }

      var vertexColors = face.vertexColors;

      if (vertexColors.length === 3) {
        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
      } else {
        var color = face.color;
        this.colors.push(color, color, color);
      }

      if (hasFaceVertexUv === true) {
        var vertexUvs = faceVertexUvs[0][i];

        if (vertexUvs !== undefined) {
          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
          this.uvs.push(new Vector2(), new Vector2(), new Vector2());
        }
      }

      if (hasFaceVertexUv2 === true) {
        var vertexUvs = faceVertexUvs[1][i];

        if (vertexUvs !== undefined) {
          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
        }
      } // morphs


      for (var j = 0; j < morphTargetsLength; j++) {
        var morphTarget = morphTargets[j].vertices;
        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
      }

      for (var j = 0; j < morphNormalsLength; j++) {
        var morphNormal = morphNormals[j].vertexNormals[i];
        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
      } // skins


      if (hasSkinIndices) {
        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
      }

      if (hasSkinWeights) {
        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
      }
    }

    this.computeGroups(geometry);
    this.verticesNeedUpdate = geometry.verticesNeedUpdate;
    this.normalsNeedUpdate = geometry.normalsNeedUpdate;
    this.colorsNeedUpdate = geometry.colorsNeedUpdate;
    this.uvsNeedUpdate = geometry.uvsNeedUpdate;
    this.groupsNeedUpdate = geometry.groupsNeedUpdate;

    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }

    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }

    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function arrayMax(array) {
  if (array.length === 0) return -Infinity;
  var max = array[0];

  for (var i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max) max = array[i];
  }

  return max;
}
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */


var _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

var _m1$2 = new Matrix4();

var _obj = new Object3D();

var _offset = new Vector3();

var _box$1 = new Box3();

var _boxMorphTargets = new Box3();

var _vector$4 = new Vector3();

function BufferGeometry() {
  Object.defineProperty(this, 'id', {
    value: _bufferGeometryId += 2
  });
  this.uuid = _Math.generateUUID();
  this.name = '';
  this.type = 'BufferGeometry';
  this.index = null;
  this.attributes = {};
  this.morphAttributes = {};
  this.groups = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.drawRange = {
    start: 0,
    count: Infinity
  };
  this.userData = {};
}

BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: BufferGeometry,
  isBufferGeometry: true,
  getIndex: function () {
    return this.index;
  },
  setIndex: function (index) {
    if (Array.isArray(index)) {
      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
  },
  addAttribute: function (name, attribute) {
    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
      console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
      return this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
    }

    if (name === 'index') {
      console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
      this.setIndex(attribute);
      return this;
    }

    this.attributes[name] = attribute;
    return this;
  },
  getAttribute: function (name) {
    return this.attributes[name];
  },
  removeAttribute: function (name) {
    delete this.attributes[name];
    return this;
  },
  addGroup: function (start, count, materialIndex) {
    this.groups.push({
      start: start,
      count: count,
      materialIndex: materialIndex !== undefined ? materialIndex : 0
    });
  },
  clearGroups: function () {
    this.groups = [];
  },
  setDrawRange: function (start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  },
  applyMatrix: function (matrix) {
    var position = this.attributes.position;

    if (position !== undefined) {
      matrix.applyToBufferAttribute(position);
      position.needsUpdate = true;
    }

    var normal = this.attributes.normal;

    if (normal !== undefined) {
      var normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normalMatrix.applyToBufferAttribute(normal);
      normal.needsUpdate = true;
    }

    var tangent = this.attributes.tangent;

    if (tangent !== undefined) {
      var normalMatrix = new Matrix3().getNormalMatrix(matrix); // Tangent is vec4, but the '.w' component is a sign value (+1/-1).

      normalMatrix.applyToBufferAttribute(tangent);
      tangent.needsUpdate = true;
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    return this;
  },
  rotateX: function (angle) {
    // rotate geometry around world x-axis
    _m1$2.makeRotationX(angle);

    this.applyMatrix(_m1$2);
    return this;
  },
  rotateY: function (angle) {
    // rotate geometry around world y-axis
    _m1$2.makeRotationY(angle);

    this.applyMatrix(_m1$2);
    return this;
  },
  rotateZ: function (angle) {
    // rotate geometry around world z-axis
    _m1$2.makeRotationZ(angle);

    this.applyMatrix(_m1$2);
    return this;
  },
  translate: function (x, y, z) {
    // translate geometry
    _m1$2.makeTranslation(x, y, z);

    this.applyMatrix(_m1$2);
    return this;
  },
  scale: function (x, y, z) {
    // scale geometry
    _m1$2.makeScale(x, y, z);

    this.applyMatrix(_m1$2);
    return this;
  },
  lookAt: function (vector) {
    _obj.lookAt(vector);

    _obj.updateMatrix();

    this.applyMatrix(_obj.matrix);
    return this;
  },
  center: function () {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  },
  setFromObject: function (object) {
    // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
    var geometry = object.geometry;

    if (object.isPoints || object.isLine) {
      var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
      var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
      this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
      this.addAttribute('color', colors.copyColorsArray(geometry.colors));

      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
        var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
        this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
      }

      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }

      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }
    } else if (object.isMesh) {
      if (geometry && geometry.isGeometry) {
        this.fromGeometry(geometry);
      }
    }

    return this;
  },
  setFromPoints: function (points) {
    var position = [];

    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }

    this.addAttribute('position', new Float32BufferAttribute(position, 3));
    return this;
  },
  updateFromObject: function (object) {
    var geometry = object.geometry;

    if (object.isMesh) {
      var direct = geometry.__directGeometry;

      if (geometry.elementsNeedUpdate === true) {
        direct = undefined;
        geometry.elementsNeedUpdate = false;
      }

      if (direct === undefined) {
        return this.fromGeometry(geometry);
      }

      direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
      direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
      direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
      direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
      direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
      geometry.verticesNeedUpdate = false;
      geometry.normalsNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.uvsNeedUpdate = false;
      geometry.groupsNeedUpdate = false;
      geometry = direct;
    }

    var attribute;

    if (geometry.verticesNeedUpdate === true) {
      attribute = this.attributes.position;

      if (attribute !== undefined) {
        attribute.copyVector3sArray(geometry.vertices);
        attribute.needsUpdate = true;
      }

      geometry.verticesNeedUpdate = false;
    }

    if (geometry.normalsNeedUpdate === true) {
      attribute = this.attributes.normal;

      if (attribute !== undefined) {
        attribute.copyVector3sArray(geometry.normals);
        attribute.needsUpdate = true;
      }

      geometry.normalsNeedUpdate = false;
    }

    if (geometry.colorsNeedUpdate === true) {
      attribute = this.attributes.color;

      if (attribute !== undefined) {
        attribute.copyColorsArray(geometry.colors);
        attribute.needsUpdate = true;
      }

      geometry.colorsNeedUpdate = false;
    }

    if (geometry.uvsNeedUpdate) {
      attribute = this.attributes.uv;

      if (attribute !== undefined) {
        attribute.copyVector2sArray(geometry.uvs);
        attribute.needsUpdate = true;
      }

      geometry.uvsNeedUpdate = false;
    }

    if (geometry.lineDistancesNeedUpdate) {
      attribute = this.attributes.lineDistance;

      if (attribute !== undefined) {
        attribute.copyArray(geometry.lineDistances);
        attribute.needsUpdate = true;
      }

      geometry.lineDistancesNeedUpdate = false;
    }

    if (geometry.groupsNeedUpdate) {
      geometry.computeGroups(object.geometry);
      this.groups = geometry.groups;
      geometry.groupsNeedUpdate = false;
    }

    return this;
  },
  fromGeometry: function (geometry) {
    geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
    return this.fromDirectGeometry(geometry.__directGeometry);
  },
  fromDirectGeometry: function (geometry) {
    var positions = new Float32Array(geometry.vertices.length * 3);
    this.addAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));

    if (geometry.normals.length > 0) {
      var normals = new Float32Array(geometry.normals.length * 3);
      this.addAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
    }

    if (geometry.colors.length > 0) {
      var colors = new Float32Array(geometry.colors.length * 3);
      this.addAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
    }

    if (geometry.uvs.length > 0) {
      var uvs = new Float32Array(geometry.uvs.length * 2);
      this.addAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
    }

    if (geometry.uvs2.length > 0) {
      var uvs2 = new Float32Array(geometry.uvs2.length * 2);
      this.addAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
    } // groups


    this.groups = geometry.groups; // morphs

    for (var name in geometry.morphTargets) {
      var array = [];
      var morphTargets = geometry.morphTargets[name];

      for (var i = 0, l = morphTargets.length; i < l; i++) {
        var morphTarget = morphTargets[i];
        var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
        attribute.name = morphTarget.name;
        array.push(attribute.copyVector3sArray(morphTarget.data));
      }

      this.morphAttributes[name] = array;
    } // skinning


    if (geometry.skinIndices.length > 0) {
      var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
      this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
    }

    if (geometry.skinWeights.length > 0) {
      var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
      this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
    } //


    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }

    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }

    return this;
  },
  computeBoundingBox: function () {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }

    var position = this.attributes.position;
    var morphAttributesPosition = this.morphAttributes.position;

    if (position !== undefined) {
      this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present

      if (morphAttributesPosition) {
        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
          var morphAttribute = morphAttributesPosition[i];

          _box$1.setFromBufferAttribute(morphAttribute);

          this.boundingBox.expandByPoint(_box$1.min);
          this.boundingBox.expandByPoint(_box$1.max);
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }

    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeBoundingSphere: function () {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }

    var position = this.attributes.position;
    var morphAttributesPosition = this.morphAttributes.position;

    if (position) {
      // first, find the center of the bounding sphere
      var center = this.boundingSphere.center;

      _box$1.setFromBufferAttribute(position); // process morph attributes if present


      if (morphAttributesPosition) {
        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
          var morphAttribute = morphAttributesPosition[i];

          _boxMorphTargets.setFromBufferAttribute(morphAttribute);

          _box$1.expandByPoint(_boxMorphTargets.min);

          _box$1.expandByPoint(_boxMorphTargets.max);
        }
      }

      _box$1.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case


      var maxRadiusSq = 0;

      for (var i = 0, il = position.count; i < il; i++) {
        _vector$4.fromBufferAttribute(position, i);

        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
      } // process morph attributes if present


      if (morphAttributesPosition) {
        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
          var morphAttribute = morphAttributesPosition[i];

          for (var j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$4.fromBufferAttribute(morphAttribute, j);

            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
          }
        }
      }

      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  },
  computeFaceNormals: function () {// backwards compatibility
  },
  computeVertexNormals: function () {
    var index = this.index;
    var attributes = this.attributes;

    if (attributes.position) {
      var positions = attributes.position.array;

      if (attributes.normal === undefined) {
        this.addAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));
      } else {
        // reset existing normals to zero
        var array = attributes.normal.array;

        for (var i = 0, il = array.length; i < il; i++) {
          array[i] = 0;
        }
      }

      var normals = attributes.normal.array;
      var vA, vB, vC;
      var pA = new Vector3(),
          pB = new Vector3(),
          pC = new Vector3();
      var cb = new Vector3(),
          ab = new Vector3(); // indexed elements

      if (index) {
        var indices = index.array;

        for (var i = 0, il = index.count; i < il; i += 3) {
          vA = indices[i + 0] * 3;
          vB = indices[i + 1] * 3;
          vC = indices[i + 2] * 3;
          pA.fromArray(positions, vA);
          pB.fromArray(positions, vB);
          pC.fromArray(positions, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normals[vA] += cb.x;
          normals[vA + 1] += cb.y;
          normals[vA + 2] += cb.z;
          normals[vB] += cb.x;
          normals[vB + 1] += cb.y;
          normals[vB + 2] += cb.z;
          normals[vC] += cb.x;
          normals[vC + 1] += cb.y;
          normals[vC + 2] += cb.z;
        }
      } else {
        // non-indexed elements (unconnected triangle soup)
        for (var i = 0, il = positions.length; i < il; i += 9) {
          pA.fromArray(positions, i);
          pB.fromArray(positions, i + 3);
          pC.fromArray(positions, i + 6);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normals[i] = cb.x;
          normals[i + 1] = cb.y;
          normals[i + 2] = cb.z;
          normals[i + 3] = cb.x;
          normals[i + 4] = cb.y;
          normals[i + 5] = cb.z;
          normals[i + 6] = cb.x;
          normals[i + 7] = cb.y;
          normals[i + 8] = cb.z;
        }
      }

      this.normalizeNormals();
      attributes.normal.needsUpdate = true;
    }
  },
  merge: function (geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
      return;
    }

    if (offset === undefined) {
      offset = 0;
      console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
    }

    var attributes = this.attributes;

    for (var key in attributes) {
      if (geometry.attributes[key] === undefined) continue;
      var attribute1 = attributes[key];
      var attributeArray1 = attribute1.array;
      var attribute2 = geometry.attributes[key];
      var attributeArray2 = attribute2.array;
      var attributeOffset = attribute2.itemSize * offset;
      var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);

      for (var i = 0, j = attributeOffset; i < length; i++, j++) {
        attributeArray1[j] = attributeArray2[i];
      }
    }

    return this;
  },
  normalizeNormals: function () {
    var normals = this.attributes.normal;

    for (var i = 0, il = normals.count; i < il; i++) {
      _vector$4.x = normals.getX(i);
      _vector$4.y = normals.getY(i);
      _vector$4.z = normals.getZ(i);

      _vector$4.normalize();

      normals.setXYZ(i, _vector$4.x, _vector$4.y, _vector$4.z);
    }
  },
  toNonIndexed: function () {
    function convertBufferAttribute(attribute, indices) {
      var array = attribute.array;
      var itemSize = attribute.itemSize;
      var array2 = new array.constructor(indices.length * itemSize);
      var index = 0,
          index2 = 0;

      for (var i = 0, l = indices.length; i < l; i++) {
        index = indices[i] * itemSize;

        for (var j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }

      return new BufferAttribute(array2, itemSize);
    } //


    if (this.index === null) {
      console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
      return this;
    }

    var geometry2 = new BufferGeometry();
    var indices = this.index.array;
    var attributes = this.attributes; // attributes

    for (var name in attributes) {
      var attribute = attributes[name];
      var newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.addAttribute(name, newAttribute);
    } // morph attributes


    var morphAttributes = this.morphAttributes;

    for (name in morphAttributes) {
      var morphArray = [];
      var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (var i = 0, il = morphAttribute.length; i < il; i++) {
        var attribute = morphAttribute[i];
        var newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }

      geometry2.morphAttributes[name] = morphArray;
    } // groups


    var groups = this.groups;

    for (var i = 0, l = groups.length; i < l; i++) {
      var group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }

    return geometry2;
  },
  toJSON: function () {
    var data = {
      metadata: {
        version: 4.5,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    }; // standard BufferGeometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;

    if (this.parameters !== undefined) {
      var parameters = this.parameters;

      for (var key in parameters) {
        if (parameters[key] !== undefined) data[key] = parameters[key];
      }

      return data;
    }

    data.data = {
      attributes: {}
    };
    var index = this.index;

    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }

    var attributes = this.attributes;

    for (var key in attributes) {
      var attribute = attributes[key];
      var attributeData = attribute.toJSON();
      if (attribute.name !== '') attributeData.name = attribute.name;
      data.data.attributes[key] = attributeData;
    }

    var morphAttributes = {};
    var hasMorphAttributes = false;

    for (var key in this.morphAttributes) {
      var attributeArray = this.morphAttributes[key];
      var array = [];

      for (var i = 0, il = attributeArray.length; i < il; i++) {
        var attribute = attributeArray[i];
        var attributeData = attribute.toJSON();
        if (attribute.name !== '') attributeData.name = attribute.name;
        array.push(attributeData);
      }

      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }

    if (hasMorphAttributes) data.data.morphAttributes = morphAttributes;
    var groups = this.groups;

    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }

    var boundingSphere = this.boundingSphere;

    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }

    return data;
  },
  clone: function () {
    /*
     // Handle primitives
    	 var parameters = this.parameters;
    	 if ( parameters !== undefined ) {
    	 var values = [];
    	 for ( var key in parameters ) {
    	 values.push( parameters[ key ] );
    	 }
    	 var geometry = Object.create( this.constructor.prototype );
     this.constructor.apply( geometry, values );
     return geometry;
    	 }
    	 return new this.constructor().copy( this );
     */
    return new BufferGeometry().copy(this);
  },
  copy: function (source) {
    var name, i, l; // reset

    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null; // name

    this.name = source.name; // index

    var index = source.index;

    if (index !== null) {
      this.setIndex(index.clone());
    } // attributes


    var attributes = source.attributes;

    for (name in attributes) {
      var attribute = attributes[name];
      this.addAttribute(name, attribute.clone());
    } // morph attributes


    var morphAttributes = source.morphAttributes;

    for (name in morphAttributes) {
      var array = [];
      var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone());
      }

      this.morphAttributes[name] = array;
    } // groups


    var groups = source.groups;

    for (i = 0, l = groups.length; i < l; i++) {
      var group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    } // bounding box


    var boundingBox = source.boundingBox;

    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    } // bounding sphere


    var boundingSphere = source.boundingSphere;

    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    } // draw range


    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count; // user data

    this.userData = source.userData;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

var _inverseMatrix = new Matrix4();

var _ray = new Ray();

var _sphere = new Sphere();

var _vA = new Vector3();

var _vB = new Vector3();

var _vC = new Vector3();

var _tempA = new Vector3();

var _tempB = new Vector3();

var _tempC = new Vector3();

var _morphA = new Vector3();

var _morphB = new Vector3();

var _morphC = new Vector3();

var _uvA = new Vector2();

var _uvB = new Vector2();

var _uvC = new Vector2();

var _intersectionPoint = new Vector3();

var _intersectionPointWorld = new Vector3();

function Mesh(geometry, material) {
  Object3D.call(this);
  this.type = 'Mesh';
  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  this.material = material !== undefined ? material : new MeshBasicMaterial({
    color: Math.random() * 0xffffff
  });
  this.drawMode = TrianglesDrawMode;
  this.updateMorphTargets();
}

Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Mesh,
  isMesh: true,
  setDrawMode: function (value) {
    this.drawMode = value;
  },
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    this.drawMode = source.drawMode;

    if (source.morphTargetInfluences !== undefined) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }

    if (source.morphTargetDictionary !== undefined) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }

    return this;
  },
  updateMorphTargets: function () {
    var geometry = this.geometry;
    var m, ml, name;

    if (geometry.isBufferGeometry) {
      var morphAttributes = geometry.morphAttributes;
      var keys = Object.keys(morphAttributes);

      if (keys.length > 0) {
        var morphAttribute = morphAttributes[keys[0]];

        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};

          for (m = 0, ml = morphAttribute.length; m < ml; m++) {
            name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      var morphTargets = geometry.morphTargets;

      if (morphTargets !== undefined && morphTargets.length > 0) {
        console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  },
  raycast: function (raycaster, intersects) {
    var geometry = this.geometry;
    var material = this.material;
    var matrixWorld = this.matrixWorld;
    if (material === undefined) return; // Checking boundingSphere distance to ray

    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

    _sphere.copy(geometry.boundingSphere);

    _sphere.applyMatrix4(matrixWorld);

    if (raycaster.ray.intersectsSphere(_sphere) === false) return; //

    _inverseMatrix.getInverse(matrixWorld);

    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing


    if (geometry.boundingBox !== null) {
      if (_ray.intersectsBox(geometry.boundingBox) === false) return;
    }

    var intersection;

    if (geometry.isBufferGeometry) {
      var a, b, c;
      var index = geometry.index;
      var position = geometry.attributes.position;
      var morphPosition = geometry.morphAttributes.position;
      var uv = geometry.attributes.uv;
      var uv2 = geometry.attributes.uv2;
      var groups = geometry.groups;
      var drawRange = geometry.drawRange;
      var i, j, il, jl;
      var group, groupMaterial;
      var start, end;

      if (index !== null) {
        // indexed buffer geometry
        if (Array.isArray(material)) {
          for (i = 0, il = groups.length; i < il; i++) {
            group = groups[i];
            groupMaterial = material[group.materialIndex];
            start = Math.max(group.start, drawRange.start);
            end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

            for (j = start, jl = end; j < jl; j += 3) {
              a = index.getX(j);
              b = index.getX(j + 1);
              c = index.getX(j + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, uv, uv2, a, b, c);

              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics

                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          start = Math.max(0, drawRange.start);
          end = Math.min(index.count, drawRange.start + drawRange.count);

          for (i = start, il = end; i < il; i += 3) {
            a = index.getX(i);
            b = index.getX(i + 1);
            c = index.getX(i + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, uv, uv2, a, b, c);

            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics

              intersects.push(intersection);
            }
          }
        }
      } else if (position !== undefined) {
        // non-indexed buffer geometry
        if (Array.isArray(material)) {
          for (i = 0, il = groups.length; i < il; i++) {
            group = groups[i];
            groupMaterial = material[group.materialIndex];
            start = Math.max(group.start, drawRange.start);
            end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

            for (j = start, jl = end; j < jl; j += 3) {
              a = j;
              b = j + 1;
              c = j + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, uv, uv2, a, b, c);

              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics

                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          start = Math.max(0, drawRange.start);
          end = Math.min(position.count, drawRange.start + drawRange.count);

          for (i = start, il = end; i < il; i += 3) {
            a = i;
            b = i + 1;
            c = i + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, uv, uv2, a, b, c);

            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics

              intersects.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      var fvA, fvB, fvC;
      var isMultiMaterial = Array.isArray(material);
      var vertices = geometry.vertices;
      var faces = geometry.faces;
      var uvs;
      var faceVertexUvs = geometry.faceVertexUvs[0];
      if (faceVertexUvs.length > 0) uvs = faceVertexUvs;

      for (var f = 0, fl = faces.length; f < fl; f++) {
        var face = faces[f];
        var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
        if (faceMaterial === undefined) continue;
        fvA = vertices[face.a];
        fvB = vertices[face.b];
        fvC = vertices[face.c];
        intersection = checkIntersection(this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint);

        if (intersection) {
          if (uvs && uvs[f]) {
            var uvs_f = uvs[f];

            _uvA.copy(uvs_f[0]);

            _uvB.copy(uvs_f[1]);

            _uvC.copy(uvs_f[2]);

            intersection.uv = Triangle.getUV(_intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2());
          }

          intersection.face = face;
          intersection.faceIndex = f;
          intersects.push(intersection);
        }
      }
    }
  },
  clone: function () {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});

function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  var intersect;

  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
  }

  if (intersect === null) return null;

  _intersectionPointWorld.copy(point);

  _intersectionPointWorld.applyMatrix4(object.matrixWorld);

  var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far) return null;
  return {
    distance: distance,
    point: _intersectionPointWorld.clone(),
    object: object
  };
}

function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, uv, uv2, a, b, c) {
  _vA.fromBufferAttribute(position, a);

  _vB.fromBufferAttribute(position, b);

  _vC.fromBufferAttribute(position, c);

  var morphInfluences = object.morphTargetInfluences;

  if (material.morphTargets && morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);

    _morphB.set(0, 0, 0);

    _morphC.set(0, 0, 0);

    for (var i = 0, il = morphPosition.length; i < il; i++) {
      var influence = morphInfluences[i];
      var morphAttribute = morphPosition[i];
      if (influence === 0) continue;

      _tempA.fromBufferAttribute(morphAttribute, a);

      _tempB.fromBufferAttribute(morphAttribute, b);

      _tempC.fromBufferAttribute(morphAttribute, c);

      _morphA.addScaledVector(_tempA.sub(_vA), influence);

      _morphB.addScaledVector(_tempB.sub(_vB), influence);

      _morphC.addScaledVector(_tempC.sub(_vC), influence);
    }

    _vA.add(_morphA);

    _vB.add(_morphB);

    _vC.add(_morphC);
  }

  var intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);

  if (intersection) {
    if (uv) {
      _uvA.fromBufferAttribute(uv, a);

      _uvB.fromBufferAttribute(uv, b);

      _uvC.fromBufferAttribute(uv, c);

      intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }

    if (uv2) {
      _uvA.fromBufferAttribute(uv2, a);

      _uvB.fromBufferAttribute(uv2, b);

      _uvC.fromBufferAttribute(uv2, c);

      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }

    var face = new Face3(a, b, c);
    Triangle.getNormal(_vA, _vB, _vC, face.normal);
    intersection.face = face;
  }

  return intersection;
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */


var _geometryId = 0; // Geometry uses even numbers as Id

var _m1$3 = new Matrix4();

var _obj$1 = new Object3D();

var _offset$1 = new Vector3();

function Geometry() {
  Object.defineProperty(this, 'id', {
    value: _geometryId += 2
  });
  this.uuid = _Math.generateUUID();
  this.name = '';
  this.type = 'Geometry';
  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [[]];
  this.morphTargets = [];
  this.morphNormals = [];
  this.skinWeights = [];
  this.skinIndices = [];
  this.lineDistances = [];
  this.boundingBox = null;
  this.boundingSphere = null; // update flags

  this.elementsNeedUpdate = false;
  this.verticesNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.lineDistancesNeedUpdate = false;
  this.groupsNeedUpdate = false;
}

Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Geometry,
  isGeometry: true,
  applyMatrix: function (matrix) {
    var normalMatrix = new Matrix3().getNormalMatrix(matrix);

    for (var i = 0, il = this.vertices.length; i < il; i++) {
      var vertex = this.vertices[i];
      vertex.applyMatrix4(matrix);
    }

    for (var i = 0, il = this.faces.length; i < il; i++) {
      var face = this.faces[i];
      face.normal.applyMatrix3(normalMatrix).normalize();

      for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
      }
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    this.verticesNeedUpdate = true;
    this.normalsNeedUpdate = true;
    return this;
  },
  rotateX: function (angle) {
    // rotate geometry around world x-axis
    _m1$3.makeRotationX(angle);

    this.applyMatrix(_m1$3);
    return this;
  },
  rotateY: function (angle) {
    // rotate geometry around world y-axis
    _m1$3.makeRotationY(angle);

    this.applyMatrix(_m1$3);
    return this;
  },
  rotateZ: function (angle) {
    // rotate geometry around world z-axis
    _m1$3.makeRotationZ(angle);

    this.applyMatrix(_m1$3);
    return this;
  },
  translate: function (x, y, z) {
    // translate geometry
    _m1$3.makeTranslation(x, y, z);

    this.applyMatrix(_m1$3);
    return this;
  },
  scale: function (x, y, z) {
    // scale geometry
    _m1$3.makeScale(x, y, z);

    this.applyMatrix(_m1$3);
    return this;
  },
  lookAt: function (vector) {
    _obj$1.lookAt(vector);

    _obj$1.updateMatrix();

    this.applyMatrix(_obj$1.matrix);
    return this;
  },
  fromBufferGeometry: function (geometry) {
    var scope = this;
    var indices = geometry.index !== null ? geometry.index.array : undefined;
    var attributes = geometry.attributes;
    var positions = attributes.position.array;
    var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
    var colors = attributes.color !== undefined ? attributes.color.array : undefined;
    var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
    var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
    if (uvs2 !== undefined) this.faceVertexUvs[1] = [];

    for (var i = 0; i < positions.length; i += 3) {
      scope.vertices.push(new Vector3().fromArray(positions, i));

      if (colors !== undefined) {
        scope.colors.push(new Color().fromArray(colors, i));
      }
    }

    function addFace(a, b, c, materialIndex) {
      var vertexColors = colors === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];
      var vertexNormals = normals === undefined ? [] : [new Vector3().fromArray(normals, a * 3), new Vector3().fromArray(normals, b * 3), new Vector3().fromArray(normals, c * 3)];
      var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
      scope.faces.push(face);

      if (uvs !== undefined) {
        scope.faceVertexUvs[0].push([new Vector2().fromArray(uvs, a * 2), new Vector2().fromArray(uvs, b * 2), new Vector2().fromArray(uvs, c * 2)]);
      }

      if (uvs2 !== undefined) {
        scope.faceVertexUvs[1].push([new Vector2().fromArray(uvs2, a * 2), new Vector2().fromArray(uvs2, b * 2), new Vector2().fromArray(uvs2, c * 2)]);
      }
    }

    var groups = geometry.groups;

    if (groups.length > 0) {
      for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        var start = group.start;
        var count = group.count;

        for (var j = start, jl = start + count; j < jl; j += 3) {
          if (indices !== undefined) {
            addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
          } else {
            addFace(j, j + 1, j + 2, group.materialIndex);
          }
        }
      }
    } else {
      if (indices !== undefined) {
        for (var i = 0; i < indices.length; i += 3) {
          addFace(indices[i], indices[i + 1], indices[i + 2]);
        }
      } else {
        for (var i = 0; i < positions.length / 3; i += 3) {
          addFace(i, i + 1, i + 2);
        }
      }
    }

    this.computeFaceNormals();

    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }

    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }

    return this;
  },
  center: function () {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset$1).negate();
    this.translate(_offset$1.x, _offset$1.y, _offset$1.z);
    return this;
  },
  normalize: function () {
    this.computeBoundingSphere();
    var center = this.boundingSphere.center;
    var radius = this.boundingSphere.radius;
    var s = radius === 0 ? 1 : 1.0 / radius;
    var matrix = new Matrix4();
    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
    this.applyMatrix(matrix);
    return this;
  },
  computeFaceNormals: function () {
    var cb = new Vector3(),
        ab = new Vector3();

    for (var f = 0, fl = this.faces.length; f < fl; f++) {
      var face = this.faces[f];
      var vA = this.vertices[face.a];
      var vB = this.vertices[face.b];
      var vC = this.vertices[face.c];
      cb.subVectors(vC, vB);
      ab.subVectors(vA, vB);
      cb.cross(ab);
      cb.normalize();
      face.normal.copy(cb);
    }
  },
  computeVertexNormals: function (areaWeighted) {
    if (areaWeighted === undefined) areaWeighted = true;
    var v, vl, f, fl, face, vertices;
    vertices = new Array(this.vertices.length);

    for (v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v] = new Vector3();
    }

    if (areaWeighted) {
      // vertex normals weighted by triangle areas
      // http://www.iquilezles.org/www/articles/normals/normals.htm
      var vA, vB, vC;
      var cb = new Vector3(),
          ab = new Vector3();

      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        vA = this.vertices[face.a];
        vB = this.vertices[face.b];
        vC = this.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        vertices[face.a].add(cb);
        vertices[face.b].add(cb);
        vertices[face.c].add(cb);
      }
    } else {
      this.computeFaceNormals();

      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        vertices[face.a].add(face.normal);
        vertices[face.b].add(face.normal);
        vertices[face.c].add(face.normal);
      }
    }

    for (v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v].normalize();
    }

    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      var vertexNormals = face.vertexNormals;

      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(vertices[face.a]);
        vertexNormals[1].copy(vertices[face.b]);
        vertexNormals[2].copy(vertices[face.c]);
      } else {
        vertexNormals[0] = vertices[face.a].clone();
        vertexNormals[1] = vertices[face.b].clone();
        vertexNormals[2] = vertices[face.c].clone();
      }
    }

    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  },
  computeFlatVertexNormals: function () {
    var f, fl, face;
    this.computeFaceNormals();

    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      var vertexNormals = face.vertexNormals;

      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(face.normal);
        vertexNormals[1].copy(face.normal);
        vertexNormals[2].copy(face.normal);
      } else {
        vertexNormals[0] = face.normal.clone();
        vertexNormals[1] = face.normal.clone();
        vertexNormals[2] = face.normal.clone();
      }
    }

    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  },
  computeMorphNormals: function () {
    var i, il, f, fl, face; // save original normals
    // - create temp variables on first access
    //   otherwise just copy (for faster repeated calls)

    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];

      if (!face.__originalFaceNormal) {
        face.__originalFaceNormal = face.normal.clone();
      } else {
        face.__originalFaceNormal.copy(face.normal);
      }

      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];

      for (i = 0, il = face.vertexNormals.length; i < il; i++) {
        if (!face.__originalVertexNormals[i]) {
          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
        } else {
          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
        }
      }
    } // use temp geometry to compute face and vertex normals for each morph


    var tmpGeo = new Geometry();
    tmpGeo.faces = this.faces;

    for (i = 0, il = this.morphTargets.length; i < il; i++) {
      // create on first access
      if (!this.morphNormals[i]) {
        this.morphNormals[i] = {};
        this.morphNormals[i].faceNormals = [];
        this.morphNormals[i].vertexNormals = [];
        var dstNormalsFace = this.morphNormals[i].faceNormals;
        var dstNormalsVertex = this.morphNormals[i].vertexNormals;
        var faceNormal, vertexNormals;

        for (f = 0, fl = this.faces.length; f < fl; f++) {
          faceNormal = new Vector3();
          vertexNormals = {
            a: new Vector3(),
            b: new Vector3(),
            c: new Vector3()
          };
          dstNormalsFace.push(faceNormal);
          dstNormalsVertex.push(vertexNormals);
        }
      }

      var morphNormals = this.morphNormals[i]; // set vertices to morph target

      tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals

      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals(); // store morph normals

      var faceNormal, vertexNormals;

      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        faceNormal = morphNormals.faceNormals[f];
        vertexNormals = morphNormals.vertexNormals[f];
        faceNormal.copy(face.normal);
        vertexNormals.a.copy(face.vertexNormals[0]);
        vertexNormals.b.copy(face.vertexNormals[1]);
        vertexNormals.c.copy(face.vertexNormals[2]);
      }
    } // restore original normals


    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;
    }
  },
  computeBoundingBox: function () {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }

    this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function () {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }

    this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function (geometry, matrix, materialIndexOffset) {
    if (!(geometry && geometry.isGeometry)) {
      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
      return;
    }

    var normalMatrix,
        vertexOffset = this.vertices.length,
        vertices1 = this.vertices,
        vertices2 = geometry.vertices,
        faces1 = this.faces,
        faces2 = geometry.faces,
        colors1 = this.colors,
        colors2 = geometry.colors;
    if (materialIndexOffset === undefined) materialIndexOffset = 0;

    if (matrix !== undefined) {
      normalMatrix = new Matrix3().getNormalMatrix(matrix);
    } // vertices


    for (var i = 0, il = vertices2.length; i < il; i++) {
      var vertex = vertices2[i];
      var vertexCopy = vertex.clone();
      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);
      vertices1.push(vertexCopy);
    } // colors


    for (var i = 0, il = colors2.length; i < il; i++) {
      colors1.push(colors2[i].clone());
    } // faces


    for (i = 0, il = faces2.length; i < il; i++) {
      var face = faces2[i],
          faceCopy,
          normal,
          color,
          faceVertexNormals = face.vertexNormals,
          faceVertexColors = face.vertexColors;
      faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
      faceCopy.normal.copy(face.normal);

      if (normalMatrix !== undefined) {
        faceCopy.normal.applyMatrix3(normalMatrix).normalize();
      }

      for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
        normal = faceVertexNormals[j].clone();

        if (normalMatrix !== undefined) {
          normal.applyMatrix3(normalMatrix).normalize();
        }

        faceCopy.vertexNormals.push(normal);
      }

      faceCopy.color.copy(face.color);

      for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
        color = faceVertexColors[j];
        faceCopy.vertexColors.push(color.clone());
      }

      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
      faces1.push(faceCopy);
    } // uvs


    for (var i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {
      var faceVertexUvs2 = geometry.faceVertexUvs[i];
      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];

      for (var j = 0, jl = faceVertexUvs2.length; j < jl; j++) {
        var uvs2 = faceVertexUvs2[j],
            uvsCopy = [];

        for (var k = 0, kl = uvs2.length; k < kl; k++) {
          uvsCopy.push(uvs2[k].clone());
        }

        this.faceVertexUvs[i].push(uvsCopy);
      }
    }
  },
  mergeMesh: function (mesh) {
    if (!(mesh && mesh.isMesh)) {
      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
      return;
    }

    if (mesh.matrixAutoUpdate) mesh.updateMatrix();
    this.merge(mesh.geometry, mesh.matrix);
  },

  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */
  mergeVertices: function () {
    var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)

    var unique = [],
        changes = [];
    var v, key;
    var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001

    var precision = Math.pow(10, precisionPoints);
    var i, il, face;
    var indices, j, jl;

    for (i = 0, il = this.vertices.length; i < il; i++) {
      v = this.vertices[i];
      key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);

      if (verticesMap[key] === undefined) {
        verticesMap[key] = i;
        unique.push(this.vertices[i]);
        changes[i] = unique.length - 1;
      } else {
        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
        changes[i] = changes[verticesMap[key]];
      }
    } // if faces are completely degenerate after merging vertices, we
    // have to remove them from the geometry.


    var faceIndicesToRemove = [];

    for (i = 0, il = this.faces.length; i < il; i++) {
      face = this.faces[i];
      face.a = changes[face.a];
      face.b = changes[face.b];
      face.c = changes[face.c];
      indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3
      // we have to remove the face as nothing can be saved

      for (var n = 0; n < 3; n++) {
        if (indices[n] === indices[(n + 1) % 3]) {
          faceIndicesToRemove.push(i);
          break;
        }
      }
    }

    for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
      var idx = faceIndicesToRemove[i];
      this.faces.splice(idx, 1);

      for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
        this.faceVertexUvs[j].splice(idx, 1);
      }
    } // Use unique set of vertices


    var diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;
  },
  setFromPoints: function (points) {
    this.vertices = [];

    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
    }

    return this;
  },
  sortFacesByMaterialIndex: function () {
    var faces = this.faces;
    var length = faces.length; // tag faces

    for (var i = 0; i < length; i++) {
      faces[i]._id = i;
    } // sort faces


    function materialIndexSort(a, b) {
      return a.materialIndex - b.materialIndex;
    }

    faces.sort(materialIndexSort); // sort uvs

    var uvs1 = this.faceVertexUvs[0];
    var uvs2 = this.faceVertexUvs[1];
    var newUvs1, newUvs2;
    if (uvs1 && uvs1.length === length) newUvs1 = [];
    if (uvs2 && uvs2.length === length) newUvs2 = [];

    for (var i = 0; i < length; i++) {
      var id = faces[i]._id;
      if (newUvs1) newUvs1.push(uvs1[id]);
      if (newUvs2) newUvs2.push(uvs2[id]);
    }

    if (newUvs1) this.faceVertexUvs[0] = newUvs1;
    if (newUvs2) this.faceVertexUvs[1] = newUvs2;
  },
  toJSON: function () {
    var data = {
      metadata: {
        version: 4.5,
        type: 'Geometry',
        generator: 'Geometry.toJSON'
      }
    }; // standard Geometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;

    if (this.parameters !== undefined) {
      var parameters = this.parameters;

      for (var key in parameters) {
        if (parameters[key] !== undefined) data[key] = parameters[key];
      }

      return data;
    }

    var vertices = [];

    for (var i = 0; i < this.vertices.length; i++) {
      var vertex = this.vertices[i];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }

    var faces = [];
    var normals = [];
    var normalsHash = {};
    var colors = [];
    var colorsHash = {};
    var uvs = [];
    var uvsHash = {};

    for (var i = 0; i < this.faces.length; i++) {
      var face = this.faces[i];
      var hasMaterial = true;
      var hasFaceUv = false; // deprecated

      var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
      var hasFaceNormal = face.normal.length() > 0;
      var hasFaceVertexNormal = face.vertexNormals.length > 0;
      var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
      var hasFaceVertexColor = face.vertexColors.length > 0;
      var faceType = 0;
      faceType = setBit(faceType, 0, 0); // isQuad

      faceType = setBit(faceType, 1, hasMaterial);
      faceType = setBit(faceType, 2, hasFaceUv);
      faceType = setBit(faceType, 3, hasFaceVertexUv);
      faceType = setBit(faceType, 4, hasFaceNormal);
      faceType = setBit(faceType, 5, hasFaceVertexNormal);
      faceType = setBit(faceType, 6, hasFaceColor);
      faceType = setBit(faceType, 7, hasFaceVertexColor);
      faces.push(faceType);
      faces.push(face.a, face.b, face.c);
      faces.push(face.materialIndex);

      if (hasFaceVertexUv) {
        var faceVertexUvs = this.faceVertexUvs[0][i];
        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
      }

      if (hasFaceNormal) {
        faces.push(getNormalIndex(face.normal));
      }

      if (hasFaceVertexNormal) {
        var vertexNormals = face.vertexNormals;
        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
      }

      if (hasFaceColor) {
        faces.push(getColorIndex(face.color));
      }

      if (hasFaceVertexColor) {
        var vertexColors = face.vertexColors;
        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
      }
    }

    function setBit(value, position, enabled) {
      return enabled ? value | 1 << position : value & ~(1 << position);
    }

    function getNormalIndex(normal) {
      var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

      if (normalsHash[hash] !== undefined) {
        return normalsHash[hash];
      }

      normalsHash[hash] = normals.length / 3;
      normals.push(normal.x, normal.y, normal.z);
      return normalsHash[hash];
    }

    function getColorIndex(color) {
      var hash = color.r.toString() + color.g.toString() + color.b.toString();

      if (colorsHash[hash] !== undefined) {
        return colorsHash[hash];
      }

      colorsHash[hash] = colors.length;
      colors.push(color.getHex());
      return colorsHash[hash];
    }

    function getUvIndex(uv) {
      var hash = uv.x.toString() + uv.y.toString();

      if (uvsHash[hash] !== undefined) {
        return uvsHash[hash];
      }

      uvsHash[hash] = uvs.length / 2;
      uvs.push(uv.x, uv.y);
      return uvsHash[hash];
    }

    data.data = {};
    data.data.vertices = vertices;
    data.data.normals = normals;
    if (colors.length > 0) data.data.colors = colors;
    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility

    data.data.faces = faces;
    return data;
  },
  clone: function () {
    /*
     // Handle primitives
    	 var parameters = this.parameters;
    	 if ( parameters !== undefined ) {
    	 var values = [];
    	 for ( var key in parameters ) {
    	 values.push( parameters[ key ] );
    	 }
    	 var geometry = Object.create( this.constructor.prototype );
     this.constructor.apply( geometry, values );
     return geometry;
    	 }
    	 return new this.constructor().copy( this );
     */
    return new Geometry().copy(this);
  },
  copy: function (source) {
    var i, il, j, jl, k, kl; // reset

    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null; // name

    this.name = source.name; // vertices

    var vertices = source.vertices;

    for (i = 0, il = vertices.length; i < il; i++) {
      this.vertices.push(vertices[i].clone());
    } // colors


    var colors = source.colors;

    for (i = 0, il = colors.length; i < il; i++) {
      this.colors.push(colors[i].clone());
    } // faces


    var faces = source.faces;

    for (i = 0, il = faces.length; i < il; i++) {
      this.faces.push(faces[i].clone());
    } // face vertex uvs


    for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {
      var faceVertexUvs = source.faceVertexUvs[i];

      if (this.faceVertexUvs[i] === undefined) {
        this.faceVertexUvs[i] = [];
      }

      for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {
        var uvs = faceVertexUvs[j],
            uvsCopy = [];

        for (k = 0, kl = uvs.length; k < kl; k++) {
          var uv = uvs[k];
          uvsCopy.push(uv.clone());
        }

        this.faceVertexUvs[i].push(uvsCopy);
      }
    } // morph targets


    var morphTargets = source.morphTargets;

    for (i = 0, il = morphTargets.length; i < il; i++) {
      var morphTarget = {};
      morphTarget.name = morphTargets[i].name; // vertices

      if (morphTargets[i].vertices !== undefined) {
        morphTarget.vertices = [];

        for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
        }
      } // normals


      if (morphTargets[i].normals !== undefined) {
        morphTarget.normals = [];

        for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
          morphTarget.normals.push(morphTargets[i].normals[j].clone());
        }
      }

      this.morphTargets.push(morphTarget);
    } // morph normals


    var morphNormals = source.morphNormals;

    for (i = 0, il = morphNormals.length; i < il; i++) {
      var morphNormal = {}; // vertex normals

      if (morphNormals[i].vertexNormals !== undefined) {
        morphNormal.vertexNormals = [];

        for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
          var srcVertexNormal = morphNormals[i].vertexNormals[j];
          var destVertexNormal = {};
          destVertexNormal.a = srcVertexNormal.a.clone();
          destVertexNormal.b = srcVertexNormal.b.clone();
          destVertexNormal.c = srcVertexNormal.c.clone();
          morphNormal.vertexNormals.push(destVertexNormal);
        }
      } // face normals


      if (morphNormals[i].faceNormals !== undefined) {
        morphNormal.faceNormals = [];

        for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
        }
      }

      this.morphNormals.push(morphNormal);
    } // skin weights


    var skinWeights = source.skinWeights;

    for (i = 0, il = skinWeights.length; i < il; i++) {
      this.skinWeights.push(skinWeights[i].clone());
    } // skin indices


    var skinIndices = source.skinIndices;

    for (i = 0, il = skinIndices.length; i < il; i++) {
      this.skinIndices.push(skinIndices[i].clone());
    } // line distances


    var lineDistances = source.lineDistances;

    for (i = 0, il = lineDistances.length; i < il; i++) {
      this.lineDistances.push(lineDistances[i]);
    } // bounding box


    var boundingBox = source.boundingBox;

    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    } // bounding sphere


    var boundingSphere = source.boundingSphere;

    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    } // update flags


    this.elementsNeedUpdate = source.elementsNeedUpdate;
    this.verticesNeedUpdate = source.verticesNeedUpdate;
    this.uvsNeedUpdate = source.uvsNeedUpdate;
    this.normalsNeedUpdate = source.normalsNeedUpdate;
    this.colorsNeedUpdate = source.colorsNeedUpdate;
    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
    this.groupsNeedUpdate = source.groupsNeedUpdate;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */
// BoxGeometry

function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
  Geometry.call(this);
  this.type = 'BoxGeometry';
  this.parameters = {
    width: width,
    height: height,
    depth: depth,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    depthSegments: depthSegments
  };
  this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
  this.mergeVertices();
}

BoxGeometry.prototype = Object.create(Geometry.prototype);
BoxGeometry.prototype.constructor = BoxGeometry; // BoxBufferGeometry

function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
  BufferGeometry.call(this);
  this.type = 'BoxBufferGeometry';
  this.parameters = {
    width: width,
    height: height,
    depth: depth,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    depthSegments: depthSegments
  };
  var scope = this;
  width = width || 1;
  height = height || 1;
  depth = depth || 1; // segments

  widthSegments = Math.floor(widthSegments) || 1;
  heightSegments = Math.floor(heightSegments) || 1;
  depthSegments = Math.floor(depthSegments) || 1; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // helper variables

  var numberOfVertices = 0;
  var groupStart = 0; // build each side of the box geometry

  buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px

  buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx

  buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py

  buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny

  buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz

  buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
  // build geometry

  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

  function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
    var segmentWidth = width / gridX;
    var segmentHeight = height / gridY;
    var widthHalf = width / 2;
    var heightHalf = height / 2;
    var depthHalf = depth / 2;
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var vertexCounter = 0;
    var groupCount = 0;
    var ix, iy;
    var vector = new Vector3(); // generate vertices, normals and uvs

    for (iy = 0; iy < gridY1; iy++) {
      var y = iy * segmentHeight - heightHalf;

      for (ix = 0; ix < gridX1; ix++) {
        var x = ix * segmentWidth - widthHalf; // set values to correct vector component

        vector[u] = x * udir;
        vector[v] = y * vdir;
        vector[w] = depthHalf; // now apply vector to vertex buffer

        vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component

        vector[u] = 0;
        vector[v] = 0;
        vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer

        normals.push(vector.x, vector.y, vector.z); // uvs

        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY); // counters

        vertexCounter += 1;
      }
    } // indices
    // 1. you need three indices to draw a single face
    // 2. a single segment consists of two faces
    // 3. so we need to generate six (2*3) indices per segment


    for (iy = 0; iy < gridY; iy++) {
      for (ix = 0; ix < gridX; ix++) {
        var a = numberOfVertices + ix + gridX1 * iy;
        var b = numberOfVertices + ix + gridX1 * (iy + 1);
        var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
        var d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces

        indices.push(a, b, d);
        indices.push(b, c, d); // increase counter

        groupCount += 6;
      }
    } // add a group to the geometry. this will ensure multi material support


    scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups

    groupStart += groupCount; // update total number of vertices

    numberOfVertices += vertexCounter;
  }
}

BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
/**
 * Uniform Utilities
 */

function cloneUniforms(src) {
  var dst = {};

  for (var u in src) {
    dst[u] = {};

    for (var p in src[u]) {
      var property = src[u][p];

      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) {
        dst[u][p] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }

  return dst;
}

function mergeUniforms(uniforms) {
  var merged = {};

  for (var u = 0; u < uniforms.length; u++) {
    var tmp = cloneUniforms(uniforms[u]);

    for (var p in tmp) {
      merged[p] = tmp[p];
    }
  }

  return merged;
} // Legacy


var UniformsUtils = {
  clone: cloneUniforms,
  merge: mergeUniforms
};
exports.UniformsUtils = UniformsUtils;
var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function ShaderMaterial(parameters) {
  Material.call(this);
  this.type = 'ShaderMaterial';
  this.defines = {};
  this.uniforms = {};
  this.vertexShader = default_vertex;
  this.fragmentShader = default_fragment;
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false; // set to use scene fog

  this.lights = false; // set to use scene lights

  this.clipping = false; // set to use user-defined clipping planes

  this.skinning = false; // set to use skinning attribute streams

  this.morphTargets = false; // set to use morph targets

  this.morphNormals = false; // set to use morph normals

  this.extensions = {
    derivatives: false,
    // set to use derivatives
    fragDepth: false,
    // set to use fragment depth values
    drawBuffers: false,
    // set to use draw buffers
    shaderTextureLOD: false // set to use shader texture LOD

  }; // When rendered geometry doesn't include these attributes but the material does,
  // use these default values in WebGL. This avoids errors when buffer data is missing.

  this.defaultAttributeValues = {
    'color': [1, 1, 1],
    'uv': [0, 0],
    'uv2': [0, 0]
  };
  this.index0AttributeName = undefined;
  this.uniformsNeedUpdate = false;

  if (parameters !== undefined) {
    if (parameters.attributes !== undefined) {
      console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
    }

    this.setValues(parameters);
  }
}

ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;

ShaderMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;
  this.uniforms = cloneUniforms(source.uniforms);
  this.defines = Object.assign({}, source.defines);
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.lights = source.lights;
  this.clipping = source.clipping;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.extensions = source.extensions;
  return this;
};

ShaderMaterial.prototype.toJSON = function (meta) {
  var data = Material.prototype.toJSON.call(this, meta);
  data.uniforms = {};

  for (var name in this.uniforms) {
    var uniform = this.uniforms[name];
    var value = uniform.value;

    if (value && value.isTexture) {
      data.uniforms[name] = {
        type: 't',
        value: value.toJSON(meta).uuid
      };
    } else if (value && value.isColor) {
      data.uniforms[name] = {
        type: 'c',
        value: value.getHex()
      };
    } else if (value && value.isVector2) {
      data.uniforms[name] = {
        type: 'v2',
        value: value.toArray()
      };
    } else if (value && value.isVector3) {
      data.uniforms[name] = {
        type: 'v3',
        value: value.toArray()
      };
    } else if (value && value.isVector4) {
      data.uniforms[name] = {
        type: 'v4',
        value: value.toArray()
      };
    } else if (value && value.isMatrix3) {
      data.uniforms[name] = {
        type: 'm3',
        value: value.toArray()
      };
    } else if (value && value.isMatrix4) {
      data.uniforms[name] = {
        type: 'm4',
        value: value.toArray()
      };
    } else {
      data.uniforms[name] = {
        value: value
      }; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
    }
  }

  if (Object.keys(this.defines).length > 0) data.defines = this.defines;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;
  var extensions = {};

  for (var key in this.extensions) {
    if (this.extensions[key] === true) extensions[key] = true;
  }

  if (Object.keys(extensions).length > 0) data.extensions = extensions;
  return data;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/


function Camera() {
  Object3D.call(this);
  this.type = 'Camera';
  this.matrixWorldInverse = new Matrix4();
  this.projectionMatrix = new Matrix4();
  this.projectionMatrixInverse = new Matrix4();
}

Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Camera,
  isCamera: true,
  copy: function (source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  },
  getWorldDirection: function (target) {
    if (target === undefined) {
      console.warn('THREE.Camera: .getWorldDirection() target is now required');
      target = new Vector3();
    }

    this.updateMatrixWorld(true);
    var e = this.matrixWorld.elements;
    return target.set(-e[8], -e[9], -e[10]).normalize();
  },
  updateMatrixWorld: function (force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  clone: function () {
    return new this.constructor().copy(this);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */

function PerspectiveCamera(fov, aspect, near, far) {
  Camera.call(this);
  this.type = 'PerspectiveCamera';
  this.fov = fov !== undefined ? fov : 50;
  this.zoom = 1;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;
  this.focus = 10;
  this.aspect = aspect !== undefined ? aspect : 1;
  this.view = null;
  this.filmGauge = 35; // width of the film (default in millimeters)

  this.filmOffset = 0; // horizontal film offset (same unit as gauge)

  this.updateProjectionMatrix();
}

PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: PerspectiveCamera,
  isPerspectiveCamera: true,
  copy: function (source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  },

  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength: function (focalLength) {
    // see http://www.bobatkins.com/photography/technical/field_of_view.html
    var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  },

  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength: function () {
    var vExtentSlope = Math.tan(_Math.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  },
  getEffectiveFOV: function () {
    return _Math.RAD2DEG * 2 * Math.atan(Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom);
  },
  getFilmWidth: function () {
    // film not completely covered in portrait format (aspect < 1)
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function () {
    // film not completely covered in landscape format (aspect > 1)
    return this.filmGauge / Math.max(this.aspect, 1);
  },

  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   var w = 1920;
   *   var h = 1080;
   *   var fullWidth = w * 3;
   *   var fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;

    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }

    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function () {
    if (this.view !== null) {
      this.view.enabled = false;
    }

    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function () {
    var near = this.near,
        top = near * Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom,
        height = 2 * top,
        width = this.aspect * height,
        left = -0.5 * width,
        view = this.view;

    if (this.view !== null && this.view.enabled) {
      var fullWidth = view.fullWidth,
          fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }

    var skew = this.filmOffset;
    if (skew !== 0) left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function (meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
});
/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

var fov = 90,
    aspect = 1;

function CubeCamera(near, far, cubeResolution, options) {
  Object3D.call(this);
  this.type = 'CubeCamera';
  var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
  cameraPX.up.set(0, -1, 0);
  cameraPX.lookAt(new Vector3(1, 0, 0));
  this.add(cameraPX);
  var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
  cameraNX.up.set(0, -1, 0);
  cameraNX.lookAt(new Vector3(-1, 0, 0));
  this.add(cameraNX);
  var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
  cameraPY.up.set(0, 0, 1);
  cameraPY.lookAt(new Vector3(0, 1, 0));
  this.add(cameraPY);
  var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
  cameraNY.up.set(0, 0, -1);
  cameraNY.lookAt(new Vector3(0, -1, 0));
  this.add(cameraNY);
  var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
  cameraPZ.up.set(0, -1, 0);
  cameraPZ.lookAt(new Vector3(0, 0, 1));
  this.add(cameraPZ);
  var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
  cameraNZ.up.set(0, -1, 0);
  cameraNZ.lookAt(new Vector3(0, 0, -1));
  this.add(cameraNZ);
  options = options || {
    format: RGBFormat,
    magFilter: LinearFilter,
    minFilter: LinearFilter
  };
  this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
  this.renderTarget.texture.name = "CubeCamera";

  this.update = function (renderer, scene) {
    if (this.parent === null) this.updateMatrixWorld();
    var currentRenderTarget = renderer.getRenderTarget();
    var renderTarget = this.renderTarget;
    var generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
  };

  this.clear = function (renderer, color, depth, stencil) {
    var currentRenderTarget = renderer.getRenderTarget();
    var renderTarget = this.renderTarget;

    for (var i = 0; i < 6; i++) {
      renderer.setRenderTarget(renderTarget, i);
      renderer.clear(color, depth, stencil);
    }

    renderer.setRenderTarget(currentRenderTarget);
  };
}

CubeCamera.prototype = Object.create(Object3D.prototype);
CubeCamera.prototype.constructor = CubeCamera;
/**
 * @author alteredq / http://alteredqualia.com
 * @author WestLangley / http://github.com/WestLangley
 */

function WebGLRenderTargetCube(width, height, options) {
  WebGLRenderTarget.call(this, width, height, options);
}

WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype);
WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

WebGLRenderTargetCube.prototype.fromEquirectangularTexture = function (renderer, texture) {
  this.texture.type = texture.type;
  this.texture.format = texture.format;
  this.texture.encoding = texture.encoding;
  var scene = new Scene();
  var shader = {
    uniforms: {
      tEquirect: {
        value: null
      }
    },
    vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {", "	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );", "}", "void main() {", "	vWorldDirection = transformDirection( position, modelMatrix );", "	#include <begin_vertex>", "	#include <project_vertex>", "}"].join('\n'),
    fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#define RECIPROCAL_PI 0.31830988618", "#define RECIPROCAL_PI2 0.15915494", "void main() {", "	vec3 direction = normalize( vWorldDirection );", "	vec2 sampleUV;", "	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;", "	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "	gl_FragColor = texture2D( tEquirect, sampleUV );", "}"].join('\n')
  };
  var material = new ShaderMaterial({
    type: 'CubemapFromEquirect',
    uniforms: cloneUniforms(shader.uniforms),
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader,
    side: BackSide,
    blending: NoBlending
  });
  material.uniforms.tEquirect.value = texture;
  var mesh = new Mesh(new BoxBufferGeometry(5, 5, 5), material);
  scene.add(mesh);
  var camera = new CubeCamera(1, 10, 1);
  camera.renderTarget = this;
  camera.renderTarget.texture.name = 'CubeCameraTexture';
  camera.update(renderer, scene);
  mesh.geometry.dispose();
  mesh.material.dispose();
  return this;
};
/**
 * @author alteredq / http://alteredqualia.com/
 */


function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.image = {
    data: data,
    width: width,
    height: height
  };
  this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
  this.generateMipmaps = false;
  this.flipY = false;
  this.unpackAlignment = 1;
}

DataTexture.prototype = Object.create(Texture.prototype);
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = true;
/**
 * @author bhouston / http://clara.io
 */

var _vector1 = new Vector3();

var _vector2 = new Vector3();

var _normalMatrix = new Matrix3();

function Plane(normal, constant) {
  // normal is assumed to be normalized
  this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
  this.constant = constant !== undefined ? constant : 0;
}

Object.assign(Plane.prototype, {
  isPlane: true,
  set: function (normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  },
  setComponents: function (x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  },
  setFromNormalAndCoplanarPoint: function (normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  },
  setFromCoplanarPoints: function (a, b, c) {
    var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?


    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  },
  normalize: function () {
    // Note: will lead to a divide by zero if the plane is invalid.
    var inverseNormalLength = 1.0 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  },
  negate: function () {
    this.constant *= -1;
    this.normal.negate();
    return this;
  },
  distanceToPoint: function (point) {
    return this.normal.dot(point) + this.constant;
  },
  distanceToSphere: function (sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  },
  projectPoint: function (point, target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .projectPoint() target is now required');
      target = new Vector3();
    }

    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  },
  intersectLine: function (line, target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .intersectLine() target is now required');
      target = new Vector3();
    }

    var direction = line.delta(_vector1);
    var denominator = this.normal.dot(direction);

    if (denominator === 0) {
      // line is coplanar, return origin
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      } // Unsure if this is the correct method to handle this case.


      return undefined;
    }

    var t = -(line.start.dot(this.normal) + this.constant) / denominator;

    if (t < 0 || t > 1) {
      return undefined;
    }

    return target.copy(direction).multiplyScalar(t).add(line.start);
  },
  intersectsLine: function (line) {
    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
    var startSign = this.distanceToPoint(line.start);
    var endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  },
  intersectsBox: function (box) {
    return box.intersectsPlane(this);
  },
  intersectsSphere: function (sphere) {
    return sphere.intersectsPlane(this);
  },
  coplanarPoint: function (target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .coplanarPoint() target is now required');
      target = new Vector3();
    }

    return target.copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function (matrix, optionalNormalMatrix) {
    var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);

    var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    var normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  },
  translate: function (offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  },
  equals: function (plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

var _sphere$1 = new Sphere();

var _vector$5 = new Vector3();

function Frustum(p0, p1, p2, p3, p4, p5) {
  this.planes = [p0 !== undefined ? p0 : new Plane(), p1 !== undefined ? p1 : new Plane(), p2 !== undefined ? p2 : new Plane(), p3 !== undefined ? p3 : new Plane(), p4 !== undefined ? p4 : new Plane(), p5 !== undefined ? p5 : new Plane()];
}

Object.assign(Frustum.prototype, {
  set: function (p0, p1, p2, p3, p4, p5) {
    var planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (frustum) {
    var planes = this.planes;

    for (var i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }

    return this;
  },
  setFromMatrix: function (m) {
    var planes = this.planes;
    var me = m.elements;
    var me0 = me[0],
        me1 = me[1],
        me2 = me[2],
        me3 = me[3];
    var me4 = me[4],
        me5 = me[5],
        me6 = me[6],
        me7 = me[7];
    var me8 = me[8],
        me9 = me[9],
        me10 = me[10],
        me11 = me[11];
    var me12 = me[12],
        me13 = me[13],
        me14 = me[14],
        me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  },
  intersectsObject: function (object) {
    var geometry = object.geometry;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

    _sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

    return this.intersectsSphere(_sphere$1);
  },
  intersectsSprite: function (sprite) {
    _sphere$1.center.set(0, 0, 0);

    _sphere$1.radius = 0.7071067811865476;

    _sphere$1.applyMatrix4(sprite.matrixWorld);

    return this.intersectsSphere(_sphere$1);
  },
  intersectsSphere: function (sphere) {
    var planes = this.planes;
    var center = sphere.center;
    var negRadius = -sphere.radius;

    for (var i = 0; i < 6; i++) {
      var distance = planes[i].distanceToPoint(center);

      if (distance < negRadius) {
        return false;
      }
    }

    return true;
  },
  intersectsBox: function (box) {
    var planes = this.planes;

    for (var i = 0; i < 6; i++) {
      var plane = planes[i]; // corner at max distance

      _vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;

      if (plane.distanceToPoint(_vector$5) < 0) {
        return false;
      }
    }

    return true;
  },
  containsPoint: function (point) {
    var planes = this.planes;

    for (var i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }

    return true;
  }
});
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif";
var lights_pars_begin = "uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = clamp( clearcoatRoughness, 0.04, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif";
var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";
var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, normalScale, normalMap );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 normalScale, in sampler2D normalMap ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy *= normalScale;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvec3 NfromST = cross( S, T );\n\t\t\tif( dot( NfromST, N ) > 0.0 ) {\n\t\t\t\tS *= -1.0;\n\t\t\t\tT *= -1.0;\n\t\t\t}\n\t\t#else\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = clearcoatNormalScale * mapN.xy;\n\t\tclearcoatNormal = normalize( vTBN * mapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatNormalScale, clearcoatNormalMap );\n\t#endif\n#endif";
var clearcoat_normalmap_pars_fragment = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 encodeHalfRGBA ( vec2 v ) {\n\tvec4 encoded = vec4( 0.0 );\n\tconst vec2 offset = vec2( 1.0 / 255.0, 0.0 );\n\tencoded.xy = vec2( v.x, fract( v.x * 255.0 ) );\n\tencoded.xy = encoded.xy - ( encoded.yy * offset );\n\tencoded.zw = vec2( v.y, fract( v.y * 255.0 ) );\n\tencoded.zw = encoded.zw - ( encoded.ww * offset );\n\treturn encoded;\n}\nvec2 decodeHalfRGBA( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn decodeHalfRGBA( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";
var uv_pars_fragment = "#ifdef USE_UV\n\tvarying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}";
var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var ShaderChunk = {
  alphamap_fragment: alphamap_fragment,
  alphamap_pars_fragment: alphamap_pars_fragment,
  alphatest_fragment: alphatest_fragment,
  aomap_fragment: aomap_fragment,
  aomap_pars_fragment: aomap_pars_fragment,
  begin_vertex: begin_vertex,
  beginnormal_vertex: beginnormal_vertex,
  bsdfs: bsdfs,
  bumpmap_pars_fragment: bumpmap_pars_fragment,
  clipping_planes_fragment: clipping_planes_fragment,
  clipping_planes_pars_fragment: clipping_planes_pars_fragment,
  clipping_planes_pars_vertex: clipping_planes_pars_vertex,
  clipping_planes_vertex: clipping_planes_vertex,
  color_fragment: color_fragment,
  color_pars_fragment: color_pars_fragment,
  color_pars_vertex: color_pars_vertex,
  color_vertex: color_vertex,
  common: common,
  cube_uv_reflection_fragment: cube_uv_reflection_fragment,
  defaultnormal_vertex: defaultnormal_vertex,
  displacementmap_pars_vertex: displacementmap_pars_vertex,
  displacementmap_vertex: displacementmap_vertex,
  emissivemap_fragment: emissivemap_fragment,
  emissivemap_pars_fragment: emissivemap_pars_fragment,
  encodings_fragment: encodings_fragment,
  encodings_pars_fragment: encodings_pars_fragment,
  envmap_fragment: envmap_fragment,
  envmap_common_pars_fragment: envmap_common_pars_fragment,
  envmap_pars_fragment: envmap_pars_fragment,
  envmap_pars_vertex: envmap_pars_vertex,
  envmap_physical_pars_fragment: envmap_physical_pars_fragment,
  envmap_vertex: envmap_vertex,
  fog_vertex: fog_vertex,
  fog_pars_vertex: fog_pars_vertex,
  fog_fragment: fog_fragment,
  fog_pars_fragment: fog_pars_fragment,
  gradientmap_pars_fragment: gradientmap_pars_fragment,
  lightmap_fragment: lightmap_fragment,
  lightmap_pars_fragment: lightmap_pars_fragment,
  lights_lambert_vertex: lights_lambert_vertex,
  lights_pars_begin: lights_pars_begin,
  lights_phong_fragment: lights_phong_fragment,
  lights_phong_pars_fragment: lights_phong_pars_fragment,
  lights_physical_fragment: lights_physical_fragment,
  lights_physical_pars_fragment: lights_physical_pars_fragment,
  lights_fragment_begin: lights_fragment_begin,
  lights_fragment_maps: lights_fragment_maps,
  lights_fragment_end: lights_fragment_end,
  logdepthbuf_fragment: logdepthbuf_fragment,
  logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
  logdepthbuf_vertex: logdepthbuf_vertex,
  map_fragment: map_fragment,
  map_pars_fragment: map_pars_fragment,
  map_particle_fragment: map_particle_fragment,
  map_particle_pars_fragment: map_particle_pars_fragment,
  metalnessmap_fragment: metalnessmap_fragment,
  metalnessmap_pars_fragment: metalnessmap_pars_fragment,
  morphnormal_vertex: morphnormal_vertex,
  morphtarget_pars_vertex: morphtarget_pars_vertex,
  morphtarget_vertex: morphtarget_vertex,
  normal_fragment_begin: normal_fragment_begin,
  normal_fragment_maps: normal_fragment_maps,
  normalmap_pars_fragment: normalmap_pars_fragment,
  clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
  clearcoat_normalmap_pars_fragment: clearcoat_normalmap_pars_fragment,
  packing: packing,
  premultiplied_alpha_fragment: premultiplied_alpha_fragment,
  project_vertex: project_vertex,
  dithering_fragment: dithering_fragment,
  dithering_pars_fragment: dithering_pars_fragment,
  roughnessmap_fragment: roughnessmap_fragment,
  roughnessmap_pars_fragment: roughnessmap_pars_fragment,
  shadowmap_pars_fragment: shadowmap_pars_fragment,
  shadowmap_pars_vertex: shadowmap_pars_vertex,
  shadowmap_vertex: shadowmap_vertex,
  shadowmask_pars_fragment: shadowmask_pars_fragment,
  skinbase_vertex: skinbase_vertex,
  skinning_pars_vertex: skinning_pars_vertex,
  skinning_vertex: skinning_vertex,
  skinnormal_vertex: skinnormal_vertex,
  specularmap_fragment: specularmap_fragment,
  specularmap_pars_fragment: specularmap_pars_fragment,
  tonemapping_fragment: tonemapping_fragment,
  tonemapping_pars_fragment: tonemapping_pars_fragment,
  uv_pars_fragment: uv_pars_fragment,
  uv_pars_vertex: uv_pars_vertex,
  uv_vertex: uv_vertex,
  uv2_pars_fragment: uv2_pars_fragment,
  uv2_pars_vertex: uv2_pars_vertex,
  uv2_vertex: uv2_vertex,
  worldpos_vertex: worldpos_vertex,
  background_frag: background_frag,
  background_vert: background_vert,
  cube_frag: cube_frag,
  cube_vert: cube_vert,
  depth_frag: depth_frag,
  depth_vert: depth_vert,
  distanceRGBA_frag: distanceRGBA_frag,
  distanceRGBA_vert: distanceRGBA_vert,
  equirect_frag: equirect_frag,
  equirect_vert: equirect_vert,
  linedashed_frag: linedashed_frag,
  linedashed_vert: linedashed_vert,
  meshbasic_frag: meshbasic_frag,
  meshbasic_vert: meshbasic_vert,
  meshlambert_frag: meshlambert_frag,
  meshlambert_vert: meshlambert_vert,
  meshmatcap_frag: meshmatcap_frag,
  meshmatcap_vert: meshmatcap_vert,
  meshphong_frag: meshphong_frag,
  meshphong_vert: meshphong_vert,
  meshphysical_frag: meshphysical_frag,
  meshphysical_vert: meshphysical_vert,
  normal_frag: normal_frag,
  normal_vert: normal_vert,
  points_frag: points_frag,
  points_vert: points_vert,
  shadow_frag: shadow_frag,
  shadow_vert: shadow_vert,
  sprite_frag: sprite_frag,
  sprite_vert: sprite_vert
};
/**
 * Uniforms library for shared webgl shaders
 */

exports.ShaderChunk = ShaderChunk;
var UniformsLib = {
  common: {
    diffuse: {
      value: new Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    map: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    },
    alphaMap: {
      value: null
    }
  },
  specularmap: {
    specularMap: {
      value: null
    }
  },
  envmap: {
    envMap: {
      value: null
    },
    flipEnvMap: {
      value: -1
    },
    reflectivity: {
      value: 1.0
    },
    refractionRatio: {
      value: 0.98
    },
    maxMipLevel: {
      value: 0
    }
  },
  aomap: {
    aoMap: {
      value: null
    },
    aoMapIntensity: {
      value: 1
    }
  },
  lightmap: {
    lightMap: {
      value: null
    },
    lightMapIntensity: {
      value: 1
    }
  },
  emissivemap: {
    emissiveMap: {
      value: null
    }
  },
  bumpmap: {
    bumpMap: {
      value: null
    },
    bumpScale: {
      value: 1
    }
  },
  normalmap: {
    normalMap: {
      value: null
    },
    normalScale: {
      value: new Vector2(1, 1)
    }
  },
  displacementmap: {
    displacementMap: {
      value: null
    },
    displacementScale: {
      value: 1
    },
    displacementBias: {
      value: 0
    }
  },
  roughnessmap: {
    roughnessMap: {
      value: null
    }
  },
  metalnessmap: {
    metalnessMap: {
      value: null
    }
  },
  gradientmap: {
    gradientMap: {
      value: null
    }
  },
  fog: {
    fogDensity: {
      value: 0.00025
    },
    fogNear: {
      value: 1
    },
    fogFar: {
      value: 2000
    },
    fogColor: {
      value: new Color(0xffffff)
    }
  },
  lights: {
    ambientLightColor: {
      value: []
    },
    lightProbe: {
      value: []
    },
    directionalLights: {
      value: [],
      properties: {
        direction: {},
        color: {},
        shadow: {},
        shadowBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    directionalShadowMap: {
      value: []
    },
    directionalShadowMatrix: {
      value: []
    },
    spotLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {},
        shadow: {},
        shadowBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    spotShadowMap: {
      value: []
    },
    spotShadowMatrix: {
      value: []
    },
    pointLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        decay: {},
        distance: {},
        shadow: {},
        shadowBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      }
    },
    pointShadowMap: {
      value: []
    },
    pointShadowMatrix: {
      value: []
    },
    hemisphereLights: {
      value: [],
      properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      }
    },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      }
    }
  },
  points: {
    diffuse: {
      value: new Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    size: {
      value: 1.0
    },
    scale: {
      value: 1.0
    },
    map: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    }
  },
  sprite: {
    diffuse: {
      value: new Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    center: {
      value: new Vector2(0.5, 0.5)
    },
    rotation: {
      value: 0.0
    },
    map: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    }
  }
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

exports.UniformsLib = UniformsLib;
var ShaderLib = {
  basic: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      }
    }]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      },
      specular: {
        value: new Color(0x111111)
      },
      shininess: {
        value: 30
      }
    }]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      },
      roughness: {
        value: 0.5
      },
      metalness: {
        value: 0.5
      },
      envMapIntensity: {
        value: 1 // temporary

      }
    }]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  matcap: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
      matcap: {
        value: null
      }
    }]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
      scale: {
        value: 1
      },
      dashSize: {
        value: 1
      },
      totalSize: {
        value: 2
      }
    }]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: {
        value: new Matrix3()
      },
      t2D: {
        value: null
      }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },

  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: {
      tCube: {
        value: null
      },
      tFlip: {
        value: -1
      },
      opacity: {
        value: 1.0
      }
    },
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {
        value: null
      }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
      referencePosition: {
        value: new Vector3()
      },
      nearDistance: {
        value: 1
      },
      farDistance: {
        value: 1000
      }
    }]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
      color: {
        value: new Color(0x00000)
      },
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
exports.ShaderLib = ShaderLib;
ShaderLib.physical = {
  uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
    transparency: {
      value: 0
    },
    clearcoat: {
      value: 0
    },
    clearcoatRoughness: {
      value: 0
    },
    sheen: {
      value: new Color(0x000000)
    },
    clearcoatNormalScale: {
      value: new Vector2(1, 1)
    },
    clearcoatNormalMap: {
      value: null
    }
  }]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLAnimation() {
  var context = null;
  var isAnimating = false;
  var animationLoop = null;

  function onAnimationFrame(time, frame) {
    if (isAnimating === false) return;
    animationLoop(time, frame);
    context.requestAnimationFrame(onAnimationFrame);
  }

  return {
    start: function () {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function () {
      isAnimating = false;
    },
    setAnimationLoop: function (callback) {
      animationLoop = callback;
    },
    setContext: function (value) {
      context = value;
    }
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLAttributes(gl) {
  var buffers = new WeakMap();

  function createBuffer(attribute, bufferType) {
    var array = attribute.array;
    var usage = attribute.dynamic ? 35048 : 35044;
    var buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    var type = 5126;

    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Float64Array) {
      console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
    } else if (array instanceof Uint16Array) {
      type = 5123;
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    }

    return {
      buffer: buffer,
      type: type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }

  function updateBuffer(buffer, attribute, bufferType) {
    var array = attribute.array;
    var updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);

    if (attribute.dynamic === false) {
      gl.bufferData(bufferType, array, 35044);
    } else if (updateRange.count === -1) {
      // Not using update ranges
      gl.bufferSubData(bufferType, 0, array);
    } else if (updateRange.count === 0) {
      console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
    } else {
      gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      updateRange.count = -1; // reset range
    }
  } //


  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }

  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    var data = buffers.get(attribute);

    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }

  function update(attribute, bufferType) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    var data = buffers.get(attribute);

    if (data === undefined) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }

  return {
    get: get,
    remove: remove,
    update: update
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */
// PlaneGeometry


function PlaneGeometry(width, height, widthSegments, heightSegments) {
  Geometry.call(this);
  this.type = 'PlaneGeometry';
  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };
  this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
  this.mergeVertices();
}

PlaneGeometry.prototype = Object.create(Geometry.prototype);
PlaneGeometry.prototype.constructor = PlaneGeometry; // PlaneBufferGeometry

function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
  BufferGeometry.call(this);
  this.type = 'PlaneBufferGeometry';
  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };
  width = width || 1;
  height = height || 1;
  var width_half = width / 2;
  var height_half = height / 2;
  var gridX = Math.floor(widthSegments) || 1;
  var gridY = Math.floor(heightSegments) || 1;
  var gridX1 = gridX + 1;
  var gridY1 = gridY + 1;
  var segment_width = width / gridX;
  var segment_height = height / gridY;
  var ix, iy; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // generate vertices, normals and uvs

  for (iy = 0; iy < gridY1; iy++) {
    var y = iy * segment_height - height_half;

    for (ix = 0; ix < gridX1; ix++) {
      var x = ix * segment_width - width_half;
      vertices.push(x, -y, 0);
      normals.push(0, 0, 1);
      uvs.push(ix / gridX);
      uvs.push(1 - iy / gridY);
    }
  } // indices


  for (iy = 0; iy < gridY; iy++) {
    for (ix = 0; ix < gridX; ix++) {
      var a = ix + gridX1 * iy;
      var b = ix + gridX1 * (iy + 1);
      var c = ix + 1 + gridX1 * (iy + 1);
      var d = ix + 1 + gridX1 * iy; // faces

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLBackground(renderer, state, objects, premultipliedAlpha) {
  var clearColor = new Color(0x000000);
  var clearAlpha = 0;
  var planeMesh;
  var boxMesh; // Store the current background texture and its `version`
  // so we can recompile the material accordingly.

  var currentBackground = null;
  var currentBackgroundVersion = 0;

  function render(renderList, scene, camera, forceClear) {
    var background = scene.background; // Ignore background in AR
    // TODO: Reconsider this.

    var vr = renderer.vr;
    var session = vr.getSession && vr.getSession();

    if (session && session.environmentBlendMode === 'additive') {
      background = null;
    }

    if (background === null) {
      setClear(clearColor, clearAlpha);
      currentBackground = null;
      currentBackgroundVersion = 0;
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
      currentBackground = null;
      currentBackgroundVersion = 0;
    }

    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }

    if (background && (background.isCubeTexture || background.isWebGLRenderTargetCube)) {
      if (boxMesh === undefined) {
        boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
          type: 'BackgroundCubeMaterial',
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.removeAttribute('normal');
        boxMesh.geometry.removeAttribute('uv');

        boxMesh.onBeforeRender = function (renderer, scene, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        }; // enable code injection for non-built-in material


        Object.defineProperty(boxMesh.material, 'map', {
          get: function () {
            return this.uniforms.tCube.value;
          }
        });
        objects.update(boxMesh);
      }

      var texture = background.isWebGLRenderTargetCube ? background.texture : background;
      boxMesh.material.uniforms.tCube.value = texture;
      boxMesh.material.uniforms.tFlip.value = background.isWebGLRenderTargetCube ? 1 : -1;

      if (currentBackground !== background || currentBackgroundVersion !== texture.version) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = texture.version;
      } // push to the pre-sorted opaque render list


      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === undefined) {
        planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({
          type: 'BackgroundMaterial',
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.removeAttribute('normal'); // enable code injection for non-built-in material

        Object.defineProperty(planeMesh.material, 'map', {
          get: function () {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }

      planeMesh.material.uniforms.t2D.value = background;

      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }

      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

      if (currentBackground !== background || currentBackgroundVersion !== background.version) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
      } // push to the pre-sorted opaque render list


      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }

  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }

  return {
    getClearColor: function () {
      return clearColor;
    },
    setClearColor: function (color, alpha) {
      clearColor.set(color);
      clearAlpha = alpha !== undefined ? alpha : 1;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function () {
      return clearAlpha;
    },
    setClearAlpha: function (alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render: render
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  var mode;

  function setMode(value) {
    mode = value;
  }

  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode);
  }

  function renderInstances(geometry, start, count) {
    var extension, methodName;

    if (capabilities.isWebGL2) {
      extension = gl;
      methodName = 'drawArraysInstanced';
    } else {
      extension = extensions.get('ANGLE_instanced_arrays');
      methodName = 'drawArraysInstancedANGLE';

      if (extension === null) {
        console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }

    extension[methodName](mode, start, count, geometry.maxInstancedCount);
    info.update(count, mode, geometry.maxInstancedCount);
  } //


  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLCapabilities(gl, extensions, parameters) {
  var maxAnisotropy;

  function getMaxAnisotropy() {
    if (maxAnisotropy !== undefined) return maxAnisotropy;
    var extension = extensions.get('EXT_texture_filter_anisotropic');

    if (extension !== null) {
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }

    return maxAnisotropy;
  }

  function getMaxPrecision(precision) {
    if (precision === 'highp') {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return 'highp';
      }

      precision = 'mediump';
    }

    if (precision === 'mediump') {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return 'mediump';
      }
    }

    return 'lowp';
  }

  var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;
  var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
  var maxPrecision = getMaxPrecision(precision);

  if (maxPrecision !== precision) {
    console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
    precision = maxPrecision;
  }

  var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  var maxTextures = gl.getParameter(34930);
  var maxVertexTextures = gl.getParameter(35660);
  var maxTextureSize = gl.getParameter(3379);
  var maxCubemapSize = gl.getParameter(34076);
  var maxAttributes = gl.getParameter(34921);
  var maxVertexUniforms = gl.getParameter(36347);
  var maxVaryings = gl.getParameter(36348);
  var maxFragmentUniforms = gl.getParameter(36349);
  var vertexTextures = maxVertexTextures > 0;
  var floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
  var floatVertexTextures = vertexTextures && floatFragmentTextures;
  var maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2: isWebGL2,
    getMaxAnisotropy: getMaxAnisotropy,
    getMaxPrecision: getMaxPrecision,
    precision: precision,
    logarithmicDepthBuffer: logarithmicDepthBuffer,
    maxTextures: maxTextures,
    maxVertexTextures: maxVertexTextures,
    maxTextureSize: maxTextureSize,
    maxCubemapSize: maxCubemapSize,
    maxAttributes: maxAttributes,
    maxVertexUniforms: maxVertexUniforms,
    maxVaryings: maxVaryings,
    maxFragmentUniforms: maxFragmentUniforms,
    vertexTextures: vertexTextures,
    floatFragmentTextures: floatFragmentTextures,
    floatVertexTextures: floatVertexTextures,
    maxSamples: maxSamples
  };
}
/**
 * @author tschw
 */


function WebGLClipping() {
  var scope = this,
      globalState = null,
      numGlobalPlanes = 0,
      localClippingEnabled = false,
      renderingShadows = false,
      plane = new Plane(),
      viewNormalMatrix = new Matrix3(),
      uniform = {
    value: null,
    needsUpdate: false
  };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;

  this.init = function (planes, enableLocalClipping, camera) {
    var enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };

  this.beginShadows = function () {
    renderingShadows = true;
    projectPlanes(null);
  };

  this.endShadows = function () {
    renderingShadows = false;
    resetGlobalState();
  };

  this.setState = function (planes, clipIntersection, clipShadows, camera, cache, fromCache) {
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      // there's no local clipping
      if (renderingShadows) {
        // there's no global clipping
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
          lGlobal = nGlobal * 4,
          dstArray = cache.clippingState || null;
      uniform.value = dstArray; // ensure unique state

      dstArray = projectPlanes(planes, camera, lGlobal, fromCache);

      for (var i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }

      cache.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };

  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }

    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }

  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    var nPlanes = planes !== null ? planes.length : 0,
        dstArray = null;

    if (nPlanes !== 0) {
      dstArray = uniform.value;

      if (skipTransform !== true || dstArray === null) {
        var flatSize = dstOffset + nPlanes * 4,
            viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);

        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }

        for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }

      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }

    scope.numPlanes = nPlanes;
    return dstArray;
  }
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLExtensions(gl) {
  var extensions = {};
  return {
    get: function (name) {
      if (extensions[name] !== undefined) {
        return extensions[name];
      }

      var extension;

      switch (name) {
        case 'WEBGL_depth_texture':
          extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
          break;

        case 'EXT_texture_filter_anisotropic':
          extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
          break;

        case 'WEBGL_compressed_texture_s3tc':
          extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
          break;

        case 'WEBGL_compressed_texture_pvrtc':
          extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
          break;

        default:
          extension = gl.getExtension(name);
      }

      if (extension === null) {
        console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
      }

      extensions[name] = extension;
      return extension;
    }
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLGeometries(gl, attributes, info) {
  var geometries = new WeakMap();
  var wireframeAttributes = new WeakMap();

  function onGeometryDispose(event) {
    var geometry = event.target;
    var buffergeometry = geometries.get(geometry);

    if (buffergeometry.index !== null) {
      attributes.remove(buffergeometry.index);
    }

    for (var name in buffergeometry.attributes) {
      attributes.remove(buffergeometry.attributes[name]);
    }

    geometry.removeEventListener('dispose', onGeometryDispose);
    geometries.delete(geometry);
    var attribute = wireframeAttributes.get(buffergeometry);

    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(buffergeometry);
    } //


    info.memory.geometries--;
  }

  function get(object, geometry) {
    var buffergeometry = geometries.get(geometry);
    if (buffergeometry) return buffergeometry;
    geometry.addEventListener('dispose', onGeometryDispose);

    if (geometry.isBufferGeometry) {
      buffergeometry = geometry;
    } else if (geometry.isGeometry) {
      if (geometry._bufferGeometry === undefined) {
        geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
      }

      buffergeometry = geometry._bufferGeometry;
    }

    geometries.set(geometry, buffergeometry);
    info.memory.geometries++;
    return buffergeometry;
  }

  function update(geometry) {
    var index = geometry.index;
    var geometryAttributes = geometry.attributes;

    if (index !== null) {
      attributes.update(index, 34963);
    }

    for (var name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    } // morph targets


    var morphAttributes = geometry.morphAttributes;

    for (var name in morphAttributes) {
      var array = morphAttributes[name];

      for (var i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], 34962);
      }
    }
  }

  function updateWireframeAttribute(geometry) {
    var indices = [];
    var geometryIndex = geometry.index;
    var geometryPosition = geometry.attributes.position;
    var version = 0;

    if (geometryIndex !== null) {
      var array = geometryIndex.array;
      version = geometryIndex.version;

      for (var i = 0, l = array.length; i < l; i += 3) {
        var a = array[i + 0];
        var b = array[i + 1];
        var c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      var array = geometryPosition.array;
      version = geometryPosition.version;

      for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        var a = i + 0;
        var b = i + 1;
        var c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    }

    var attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    attributes.update(attribute, 34963); //

    var previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) attributes.remove(previousAttribute); //

    wireframeAttributes.set(geometry, attribute);
  }

  function getWireframeAttribute(geometry) {
    var currentAttribute = wireframeAttributes.get(geometry);

    if (currentAttribute) {
      var geometryIndex = geometry.index;

      if (geometryIndex !== null) {
        // if the attribute is obsolete, create a new one
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }

    return wireframeAttributes.get(geometry);
  }

  return {
    get: get,
    update: update,
    getWireframeAttribute: getWireframeAttribute
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  var mode;

  function setMode(value) {
    mode = value;
  }

  var type, bytesPerElement;

  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }

  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode);
  }

  function renderInstances(geometry, start, count) {
    var extension, methodName;

    if (capabilities.isWebGL2) {
      extension = gl;
      methodName = 'drawElementsInstanced';
    } else {
      extension = extensions.get('ANGLE_instanced_arrays');
      methodName = 'drawElementsInstancedANGLE';

      if (extension === null) {
        console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }

    extension[methodName](mode, count, type, start * bytesPerElement, geometry.maxInstancedCount);
    info.update(count, mode, geometry.maxInstancedCount);
  } //


  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
/**
 * @author Mugen87 / https://github.com/Mugen87
 */


function WebGLInfo(gl) {
  var memory = {
    geometries: 0,
    textures: 0
  };
  var render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };

  function update(count, mode, instanceCount) {
    instanceCount = instanceCount || 1;
    render.calls++;

    switch (mode) {
      case 4:
        render.triangles += instanceCount * (count / 3);
        break;

      case 5:
      case 6:
        render.triangles += instanceCount * (count - 2);
        break;

      case 1:
        render.lines += instanceCount * (count / 2);
        break;

      case 3:
        render.lines += instanceCount * (count - 1);
        break;

      case 2:
        render.lines += instanceCount * count;
        break;

      case 0:
        render.points += instanceCount * count;
        break;

      default:
        console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
        break;
    }
  }

  function reset() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }

  return {
    memory: memory,
    render: render,
    programs: null,
    autoReset: true,
    reset: reset,
    update: update
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}

function WebGLMorphtargets(gl) {
  var influencesList = {};
  var morphInfluences = new Float32Array(8);

  function update(object, geometry, material, program) {
    var objectInfluences = object.morphTargetInfluences;
    var length = objectInfluences.length;
    var influences = influencesList[geometry.id];

    if (influences === undefined) {
      // initialise list
      influences = [];

      for (var i = 0; i < length; i++) {
        influences[i] = [i, 0];
      }

      influencesList[geometry.id] = influences;
    }

    var morphTargets = material.morphTargets && geometry.morphAttributes.position;
    var morphNormals = material.morphNormals && geometry.morphAttributes.normal; // Remove current morphAttributes

    for (var i = 0; i < length; i++) {
      var influence = influences[i];

      if (influence[1] !== 0) {
        if (morphTargets) geometry.removeAttribute('morphTarget' + i);
        if (morphNormals) geometry.removeAttribute('morphNormal' + i);
      }
    } // Collect influences


    for (var i = 0; i < length; i++) {
      var influence = influences[i];
      influence[0] = i;
      influence[1] = objectInfluences[i];
    }

    influences.sort(absNumericalSort); // Add morphAttributes

    for (var i = 0; i < 8; i++) {
      var influence = influences[i];

      if (influence) {
        var index = influence[0];
        var value = influence[1];

        if (value) {
          if (morphTargets) geometry.addAttribute('morphTarget' + i, morphTargets[index]);
          if (morphNormals) geometry.addAttribute('morphNormal' + i, morphNormals[index]);
          morphInfluences[i] = value;
          continue;
        }
      }

      morphInfluences[i] = 0;
    }

    program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
  }

  return {
    update: update
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLObjects(geometries, info) {
  var updateList = {};

  function update(object) {
    var frame = info.render.frame;
    var geometry = object.geometry;
    var buffergeometry = geometries.get(object, geometry); // Update once per frame

    if (updateList[buffergeometry.id] !== frame) {
      if (geometry.isGeometry) {
        buffergeometry.updateFromObject(object);
      }

      geometries.update(buffergeometry);
      updateList[buffergeometry.id] = frame;
    }

    return buffergeometry;
  }

  function dispose() {
    updateList = {};
  }

  return {
    update: update,
    dispose: dispose
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
  images = images !== undefined ? images : [];
  mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
  format = format !== undefined ? format : RGBFormat;
  Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.flipY = false;
}

CubeTexture.prototype = Object.create(Texture.prototype);
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;
Object.defineProperty(CubeTexture.prototype, 'images', {
  get: function () {
    return this.image;
  },
  set: function (value) {
    this.image = value;
  }
});
/**
 * @author Takahiro https://github.com/takahirox
 */

function DataTexture2DArray(data, width, height, depth) {
  Texture.call(this, null);
  this.image = {
    data: data,
    width: width,
    height: height,
    depth: depth
  };
  this.magFilter = NearestFilter;
  this.minFilter = NearestFilter;
  this.wrapR = ClampToEdgeWrapping;
  this.generateMipmaps = false;
  this.flipY = false;
}

DataTexture2DArray.prototype = Object.create(Texture.prototype);
DataTexture2DArray.prototype.constructor = DataTexture2DArray;
DataTexture2DArray.prototype.isDataTexture2DArray = true;
/**
 * @author Artur Trzesiok
 */

function DataTexture3D(data, width, height, depth) {
  // We're going to add .setXXX() methods for setting properties later.
  // Users can still set in DataTexture3D directly.
  //
  //	var texture = new THREE.DataTexture3D( data, width, height, depth );
  // 	texture.anisotropy = 16;
  //
  // See #14839
  Texture.call(this, null);
  this.image = {
    data: data,
    width: width,
    height: height,
    depth: depth
  };
  this.magFilter = NearestFilter;
  this.minFilter = NearestFilter;
  this.wrapR = ClampToEdgeWrapping;
  this.generateMipmaps = false;
  this.flipY = false;
}

DataTexture3D.prototype = Object.create(Texture.prototype);
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;
/**
 * @author tschw
 * @author Mugen87 / https://github.com/Mugen87
 * @author mrdoob / http://mrdoob.com/
 *
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

var emptyTexture = new Texture();
var emptyTexture2dArray = new DataTexture2DArray();
var emptyTexture3d = new DataTexture3D();
var emptyCubeTexture = new CubeTexture(); // --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)

var arrayCacheF32 = [];
var arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms

var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices

function flatten(array, nBlocks, blockSize) {
  var firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )
  // see http://jacksondunstan.com/articles/983

  var n = nBlocks * blockSize,
      r = arrayCacheF32[n];

  if (r === undefined) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }

  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);

    for (var i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }

  return r;
}

function arraysEqual(a, b) {
  if (a.length !== b.length) return false;

  for (var i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i]) return false;
  }

  return true;
}

function copyArray(a, b) {
  for (var i = 0, l = b.length; i < l; i++) {
    a[i] = b[i];
  }
} // Texture unit allocation


function allocTexUnits(textures, n) {
  var r = arrayCacheI32[n];

  if (r === undefined) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }

  for (var i = 0; i !== n; ++i) r[i] = textures.allocateTextureUnit();

  return r;
} // --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar


function setValueV1f(gl, v) {
  var cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
} // Single float vector (from flat array or THREE.VectorN)


function setValueV2f(gl, v) {
  var cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}

function setValueV3f(gl, v) {
  var cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== undefined) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}

function setValueV4f(gl, v) {
  var cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
} // Single matrix (from flat array or MatrixN)


function setValueM2(gl, v) {
  var cache = this.cache;
  var elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}

function setValueM3(gl, v) {
  var cache = this.cache;
  var elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}

function setValueM4(gl, v) {
  var cache = this.cache;
  var elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
} // Single texture (2D / Cube)


function setValueT1(gl, v, textures) {
  var cache = this.cache;
  var unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.safeSetTexture2D(v || emptyTexture, unit);
}

function setValueT2DArray1(gl, v, textures) {
  var cache = this.cache;
  var unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.setTexture2DArray(v || emptyTexture2dArray, unit);
}

function setValueT3D1(gl, v, textures) {
  var cache = this.cache;
  var unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.setTexture3D(v || emptyTexture3d, unit);
}

function setValueT6(gl, v, textures) {
  var cache = this.cache;
  var unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.safeSetTextureCube(v || emptyCubeTexture, unit);
} // Integer / Boolean vectors or arrays thereof (always flat arrays)


function setValueV1i(gl, v) {
  var cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
}

function setValueV2i(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform2iv(this.addr, v);
  copyArray(cache, v);
}

function setValueV3i(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform3iv(this.addr, v);
  copyArray(cache, v);
}

function setValueV4i(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform4iv(this.addr, v);
  copyArray(cache, v);
} // Helper to pick the right setter for the singular case


function getSingularSetter(type) {
  switch (type) {
    case 0x1406:
      return setValueV1f;
    // FLOAT

    case 0x8b50:
      return setValueV2f;
    // _VEC2

    case 0x8b51:
      return setValueV3f;
    // _VEC3

    case 0x8b52:
      return setValueV4f;
    // _VEC4

    case 0x8b5a:
      return setValueM2;
    // _MAT2

    case 0x8b5b:
      return setValueM3;
    // _MAT3

    case 0x8b5c:
      return setValueM4;
    // _MAT4

    case 0x8b5e:
    case 0x8d66:
      return setValueT1;
    // SAMPLER_2D, SAMPLER_EXTERNAL_OES

    case 0x8b5f:
      return setValueT3D1;
    // SAMPLER_3D

    case 0x8b60:
      return setValueT6;
    // SAMPLER_CUBE

    case 0x8DC1:
      return setValueT2DArray1;
    // SAMPLER_2D_ARRAY

    case 0x1404:
    case 0x8b56:
      return setValueV1i;
    // INT, BOOL

    case 0x8b53:
    case 0x8b57:
      return setValueV2i;
    // _VEC2

    case 0x8b54:
    case 0x8b58:
      return setValueV3i;
    // _VEC3

    case 0x8b55:
    case 0x8b59:
      return setValueV4i;
    // _VEC4
  }
} // Array of scalars


function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
} // Integer / Boolean vectors or arrays thereof (always flat arrays)


function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}

function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}

function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}

function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
} // Array of vectors (flat or from THREE classes)


function setValueV2fArray(gl, v) {
  var data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}

function setValueV3fArray(gl, v) {
  var data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}

function setValueV4fArray(gl, v) {
  var data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
} // Array of matrices (flat or from THREE clases)


function setValueM2Array(gl, v) {
  var data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}

function setValueM3Array(gl, v) {
  var data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}

function setValueM4Array(gl, v) {
  var data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
} // Array of textures (2D / Cube)


function setValueT1Array(gl, v, textures) {
  var n = v.length;
  var units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);

  for (var i = 0; i !== n; ++i) {
    textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
  }
}

function setValueT6Array(gl, v, textures) {
  var n = v.length;
  var units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);

  for (var i = 0; i !== n; ++i) {
    textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
} // Helper to pick the right setter for a pure (bottom-level) array


function getPureArraySetter(type) {
  switch (type) {
    case 0x1406:
      return setValueV1fArray;
    // FLOAT

    case 0x8b50:
      return setValueV2fArray;
    // _VEC2

    case 0x8b51:
      return setValueV3fArray;
    // _VEC3

    case 0x8b52:
      return setValueV4fArray;
    // _VEC4

    case 0x8b5a:
      return setValueM2Array;
    // _MAT2

    case 0x8b5b:
      return setValueM3Array;
    // _MAT3

    case 0x8b5c:
      return setValueM4Array;
    // _MAT4

    case 0x8b5e:
      return setValueT1Array;
    // SAMPLER_2D

    case 0x8b60:
      return setValueT6Array;
    // SAMPLER_CUBE

    case 0x1404:
    case 0x8b56:
      return setValueV1iArray;
    // INT, BOOL

    case 0x8b53:
    case 0x8b57:
      return setValueV2iArray;
    // _VEC2

    case 0x8b54:
    case 0x8b58:
      return setValueV3iArray;
    // _VEC3

    case 0x8b55:
    case 0x8b59:
      return setValueV4iArray;
    // _VEC4
  }
} // --- Uniform Classes ---


function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
}

function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
}

PureArrayUniform.prototype.updateCache = function (data) {
  var cache = this.cache;

  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }

  copyArray(cache, data);
};

function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}

StructuredUniform.prototype.setValue = function (gl, value, textures) {
  var seq = this.seq;

  for (var i = 0, n = seq.length; i !== n; ++i) {
    var u = seq[i];
    u.setValue(gl, value[u.id], textures);
  }
}; // --- Top-level ---
// Parser - builds up the property tree from the path strings


var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g; // extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}

function parseUniform(activeInfo, addr, container) {
  var path = activeInfo.name,
      pathLength = path.length; // reset RegExp object, because of the early exit of a previous run

  RePathPart.lastIndex = 0;

  while (true) {
    var match = RePathPart.exec(path),
        matchEnd = RePathPart.lastIndex,
        id = match[1],
        idIsIndex = match[2] === ']',
        subscript = match[3];
    if (idIsIndex) id = id | 0; // convert to integer

    if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
      // bare name or "pure" bottom-level array "[0]" suffix
      addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      // step into inner node / create it in case it doesn't exist
      var map = container.map,
          next = map[id];

      if (next === undefined) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }

      container = next;
    }
  }
} // Root Container


function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  var n = gl.getProgramParameter(program, 35718);

  for (var i = 0; i < n; ++i) {
    var info = gl.getActiveUniform(program, i),
        addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}

WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
  var u = this.map[name];
  if (u !== undefined) u.setValue(gl, value, textures);
};

WebGLUniforms.prototype.setOptional = function (gl, object, name) {
  var v = object[name];
  if (v !== undefined) this.setValue(gl, name, v);
}; // Static interface


WebGLUniforms.upload = function (gl, seq, values, textures) {
  for (var i = 0, n = seq.length; i !== n; ++i) {
    var u = seq[i],
        v = values[u.id];

    if (v.needsUpdate !== false) {
      // note: always updating when .needsUpdate is undefined
      u.setValue(gl, v.value, textures);
    }
  }
};

WebGLUniforms.seqWithValue = function (seq, values) {
  var r = [];

  for (var i = 0, n = seq.length; i !== n; ++i) {
    var u = seq[i];
    if (u.id in values) r.push(u);
  }

  return r;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLShader(gl, type, string) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


var programIdCount = 0;

function addLineNumbers(string) {
  var lines = string.split('\n');

  for (var i = 0; i < lines.length; i++) {
    lines[i] = i + 1 + ': ' + lines[i];
  }

  return lines.join('\n');
}

function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ['Linear', '( value )'];

    case sRGBEncoding:
      return ['sRGB', '( value )'];

    case RGBEEncoding:
      return ['RGBE', '( value )'];

    case RGBM7Encoding:
      return ['RGBM', '( value, 7.0 )'];

    case RGBM16Encoding:
      return ['RGBM', '( value, 16.0 )'];

    case RGBDEncoding:
      return ['RGBD', '( value, 256.0 )'];

    case GammaEncoding:
      return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];

    case LogLuvEncoding:
      return ['LogLuv', '( value )'];

    default:
      throw new Error('unsupported encoding: ' + encoding);
  }
}

function getShaderErrors(gl, shader, type) {
  var status = gl.getShaderParameter(shader, 35713);
  var log = gl.getShaderInfoLog(shader).trim();
  if (status && log === '') return ''; // --enable-privileged-webgl-extension
  // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

  var source = gl.getShaderSource(shader);
  return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
}

function getTexelDecodingFunction(functionName, encoding) {
  var components = getEncodingComponents(encoding);
  return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
}

function getTexelEncodingFunction(functionName, encoding) {
  var components = getEncodingComponents(encoding);
  return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}

function getToneMappingFunction(functionName, toneMapping) {
  var toneMappingName;

  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = 'Linear';
      break;

    case ReinhardToneMapping:
      toneMappingName = 'Reinhard';
      break;

    case Uncharted2ToneMapping:
      toneMappingName = 'Uncharted2';
      break;

    case CineonToneMapping:
      toneMappingName = 'OptimizedCineon';
      break;

    case ACESFilmicToneMapping:
      toneMappingName = 'ACESFilmic';
      break;

    default:
      throw new Error('unsupported toneMapping: ' + toneMapping);
  }

  return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}

function generateExtensions(extensions, parameters, rendererExtensions) {
  extensions = extensions || {};
  var chunks = [extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading ? '#extension GL_OES_standard_derivatives : enable' : '', (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '', extensions.drawBuffers && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '', (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
  return chunks.filter(filterEmptyLine).join('\n');
}

function generateDefines(defines) {
  var chunks = [];

  for (var name in defines) {
    var value = defines[name];
    if (value === false) continue;
    chunks.push('#define ' + name + ' ' + value);
  }

  return chunks.join('\n');
}

function fetchAttributeLocations(gl, program) {
  var attributes = {};
  var n = gl.getProgramParameter(program, 35721);

  for (var i = 0; i < n; i++) {
    var info = gl.getActiveAttrib(program, i);
    var name = info.name; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

    attributes[name] = gl.getAttribLocation(program, name);
  }

  return attributes;
}

function filterEmptyLine(string) {
  return string !== '';
}

function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}

function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}

function parseIncludes(string) {
  var pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

  function replace(match, include) {
    var replace = ShaderChunk[include];

    if (replace === undefined) {
      throw new Error('Can not resolve #include <' + include + '>');
    }

    return parseIncludes(replace);
  }

  return string.replace(pattern, replace);
}

function unrollLoops(string) {
  var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

  function replace(match, start, end, snippet) {
    var unroll = '';

    for (var i = parseInt(start); i < parseInt(end); i++) {
      unroll += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);
    }

    return unroll;
  }

  return string.replace(pattern, replace);
}

function WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities) {
  var gl = renderer.getContext();
  var defines = material.defines;
  var vertexShader = shader.vertexShader;
  var fragmentShader = shader.fragmentShader;
  var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
  }

  var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
  var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
  var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

  if (parameters.envMap) {
    switch (material.envMap.mapping) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        break;

      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
        break;

      case EquirectangularReflectionMapping:
      case EquirectangularRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
        break;

      case SphericalReflectionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
        break;
    }

    switch (material.envMap.mapping) {
      case CubeRefractionMapping:
      case EquirectangularRefractionMapping:
        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
        break;
    }

    switch (material.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        break;

      case MixOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
        break;

      case AddOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
        break;
    }
  }

  var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0; // console.log( 'building new program ' );
  //

  var customExtensions = capabilities.isWebGL2 ? '' : generateExtensions(material.extensions, parameters, extensions);
  var customDefines = generateDefines(defines); //

  var program = gl.createProgram();
  var prefixVertex, prefixFragment;

  if (material.isRawShaderMaterial) {
    prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

    if (prefixVertex.length > 0) {
      prefixVertex += '\n';
    }

    prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');

    if (prefixFragment.length > 0) {
      prefixFragment += '\n';
    }
  } else {
    prefixVertex = ['precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', parameters.precision === 'highp' ? '#define HIGH_PRECISION' : '', '#define SHADER_NAME ' + shader.name, customDefines, parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get('EXT_frag_depth')) ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
    prefixFragment = [customExtensions, 'precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', parameters.precision === 'highp' ? '#define HIGH_PRECISION' : '', '#define SHADER_NAME ' + shader.name, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer
    '#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get('EXT_frag_depth')) ? '#define USE_LOGDEPTHBUF_EXT' : '', ((material.extensions ? material.extensions.shaderTextureLOD : false) || parameters.envMap) && (capabilities.isWebGL2 || extensions.get('EXT_shader_texture_lod')) ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
    parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? ShaderChunk['encodings_pars_fragment'] : '', // this code is required here because it is used by the various encoding/decoding function defined below
    parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcapEncoding ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.outputEncoding ? getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding) : '', parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
  }

  vertexShader = parseIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = parseIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);

  if (capabilities.isWebGL2 && !material.isRawShaderMaterial) {
    var isGLSL3ShaderMaterial = false;
    var versionRegex = /^\s*#version\s+300\s+es\s*\n/;

    if (material.isShaderMaterial && vertexShader.match(versionRegex) !== null && fragmentShader.match(versionRegex) !== null) {
      isGLSL3ShaderMaterial = true;
      vertexShader = vertexShader.replace(versionRegex, '');
      fragmentShader = fragmentShader.replace(versionRegex, '');
    } // GLSL 3.0 conversion


    prefixVertex = ['#version 300 es\n', '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
    prefixFragment = ['#version 300 es\n', '#define varying in', isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;', isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
  }

  var vertexGlsl = prefixVertex + vertexShader;
  var fragmentGlsl = prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );
  // console.log( '*FRAGMENT*', fragmentGlsl );

  var glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  var glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.

  if (material.index0AttributeName !== undefined) {
    gl.bindAttribLocation(program, 0, material.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    // programs with morphTargets displace position out of attribute 0
    gl.bindAttribLocation(program, 0, 'position');
  }

  gl.linkProgram(program); // check for link errors

  if (renderer.debug.checkShaderErrors) {
    var programLog = gl.getProgramInfoLog(program).trim();
    var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    var runnable = true;
    var haveDiagnostics = true;

    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      var vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
      var fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
      console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
    } else if (programLog !== '') {
      console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
    } else if (vertexLog === '' || fragmentLog === '') {
      haveDiagnostics = false;
    }

    if (haveDiagnostics) {
      this.diagnostics = {
        runnable: runnable,
        material: material,
        programLog: programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  } // clean up


  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader); // set up caching for uniform locations

  var cachedUniforms;

  this.getUniforms = function () {
    if (cachedUniforms === undefined) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }

    return cachedUniforms;
  }; // set up caching for attribute locations


  var cachedAttributes;

  this.getAttributes = function () {
    if (cachedAttributes === undefined) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }

    return cachedAttributes;
  }; // free resource


  this.destroy = function () {
    gl.deleteProgram(program);
    this.program = undefined;
  }; //


  this.name = shader.name;
  this.id = programIdCount++;
  this.code = code;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLPrograms(renderer, extensions, capabilities) {
  var programs = [];
  var shaderIDs = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'phong',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite'
  };
  var parameterNames = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights', "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];

  function allocateBones(object) {
    var skeleton = object.skeleton;
    var bones = skeleton.bones;

    if (capabilities.floatVertexTextures) {
      return 1024;
    } else {
      // default for when object is not specified
      // ( for example when prebuilding shader to be used with multiple objects )
      //
      //  - leave some extra space for other uniforms
      //  - limit here is ANGLE's 254 max uniform vectors
      //    (up to 54 should be safe)
      var nVertexUniforms = capabilities.maxVertexUniforms;
      var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      var maxBones = Math.min(nVertexMatrices, bones.length);

      if (maxBones < bones.length) {
        console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
        return 0;
      }

      return maxBones;
    }
  }

  function getTextureEncodingFromMap(map, gammaOverrideLinear) {
    var encoding;

    if (!map) {
      encoding = LinearEncoding;
    } else if (map.isTexture) {
      encoding = map.encoding;
    } else if (map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    } // add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.


    if (encoding === LinearEncoding && gammaOverrideLinear) {
      encoding = GammaEncoding;
    }

    return encoding;
  }

  this.getParameters = function (material, lights, shadows, fog, nClipPlanes, nClipIntersection, object) {
    var shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene
    // (not to blow over maxLights budget)

    var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
    var precision = capabilities.precision;

    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);

      if (precision !== material.precision) {
        console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
      }
    }

    var currentRenderTarget = renderer.getRenderTarget();
    var parameters = {
      shaderID: shaderID,
      precision: precision,
      supportsVertexTextures: capabilities.vertexTextures,
      outputEncoding: getTextureEncodingFromMap(!currentRenderTarget ? null : currentRenderTarget.texture, renderer.gammaOutput),
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap, renderer.gammaInput),
      envMap: !!material.envMap,
      envMapMode: material.envMap && material.envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
      envMapCubeUV: !!material.envMap && (material.envMap.mapping === CubeUVReflectionMapping || material.envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      clearcoatNormalMap: !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      sheen: !!material.sheen,
      combine: material.combine,
      vertexTangents: material.normalMap && material.vertexTangents,
      vertexColors: material.vertexColors,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
      skinning: material.skinning && maxBones > 0,
      maxBones: maxBones,
      useVertexTexture: capabilities.floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: renderer.maxMorphTargets,
      maxMorphNormals: renderer.maxMorphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: nClipPlanes,
      numClipIntersection: nClipIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== undefined ? material.depthPacking : false
    };
    return parameters;
  };

  this.getProgramCode = function (material, parameters) {
    var array = [];

    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(material.fragmentShader);
      array.push(material.vertexShader);
    }

    if (material.defines !== undefined) {
      for (var name in material.defines) {
        array.push(name);
        array.push(material.defines[name]);
      }
    }

    for (var i = 0; i < parameterNames.length; i++) {
      array.push(parameters[parameterNames[i]]);
    }

    array.push(material.onBeforeCompile.toString());
    array.push(renderer.gammaOutput);
    array.push(renderer.gammaFactor);
    return array.join();
  };

  this.acquireProgram = function (material, shader, parameters, code) {
    var program; // Check if code has been already compiled

    for (var p = 0, pl = programs.length; p < pl; p++) {
      var programInfo = programs[p];

      if (programInfo.code === code) {
        program = programInfo;
        ++program.usedTimes;
        break;
      }
    }

    if (program === undefined) {
      program = new WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities);
      programs.push(program);
    }

    return program;
  };

  this.releaseProgram = function (program) {
    if (--program.usedTimes === 0) {
      // Remove from unordered set
      var i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop(); // Free WebGL resources

      program.destroy();
    }
  }; // Exposed for resource monitoring & error feedback via renderer.info:


  this.programs = programs;
}
/**
 * @author fordacious / fordacious.github.io
 */


function WebGLProperties() {
  var properties = new WeakMap();

  function get(object) {
    var map = properties.get(object);

    if (map === undefined) {
      map = {};
      properties.set(object, map);
    }

    return map;
  }

  function remove(object) {
    properties.delete(object);
  }

  function update(object, key, value) {
    properties.get(object)[key] = value;
  }

  function dispose() {
    properties = new WeakMap();
  }

  return {
    get: get,
    remove: remove,
    update: update,
    dispose: dispose
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.program !== b.program) {
    return a.program.id - b.program.id;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}

function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}

function WebGLRenderList() {
  var renderItems = [];
  var renderItemsIndex = 0;
  var opaque = [];
  var transparent = [];
  var defaultProgram = {
    id: -1
  };

  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transparent.length = 0;
  }

  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    var renderItem = renderItems[renderItemsIndex];

    if (renderItem === undefined) {
      renderItem = {
        id: object.id,
        object: object,
        geometry: geometry,
        material: material,
        program: material.program || defaultProgram,
        groupOrder: groupOrder,
        renderOrder: object.renderOrder,
        z: z,
        group: group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = material.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }

    renderItemsIndex++;
    return renderItem;
  }

  function push(object, geometry, material, groupOrder, z, group) {
    var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).push(renderItem);
  }

  function unshift(object, geometry, material, groupOrder, z, group) {
    var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).unshift(renderItem);
  }

  function sort() {
    if (opaque.length > 1) opaque.sort(painterSortStable);
    if (transparent.length > 1) transparent.sort(reversePainterSortStable);
  }

  return {
    opaque: opaque,
    transparent: transparent,
    init: init,
    push: push,
    unshift: unshift,
    sort: sort
  };
}

function WebGLRenderLists() {
  var lists = new WeakMap();

  function onSceneDispose(event) {
    var scene = event.target;
    scene.removeEventListener('dispose', onSceneDispose);
    lists.delete(scene);
  }

  function get(scene, camera) {
    var cameras = lists.get(scene);
    var list;

    if (cameras === undefined) {
      list = new WebGLRenderList();
      lists.set(scene, new WeakMap());
      lists.get(scene).set(camera, list);
      scene.addEventListener('dispose', onSceneDispose);
    } else {
      list = cameras.get(camera);

      if (list === undefined) {
        list = new WebGLRenderList();
        cameras.set(camera, list);
      }
    }

    return list;
  }

  function dispose() {
    lists = new WeakMap();
  }

  return {
    get: get,
    dispose: dispose
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function UniformsCache() {
  var lights = {};
  return {
    get: function (light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }

      var uniforms;

      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            direction: new Vector3(),
            color: new Color(),
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;

        case 'SpotLight':
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;

        case 'PointLight':
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0,
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1000
          };
          break;

        case 'HemisphereLight':
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;

        case 'RectAreaLight':
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3() // TODO (abelnation): set RectAreaLight shadow uniforms

          };
          break;
      }

      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}

var nextVersion = 0;

function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}

function WebGLLights() {
  var cache = new UniformsCache();
  var state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    point: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numDirectionalShadows: -1,
    numPointShadows: -1,
    numSpotShadows: -1
  };

  for (var i = 0; i < 9; i++) state.probe.push(new Vector3());

  var vector3 = new Vector3();
  var matrix4 = new Matrix4();
  var matrix42 = new Matrix4();

  function setup(lights, shadows, camera) {
    var r = 0,
        g = 0,
        b = 0;

    for (var i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);

    var directionalLength = 0;
    var pointLength = 0;
    var spotLength = 0;
    var rectAreaLength = 0;
    var hemiLength = 0;
    var numDirectionalShadows = 0;
    var numPointShadows = 0;
    var numSpotShadows = 0;
    var viewMatrix = camera.matrixWorldInverse;
    lights.sort(shadowCastingLightsFirst);

    for (var i = 0, l = lights.length; i < l; i++) {
      var light = lights[i];
      var color = light.color;
      var intensity = light.intensity;
      var distance = light.distance;
      var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

      if (light.isAmbientLight) {
        r += color.r * intensity;
        g += color.g * intensity;
        b += color.b * intensity;
      } else if (light.isLightProbe) {
        for (var j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
      } else if (light.isDirectionalLight) {
        var uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.shadow = light.castShadow;

        if (light.castShadow) {
          var shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }

        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        var uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        uniforms.shadow = light.castShadow;

        if (light.castShadow) {
          var shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }

        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        var uniforms = cache.get(light); // (a) intensity is the total visible light emitted
        //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
        // (b) intensity is the brightness of the light

        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors

        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42); // TODO (abelnation): RectAreaLight distance?
        // uniforms.distance = distance;

        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        var uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        uniforms.shadow = light.castShadow;

        if (light.castShadow) {
          var shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
          uniforms.shadowCameraNear = shadow.camera.near;
          uniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }

        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        var uniforms = cache.get(light);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }

    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    var hash = state.hash;

    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }

  return {
    setup: setup,
    state: state
  };
}
/**
 * @author Mugen87 / https://github.com/Mugen87
 */


function WebGLRenderState() {
  var lights = new WebGLLights();
  var lightsArray = [];
  var shadowsArray = [];

  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }

  function pushLight(light) {
    lightsArray.push(light);
  }

  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }

  function setupLights(camera) {
    lights.setup(lightsArray, shadowsArray, camera);
  }

  var state = {
    lightsArray: lightsArray,
    shadowsArray: shadowsArray,
    lights: lights
  };
  return {
    init: init,
    state: state,
    setupLights: setupLights,
    pushLight: pushLight,
    pushShadow: pushShadow
  };
}

function WebGLRenderStates() {
  var renderStates = new WeakMap();

  function onSceneDispose(event) {
    var scene = event.target;
    scene.removeEventListener('dispose', onSceneDispose);
    renderStates.delete(scene);
  }

  function get(scene, camera) {
    var renderState;

    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState();
      renderStates.set(scene, new WeakMap());
      renderStates.get(scene).set(camera, renderState);
      scene.addEventListener('dispose', onSceneDispose);
    } else {
      if (renderStates.get(scene).has(camera) === false) {
        renderState = new WebGLRenderState();
        renderStates.get(scene).set(camera, renderState);
      } else {
        renderState = renderStates.get(scene).get(camera);
      }
    }

    return renderState;
  }

  function dispose() {
    renderStates = new WeakMap();
  }

  return {
    get: get,
    dispose: dispose
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / https://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */


function MeshDepthMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshDepthMaterial';
  this.depthPacking = BasicDepthPacking;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.setValues(parameters);
}

MeshDepthMaterial.prototype = Object.create(Material.prototype);
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

MeshDepthMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.depthPacking = source.depthPacking;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  return this;
};
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */


function MeshDistanceMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshDistanceMaterial';
  this.referencePosition = new Vector3();
  this.nearDistance = 1;
  this.farDistance = 1000;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.fog = false;
  this.lights = false;
  this.setValues(parameters);
}

MeshDistanceMaterial.prototype = Object.create(Material.prototype);
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

MeshDistanceMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.referencePosition.copy(source.referencePosition);
  this.nearDistance = source.nearDistance;
  this.farDistance = source.farDistance;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  return this;
};

var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n  \n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = decodeHalfRGBA ( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = pow( squared_mean - mean * mean, 0.5 );\n  gl_FragColor = encodeHalfRGBA( vec2( mean, std_dev ) );\n}";
var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
  var _frustum = new Frustum(),
      _shadowMapSize = new Vector2(),
      _viewportSize = new Vector2(),
      _viewport = new Vector4(),
      _MorphingFlag = 1,
      _SkinningFlag = 2,
      _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1,
      _depthMaterials = new Array(_NumberOfMaterialVariants),
      _distanceMaterials = new Array(_NumberOfMaterialVariants),
      _materialCache = {};

  var shadowSide = {
    0: BackSide,
    1: FrontSide,
    2: DoubleSide
  };
  var shadowMaterialVertical = new ShaderMaterial({
    defines: {
      SAMPLE_RATE: 2.0 / 8.0,
      HALF_SAMPLE_RATE: 1.0 / 8.0
    },
    uniforms: {
      shadow_pass: {
        value: null
      },
      resolution: {
        value: new Vector2()
      },
      radius: {
        value: 4.0
      }
    },
    vertexShader: vsm_vert,
    fragmentShader: vsm_frag
  });
  var shadowMaterialHorizonal = shadowMaterialVertical.clone();
  shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;
  var fullScreenTri = new BufferGeometry();
  fullScreenTri.addAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  var fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical); // init

  for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {
    var useMorphing = (i & _MorphingFlag) !== 0;
    var useSkinning = (i & _SkinningFlag) !== 0;
    var depthMaterial = new MeshDepthMaterial({
      depthPacking: RGBADepthPacking,
      morphTargets: useMorphing,
      skinning: useSkinning
    });
    _depthMaterials[i] = depthMaterial;
    var distanceMaterial = new MeshDistanceMaterial({
      morphTargets: useMorphing,
      skinning: useSkinning
    });
    _distanceMaterials[i] = distanceMaterial;
  }

  var scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;

  this.render = function (lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;

    var currentRenderTarget = _renderer.getRenderTarget();

    var activeCubeFace = _renderer.getActiveCubeFace();

    var activeMipmapLevel = _renderer.getActiveMipmapLevel();

    var _state = _renderer.state; // Set GL state for depth map.

    _state.setBlending(NoBlending);

    _state.buffers.color.setClear(1, 1, 1, 1);

    _state.buffers.depth.setTest(true);

    _state.setScissorTest(false); // render depth map


    for (var i = 0, il = lights.length; i < il; i++) {
      var light = lights[i];
      var shadow = light.shadow;

      if (shadow === undefined) {
        console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
        continue;
      }

      _shadowMapSize.copy(shadow.mapSize);

      var shadowFrameExtents = shadow.getFrameExtents();

      _shadowMapSize.multiply(shadowFrameExtents);

      _viewportSize.copy(shadow.mapSize);

      if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
        console.warn('THREE.WebGLShadowMap:', light, 'has shadow exceeding max texture size, reducing');

        if (_shadowMapSize.x > maxTextureSize) {
          _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }

        if (_shadowMapSize.y > maxTextureSize) {
          _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }

      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        var pars = {
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          format: RGBAFormat
        };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }

      if (shadow.map === null) {
        var pars = {
          minFilter: NearestFilter,
          magFilter: NearestFilter,
          format: RGBAFormat
        };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }

      _renderer.setRenderTarget(shadow.map);

      _renderer.clear();

      var viewportCount = shadow.getViewportCount();

      for (var vp = 0; vp < viewportCount; vp++) {
        var viewport = shadow.getViewport(vp);

        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);

        _state.viewport(_viewport);

        shadow.updateMatrices(light, camera, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      } // do blur pass for VSM


      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
    }

    scope.needsUpdate = false;

    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };

  function VSMPass(shadow, camera) {
    var geometry = _objects.update(fullScreenMesh); // vertical pass


    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;

    _renderer.setRenderTarget(shadow.mapPass);

    _renderer.clear();

    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizonal pass


    shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;

    _renderer.setRenderTarget(shadow.map);

    _renderer.clear();

    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null);
  }

  function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {
    var geometry = object.geometry;
    var result = null;
    var materialVariants = _depthMaterials;
    var customMaterial = object.customDepthMaterial;

    if (light.isPointLight) {
      materialVariants = _distanceMaterials;
      customMaterial = object.customDistanceMaterial;
    }

    if (!customMaterial) {
      var useMorphing = false;

      if (material.morphTargets) {
        if (geometry && geometry.isBufferGeometry) {
          useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
        } else if (geometry && geometry.isGeometry) {
          useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
        }
      }

      if (object.isSkinnedMesh && material.skinning === false) {
        console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
      }

      var useSkinning = object.isSkinnedMesh && material.skinning;
      var variantIndex = 0;
      if (useMorphing) variantIndex |= _MorphingFlag;
      if (useSkinning) variantIndex |= _SkinningFlag;
      result = materialVariants[variantIndex];
    } else {
      result = customMaterial;
    }

    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      // in this case we need a unique material instance reflecting the
      // appropriate state
      var keyA = result.uuid,
          keyB = material.uuid;
      var materialsForVariant = _materialCache[keyA];

      if (materialsForVariant === undefined) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }

      var cachedMaterial = materialsForVariant[keyB];

      if (cachedMaterial === undefined) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }

      result = cachedMaterial;
    }

    result.visible = material.visible;
    result.wireframe = material.wireframe;

    if (type === VSMShadowMap) {
      result.side = material.shadowSide != null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide != null ? material.shadowSide : shadowSide[material.side];
    }

    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;

    if (light.isPointLight && result.isMeshDistanceMaterial) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }

    return result;
  }

  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false) return;
    var visible = object.layers.test(camera.layers);

    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

        var geometry = _objects.update(object);

        var material = object.material;

        if (Array.isArray(material)) {
          var groups = geometry.groups;

          for (var k = 0, kl = groups.length; k < kl; k++) {
            var group = groups[k];
            var groupMaterial = material[group.materialIndex];

            if (groupMaterial && groupMaterial.visible) {
              var depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);

              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          var depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);

          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }

    var children = object.children;

    for (var i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera, shadowCamera, light, type);
    }
  }
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLState(gl, extensions, utils, capabilities) {
  function ColorBuffer() {
    var locked = false;
    var color = new Vector4();
    var currentColorMask = null;
    var currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function (colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }

        color.set(r, g, b, a);

        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function () {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0); // set to invalid state
      }
    };
  }

  function DepthBuffer() {
    var locked = false;
    var currentDepthMask = null;
    var currentDepthFunc = null;
    var currentDepthClear = null;
    return {
      setTest: function (depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function (depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function (depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;

              case AlwaysDepth:
                gl.depthFunc(519);
                break;

              case LessDepth:
                gl.depthFunc(513);
                break;

              case LessEqualDepth:
                gl.depthFunc(515);
                break;

              case EqualDepth:
                gl.depthFunc(514);
                break;

              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;

              case GreaterDepth:
                gl.depthFunc(516);
                break;

              case NotEqualDepth:
                gl.depthFunc(517);
                break;

              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }

          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function () {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }

  function StencilBuffer() {
    var locked = false;
    var currentStencilMask = null;
    var currentStencilFunc = null;
    var currentStencilRef = null;
    var currentStencilFuncMask = null;
    var currentStencilFail = null;
    var currentStencilZFail = null;
    var currentStencilZPass = null;
    var currentStencilClear = null;
    return {
      setTest: function (stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function (stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function (stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function (stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function () {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  } //


  var colorBuffer = new ColorBuffer();
  var depthBuffer = new DepthBuffer();
  var stencilBuffer = new StencilBuffer();
  var maxVertexAttributes = gl.getParameter(34921);
  var newAttributes = new Uint8Array(maxVertexAttributes);
  var enabledAttributes = new Uint8Array(maxVertexAttributes);
  var attributeDivisors = new Uint8Array(maxVertexAttributes);
  var enabledCapabilities = {};
  var compressedTextureFormats = null;
  var currentProgram = null;
  var currentBlendingEnabled = null;
  var currentBlending = null;
  var currentBlendEquation = null;
  var currentBlendSrc = null;
  var currentBlendDst = null;
  var currentBlendEquationAlpha = null;
  var currentBlendSrcAlpha = null;
  var currentBlendDstAlpha = null;
  var currentPremultipledAlpha = false;
  var currentFlipSided = null;
  var currentCullFace = null;
  var currentLineWidth = null;
  var currentPolygonOffsetFactor = null;
  var currentPolygonOffsetUnits = null;
  var maxTextures = gl.getParameter(35661);
  var lineWidthAvailable = false;
  var version = 0;
  var glVersion = gl.getParameter(7938);

  if (glVersion.indexOf('WebGL') !== -1) {
    version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1.0;
  } else if (glVersion.indexOf('OpenGL ES') !== -1) {
    version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2.0;
  }

  var currentTextureSlot = null;
  var currentBoundTextures = {};
  var currentScissor = new Vector4();
  var currentViewport = new Vector4();

  function createTexture(type, target, count) {
    var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.

    var texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);

    for (var i = 0; i < count; i++) {
      gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }

    return texture;
  }

  var emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6); // init

  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending); //

  function initAttributes() {
    for (var i = 0, l = newAttributes.length; i < l; i++) {
      newAttributes[i] = 0;
    }
  }

  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }

  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    newAttributes[attribute] = 1;

    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }

    if (attributeDivisors[attribute] !== meshPerAttribute) {
      var extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
      extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }

  function disableUnusedAttributes() {
    for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }

  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }

  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }

  function getCompressedTextureFormats() {
    if (compressedTextureFormats === null) {
      compressedTextureFormats = [];

      if (extensions.get('WEBGL_compressed_texture_pvrtc') || extensions.get('WEBGL_compressed_texture_s3tc') || extensions.get('WEBGL_compressed_texture_etc1') || extensions.get('WEBGL_compressed_texture_astc')) {
        var formats = gl.getParameter(34467);

        for (var i = 0; i < formats.length; i++) {
          compressedTextureFormats.push(formats[i]);
        }
      }
    }

    return compressedTextureFormats;
  }

  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }

    return false;
  }

  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled) {
        disable(3042);
        currentBlendingEnabled = false;
      }

      return;
    }

    if (!currentBlendingEnabled) {
      enable(3042);
      currentBlendingEnabled = true;
    }

    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }

        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;

            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;

            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 0, 769, 771);
              break;

            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;

            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;

            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;

            case SubtractiveBlending:
              gl.blendFunc(0, 769);
              break;

            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;

            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        }

        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }

      return;
    } // custom blending


    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;

    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(utils.convert(blendEquation), utils.convert(blendEquationAlpha));
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }

    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(utils.convert(blendSrc), utils.convert(blendDst), utils.convert(blendSrcAlpha), utils.convert(blendDstAlpha));
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }

    currentBlending = blending;
    currentPremultipledAlpha = null;
  }

  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    var flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    var stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);

    if (stencilWrite) {
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }

    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
  } //


  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }

      currentFlipSided = flipSided;
    }
  }

  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);

      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }

    currentCullFace = cullFace;
  }

  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }

  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);

      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }

  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  } // texture


  function activeTexture(webglSlot) {
    if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;

    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }

  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }

    var boundTexture = currentBoundTextures[currentTextureSlot];

    if (boundTexture === undefined) {
      boundTexture = {
        type: undefined,
        texture: undefined
      };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }

    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }

  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  } //


  function scissor(scissor) {
    if (currentScissor.equals(scissor) === false) {
      gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
      currentScissor.copy(scissor);
    }
  }

  function viewport(viewport) {
    if (currentViewport.equals(viewport) === false) {
      gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
      currentViewport.copy(viewport);
    }
  } //


  function reset() {
    for (var i = 0; i < enabledAttributes.length; i++) {
      if (enabledAttributes[i] === 1) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }

    enabledCapabilities = {};
    compressedTextureFormats = null;
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentProgram = null;
    currentBlending = null;
    currentFlipSided = null;
    currentCullFace = null;
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }

  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    initAttributes: initAttributes,
    enableAttribute: enableAttribute,
    enableAttributeAndDivisor: enableAttributeAndDivisor,
    disableUnusedAttributes: disableUnusedAttributes,
    enable: enable,
    disable: disable,
    getCompressedTextureFormats: getCompressedTextureFormats,
    useProgram: useProgram,
    setBlending: setBlending,
    setMaterial: setMaterial,
    setFlipSided: setFlipSided,
    setCullFace: setCullFace,
    setLineWidth: setLineWidth,
    setPolygonOffset: setPolygonOffset,
    setScissorTest: setScissorTest,
    activeTexture: activeTexture,
    bindTexture: bindTexture,
    compressedTexImage2D: compressedTexImage2D,
    texImage2D: texImage2D,
    texImage3D: texImage3D,
    scissor: scissor,
    viewport: viewport,
    reset: reset
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  var _videoTextures = new WeakMap();

  var _canvas; //


  var useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';

  function createCanvas(width, height) {
    // Use OffscreenCanvas when available. Specially needed in web workers
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
  }

  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    var scale = 1; // handle case if texture exceeds max size

    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    } // only perform resize if necessary


    if (scale < 1 || needsPowerOfTwo === true) {
      // only perform resize for certain image types
      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
        var floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor;
        var width = floor(scale * image.width);
        var height = floor(scale * image.height);
        if (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas

        var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, width, height);
        console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
        return canvas;
      } else {
        if ('data' in image) {
          console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
        }

        return image;
      }
    }

    return image;
  }

  function isPowerOfTwo(image) {
    return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
  }

  function textureNeedsPowerOfTwo(texture) {
    if (capabilities.isWebGL2) return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }

  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }

  function generateMipmap(target, texture, width, height) {
    _gl.generateMipmap(target);

    var textureProperties = properties.get(texture); // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11

    textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
  }

  function getInternalFormat(glFormat, glType) {
    if (!capabilities.isWebGL2) return glFormat;
    var internalFormat = glFormat;

    if (glFormat === 6403) {
      if (glType === 5126) internalFormat = 33326;
      if (glType === 5131) internalFormat = 33325;
      if (glType === 5121) internalFormat = 33321;
    }

    if (glFormat === 6407) {
      if (glType === 5126) internalFormat = 34837;
      if (glType === 5131) internalFormat = 34843;
      if (glType === 5121) internalFormat = 32849;
    }

    if (glFormat === 6408) {
      if (glType === 5126) internalFormat = 34836;
      if (glType === 5131) internalFormat = 34842;
      if (glType === 5121) internalFormat = 32856;
    }

    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get('EXT_color_buffer_float');
    } else if (internalFormat === 34843 || internalFormat === 34837) {
      console.warn('THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.');
    }

    return internalFormat;
  } // Fallback filters for non-power-of-2 textures


  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
      return 9728;
    }

    return 9729;
  } //


  function onTextureDispose(event) {
    var texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    deallocateTexture(texture);

    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }

    info.memory.textures--;
  }

  function onRenderTargetDispose(event) {
    var renderTarget = event.target;
    renderTarget.removeEventListener('dispose', onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    info.memory.textures--;
  } //


  function deallocateTexture(texture) {
    var textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === undefined) return;

    _gl.deleteTexture(textureProperties.__webglTexture);

    properties.remove(texture);
  }

  function deallocateRenderTarget(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(renderTarget.texture);
    if (!renderTarget) return;

    if (textureProperties.__webglTexture !== undefined) {
      _gl.deleteTexture(textureProperties.__webglTexture);
    }

    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }

    if (renderTarget.isWebGLRenderTargetCube) {
      for (var i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);

        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);

      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
    }

    properties.remove(renderTarget.texture);
    properties.remove(renderTarget);
  } //


  var textureUnits = 0;

  function resetTextureUnits() {
    textureUnits = 0;
  }

  function allocateTextureUnit() {
    var textureUnit = textureUnits;

    if (textureUnit >= capabilities.maxTextures) {
      console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);
    }

    textureUnits += 1;
    return textureUnit;
  } //


  function setTexture2D(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      var image = texture.image;

      if (image === undefined) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
      } else if (image.complete === false) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }

  function setTexture2DArray(texture, slot) {
    var textureProperties = properties.get(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }

  function setTexture3D(texture, slot) {
    var textureProperties = properties.get(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }

  function setTextureCube(texture, slot) {
    if (texture.image.length !== 6) return;
    var textureProperties = properties.get(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      initTexture(textureProperties, texture);
      state.activeTexture(33984 + slot);
      state.bindTexture(34067, textureProperties.__webglTexture);

      _gl.pixelStorei(37440, texture.flipY);

      var isCompressed = texture && texture.isCompressedTexture;
      var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      var cubeImage = [];

      for (var i = 0; i < 6; i++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i] = resizeImage(texture.image[i], false, true, capabilities.maxCubemapSize);
        } else {
          cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
        }
      }

      var image = cubeImage[0],
          supportsMips = isPowerOfTwo(image) || capabilities.isWebGL2,
          glFormat = utils.convert(texture.format),
          glType = utils.convert(texture.type),
          glInternalFormat = getInternalFormat(glFormat, glType);
      setTextureParameters(34067, texture, supportsMips);
      var mipmaps;

      if (isCompressed) {
        for (var i = 0; i < 6; i++) {
          mipmaps = cubeImage[i].mipmaps;

          for (var j = 0; j < mipmaps.length; j++) {
            var mipmap = mipmaps[j];

            if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
              if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              } else {
                console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
              }
            } else {
              state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        }

        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        mipmaps = texture.mipmaps;

        for (var i = 0; i < 6; i++) {
          if (isDataTexture) {
            state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);

            for (var j = 0; j < mipmaps.length; j++) {
              var mipmap = mipmaps[j];
              var mipmapImage = mipmap.image[i].image;
              state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
            }
          } else {
            state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);

            for (var j = 0; j < mipmaps.length; j++) {
              var mipmap = mipmaps[j];
              state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
            }
          }
        }

        textureProperties.__maxMipLevel = mipmaps.length;
      }

      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        // We assume images for cube map have the same size.
        generateMipmap(34067, texture, image.width, image.height);
      }

      textureProperties.__version = texture.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    } else {
      state.activeTexture(33984 + slot);
      state.bindTexture(34067, textureProperties.__webglTexture);
    }
  }

  function setTextureCubeDynamic(texture, slot) {
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, properties.get(texture).__webglTexture);
  }

  function setTextureParameters(textureType, texture, supportsMips) {
    var extension;

    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, utils.convert(texture.wrapS));

      _gl.texParameteri(textureType, 10243, utils.convert(texture.wrapT));

      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, utils.convert(texture.wrapR));
      }

      _gl.texParameteri(textureType, 10240, utils.convert(texture.magFilter));

      _gl.texParameteri(textureType, 10241, utils.convert(texture.minFilter));
    } else {
      _gl.texParameteri(textureType, 10242, 33071);

      _gl.texParameteri(textureType, 10243, 33071);

      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }

      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
      }

      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));

      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));

      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
      }
    }

    extension = extensions.get('EXT_texture_filter_anisotropic');

    if (extension) {
      if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
      if (texture.type === HalfFloatType && (capabilities.isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null) return;

      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));

        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }

  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === undefined) {
      textureProperties.__webglInit = true;
      texture.addEventListener('dispose', onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }

  function uploadTexture(textureProperties, texture, slot) {
    var textureType = 3553;
    if (texture.isDataTexture2DArray) textureType = 35866;
    if (texture.isDataTexture3D) textureType = 32879;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);

    _gl.pixelStorei(37440, texture.flipY);

    _gl.pixelStorei(37441, texture.premultiplyAlpha);

    _gl.pixelStorei(3317, texture.unpackAlignment);

    var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
    var image = resizeImage(texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize);
    var supportsMips = isPowerOfTwo(image) || capabilities.isWebGL2,
        glFormat = utils.convert(texture.format),
        glType = utils.convert(texture.type),
        glInternalFormat = getInternalFormat(glFormat, glType);
    setTextureParameters(textureType, texture, supportsMips);
    var mipmap,
        mipmaps = texture.mipmaps;

    if (texture.isDepthTexture) {
      // populate depth texture with dummy data
      glInternalFormat = 6402;

      if (texture.type === FloatType) {
        if (!capabilities.isWebGL2) throw new Error('Float Depth Texture only supported in WebGL2.0');
        glInternalFormat = 36012;
      } else if (capabilities.isWebGL2) {
        // WebGL 2.0 requires signed internalformat for glTexImage2D
        glInternalFormat = 33189;
      }

      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
        // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
          texture.type = UnsignedShortType;
          glType = utils.convert(texture.type);
        }
      } // Depth stencil textures need the DEPTH_STENCIL internal format
      // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)


      if (texture.format === DepthStencilFormat) {
        glInternalFormat = 34041; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
        // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)

        if (texture.type !== UnsignedInt248Type) {
          console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
          texture.type = UnsignedInt248Type;
          glType = utils.convert(texture.type);
        }
      }

      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels
      if (mipmaps.length > 0 && supportsMips) {
        for (var i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }

        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (var i = 0, il = mipmaps.length; i < il; i++) {
        mipmap = mipmaps[i];

        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
            state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
          }
        } else {
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }

      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      // regular Texture (image, video, canvas)
      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels
      if (mipmaps.length > 0 && supportsMips) {
        for (var i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
        }

        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
        textureProperties.__maxMipLevel = 0;
      }
    }

    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(3553, texture, image.width, image.height);
    }

    textureProperties.__version = texture.version;
    if (texture.onUpdate) texture.onUpdate(texture);
  } // Render targets
  // Setup storage for target texture and bind it to correct framebuffer


  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    var glFormat = utils.convert(renderTarget.texture.format);
    var glType = utils.convert(renderTarget.texture.type);
    var glInternalFormat = getInternalFormat(glFormat, glType);
    state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);

    _gl.bindFramebuffer(36160, framebuffer);

    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);

    _gl.bindFramebuffer(36160, null);
  } // Setup storage for internal depth/stencil buffers and bind to correct framebuffer


  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);

    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      if (isMultisample) {
        var samples = getRenderTargetSamples(renderTarget);

        _gl.renderbufferStorageMultisample(36161, samples, 33189, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 33189, renderTarget.width, renderTarget.height);
      }

      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        var samples = getRenderTargetSamples(renderTarget);

        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }

      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      var glFormat = utils.convert(renderTarget.texture.format);
      var glType = utils.convert(renderTarget.texture.type);
      var glInternalFormat = getInternalFormat(glFormat, glType);

      if (isMultisample) {
        var samples = getRenderTargetSamples(renderTarget);

        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }

    _gl.bindRenderbuffer(36161, null);
  } // Setup resources for a Depth Texture for a FBO (needs an extension)


  function setupDepthTexture(framebuffer, renderTarget) {
    var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
    if (isCube) throw new Error('Depth Texture with cube render targets is not supported');

    _gl.bindFramebuffer(36160, framebuffer);

    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
    } // upload an empty depth texture with framebuffer size


    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }

    setTexture2D(renderTarget.depthTexture, 0);

    var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
    } else {
      throw new Error('Unknown depthTexture format');
    }
  } // Setup GL resources for a non-texture depth buffer


  function setupDepthRenderbuffer(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var isCube = renderTarget.isWebGLRenderTargetCube === true;

    if (renderTarget.depthTexture) {
      if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];

        for (var i = 0; i < 6; i++) {
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);

          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
        }
      } else {
        _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);

        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
      }
    }

    _gl.bindFramebuffer(36160, null);
  } // Set up GL resources for the render target


  function setupRenderTarget(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(renderTarget.texture);
    renderTarget.addEventListener('dispose', onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    info.memory.textures++;
    var isCube = renderTarget.isWebGLRenderTargetCube === true;
    var isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    var supportsMips = isPowerOfTwo(renderTarget) || capabilities.isWebGL2; // Setup framebuffer

    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];

      for (var i = 0; i < 6; i++) {
        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

      if (isMultisample) {
        if (capabilities.isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);

          var glFormat = utils.convert(renderTarget.texture.format);
          var glType = utils.convert(renderTarget.texture.type);
          var glInternalFormat = getInternalFormat(glFormat, glType);
          var samples = getRenderTargetSamples(renderTarget);

          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);

          _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);

          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);

          _gl.bindRenderbuffer(36161, null);

          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }

          _gl.bindFramebuffer(36160, null);
        } else {
          console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
        }
      }
    } // Setup color buffer


    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, renderTarget.texture, supportsMips);

      for (var i = 0; i < 6; i++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);
      }

      if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
        generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
      }

      state.bindTexture(34067, null);
    } else {
      state.bindTexture(3553, textureProperties.__webglTexture);
      setTextureParameters(3553, renderTarget.texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);

      if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
        generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
      }

      state.bindTexture(3553, null);
    } // Setup depth and stencil buffers


    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }

  function updateRenderTargetMipmap(renderTarget) {
    var texture = renderTarget.texture;
    var supportsMips = isPowerOfTwo(renderTarget) || capabilities.isWebGL2;

    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      var target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553;

      var webglTexture = properties.get(texture).__webglTexture;

      state.bindTexture(target, webglTexture);
      generateMipmap(target, texture, renderTarget.width, renderTarget.height);
      state.bindTexture(target, null);
    }
  }

  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (capabilities.isWebGL2) {
        var renderTargetProperties = properties.get(renderTarget);

        _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);

        _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);

        var width = renderTarget.width;
        var height = renderTarget.height;
        var mask = 16384;
        if (renderTarget.depthBuffer) mask |= 256;
        if (renderTarget.stencilBuffer) mask |= 1024;

        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
      } else {
        console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
      }
    }
  }

  function getRenderTargetSamples(renderTarget) {
    return capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(capabilities.maxSamples, renderTarget.samples) : 0;
  }

  function updateVideoTexture(texture) {
    var frame = info.render.frame; // Check the last frame we updated the VideoTexture

    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);

      texture.update();
    }
  } // backwards compatibility


  var warnedTexture2D = false;
  var warnedTextureCube = false;

  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
        warnedTexture2D = true;
      }

      texture = texture.texture;
    }

    setTexture2D(texture, slot);
  }

  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLRenderTargetCube) {
      if (warnedTextureCube === false) {
        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
        warnedTextureCube = true;
      }

      texture = texture.texture;
    } // currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
    // TODO: unify these code paths


    if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
      // CompressedTexture can have Array in image :/
      // this function alone should take care of cube textures
      setTextureCube(texture, slot);
    } else {
      // assumed: texture property of THREE.WebGLRenderTargetCube
      setTextureCubeDynamic(texture, slot);
    }
  } //


  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setTextureCubeDynamic = setTextureCubeDynamic;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}
/**
 * @author thespite / http://www.twitter.com/thespite
 */


function WebGLUtils(gl, extensions, capabilities) {
  function convert(p) {
    var extension;
    if (p === RepeatWrapping) return 10497;
    if (p === ClampToEdgeWrapping) return 33071;
    if (p === MirroredRepeatWrapping) return 33648;
    if (p === NearestFilter) return 9728;
    if (p === NearestMipmapNearestFilter) return 9984;
    if (p === NearestMipmapLinearFilter) return 9986;
    if (p === LinearFilter) return 9729;
    if (p === LinearMipmapNearestFilter) return 9985;
    if (p === LinearMipmapLinearFilter) return 9987;
    if (p === UnsignedByteType) return 5121;
    if (p === UnsignedShort4444Type) return 32819;
    if (p === UnsignedShort5551Type) return 32820;
    if (p === UnsignedShort565Type) return 33635;
    if (p === ByteType) return 5120;
    if (p === ShortType) return 5122;
    if (p === UnsignedShortType) return 5123;
    if (p === IntType) return 5124;
    if (p === UnsignedIntType) return 5125;
    if (p === FloatType) return 5126;

    if (p === HalfFloatType) {
      if (capabilities.isWebGL2) return 5131;
      extension = extensions.get('OES_texture_half_float');
      if (extension !== null) return extension.HALF_FLOAT_OES;
    }

    if (p === AlphaFormat) return 6406;
    if (p === RGBFormat) return 6407;
    if (p === RGBAFormat) return 6408;
    if (p === LuminanceFormat) return 6409;
    if (p === LuminanceAlphaFormat) return 6410;
    if (p === DepthFormat) return 6402;
    if (p === DepthStencilFormat) return 34041;
    if (p === RedFormat) return 6403;
    if (p === AddEquation) return 32774;
    if (p === SubtractEquation) return 32778;
    if (p === ReverseSubtractEquation) return 32779;
    if (p === ZeroFactor) return 0;
    if (p === OneFactor) return 1;
    if (p === SrcColorFactor) return 768;
    if (p === OneMinusSrcColorFactor) return 769;
    if (p === SrcAlphaFactor) return 770;
    if (p === OneMinusSrcAlphaFactor) return 771;
    if (p === DstAlphaFactor) return 772;
    if (p === OneMinusDstAlphaFactor) return 773;
    if (p === DstColorFactor) return 774;
    if (p === OneMinusDstColorFactor) return 775;
    if (p === SrcAlphaSaturateFactor) return 776;

    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get('WEBGL_compressed_texture_s3tc');

      if (extension !== null) {
        if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
    }

    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get('WEBGL_compressed_texture_pvrtc');

      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }
    }

    if (p === RGB_ETC1_Format) {
      extension = extensions.get('WEBGL_compressed_texture_etc1');
      if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
    }

    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
      extension = extensions.get('WEBGL_compressed_texture_astc');

      if (extension !== null) {
        return p;
      }
    }

    if (p === MinEquation || p === MaxEquation) {
      if (capabilities.isWebGL2) {
        if (p === MinEquation) return 32775;
        if (p === MaxEquation) return 32776;
      }

      extension = extensions.get('EXT_blend_minmax');

      if (extension !== null) {
        if (p === MinEquation) return extension.MIN_EXT;
        if (p === MaxEquation) return extension.MAX_EXT;
      }
    }

    if (p === UnsignedInt248Type) {
      if (capabilities.isWebGL2) return 34042;
      extension = extensions.get('WEBGL_depth_texture');
      if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
    }

    return 0;
  }

  return {
    convert: convert
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function Group() {
  Object3D.call(this);
  this.type = 'Group';
}

Group.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Group,
  isGroup: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function ArrayCamera(array) {
  PerspectiveCamera.call(this);
  this.cameras = array || [];
}

ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
  constructor: ArrayCamera,
  isArrayCamera: true
});
/**
 * @author jsantell / https://www.jsantell.com/
 * @author mrdoob / http://mrdoob.com/
 */

var cameraLPos = new Vector3();
var cameraRPos = new Vector3();
/**
 * Assumes 2 cameras that are parallel and share an X-axis, and that
 * the cameras' projection and world matrices have already been set.
 * And that near and far planes are identical for both cameras.
 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
 */

function setProjectionFromUnion(camera, cameraL, cameraR) {
  cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
  cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
  var ipd = cameraLPos.distanceTo(cameraRPos);
  var projL = cameraL.projectionMatrix.elements;
  var projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and
  // most likely identical top and bottom frustum extents.
  // Use the left camera for these values.

  var near = projL[14] / (projL[10] - 1);
  var far = projL[14] / (projL[10] + 1);
  var topFov = (projL[9] + 1) / projL[5];
  var bottomFov = (projL[9] - 1) / projL[5];
  var leftFov = (projL[8] - 1) / projL[0];
  var rightFov = (projR[8] + 1) / projR[0];
  var left = near * leftFov;
  var right = near * rightFov; // Calculate the new camera's position offset from the
  // left camera. xOffset should be roughly half `ipd`.

  var zOffset = ipd / (-leftFov + rightFov);
  var xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?

  cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
  camera.translateX(xOffset);
  camera.translateZ(zOffset);
  camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
  camera.matrixWorldInverse.getInverse(camera.matrixWorld); // Find the union of the frustum values of the cameras and scale
  // the values so that the near plane's position does not change in world space,
  // although must now be relative to the new union camera.

  var near2 = near + zOffset;
  var far2 = far + zOffset;
  var left2 = left - xOffset;
  var right2 = right + (ipd - xOffset);
  var top2 = topFov * far / far2 * near2;
  var bottom2 = bottomFov * far / far2 * near2;
  camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebVRManager(renderer) {
  var renderWidth, renderHeight;
  var scope = this;
  var device = null;
  var frameData = null;
  var poseTarget = null;
  var controllers = [];
  var standingMatrix = new Matrix4();
  var standingMatrixInverse = new Matrix4();
  var framebufferScaleFactor = 1.0;
  var referenceSpaceType = 'local-floor';

  if (typeof window !== 'undefined' && 'VRFrameData' in window) {
    frameData = new window.VRFrameData();
    window.addEventListener('vrdisplaypresentchange', onVRDisplayPresentChange, false);
  }

  var matrixWorldInverse = new Matrix4();
  var tempQuaternion = new Quaternion();
  var tempPosition = new Vector3();
  var cameraL = new PerspectiveCamera();
  cameraL.viewport = new Vector4();
  cameraL.layers.enable(1);
  var cameraR = new PerspectiveCamera();
  cameraR.viewport = new Vector4();
  cameraR.layers.enable(2);
  var cameraVR = new ArrayCamera([cameraL, cameraR]);
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2); //

  function isPresenting() {
    return device !== null && device.isPresenting === true;
  }

  var currentSize = new Vector2(),
      currentPixelRatio;

  function onVRDisplayPresentChange() {
    if (isPresenting()) {
      var eyeParameters = device.getEyeParameters('left');
      renderWidth = 2 * eyeParameters.renderWidth * framebufferScaleFactor;
      renderHeight = eyeParameters.renderHeight * framebufferScaleFactor;
      currentPixelRatio = renderer.getPixelRatio();
      renderer.getSize(currentSize);
      renderer.setDrawingBufferSize(renderWidth, renderHeight, 1);
      cameraL.viewport.set(0, 0, renderWidth / 2, renderHeight);
      cameraR.viewport.set(renderWidth / 2, 0, renderWidth / 2, renderHeight);
      animation.start();
      scope.dispatchEvent({
        type: 'sessionstart'
      });
    } else {
      if (scope.enabled) {
        renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio);
      }

      animation.stop();
      scope.dispatchEvent({
        type: 'sessionend'
      });
    }
  } //


  var triggers = [];

  function findGamepad(id) {
    var gamepads = navigator.getGamepads && navigator.getGamepads();

    for (var i = 0, j = 0, l = gamepads.length; i < l; i++) {
      var gamepad = gamepads[i];

      if (gamepad && (gamepad.id === 'Daydream Controller' || gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' || gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith('Oculus Touch') || gamepad.id.startsWith('HTC Vive Focus') || gamepad.id.startsWith('Spatial Controller'))) {
        if (j === id) return gamepad;
        j++;
      }
    }
  }

  function updateControllers() {
    for (var i = 0; i < controllers.length; i++) {
      var controller = controllers[i];
      var gamepad = findGamepad(i);

      if (gamepad !== undefined && gamepad.pose !== undefined) {
        if (gamepad.pose === null) return; // Pose

        var pose = gamepad.pose;
        if (pose.hasPosition === false) controller.position.set(0.2, -0.6, -0.05);
        if (pose.position !== null) controller.position.fromArray(pose.position);
        if (pose.orientation !== null) controller.quaternion.fromArray(pose.orientation);
        controller.matrix.compose(controller.position, controller.quaternion, controller.scale);
        controller.matrix.premultiply(standingMatrix);
        controller.matrix.decompose(controller.position, controller.quaternion, controller.scale);
        controller.matrixWorldNeedsUpdate = true;
        controller.visible = true; // Trigger

        var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;
        if (triggers[i] === undefined) triggers[i] = false;

        if (triggers[i] !== gamepad.buttons[buttonId].pressed) {
          triggers[i] = gamepad.buttons[buttonId].pressed;

          if (triggers[i] === true) {
            controller.dispatchEvent({
              type: 'selectstart'
            });
          } else {
            controller.dispatchEvent({
              type: 'selectend'
            });
            controller.dispatchEvent({
              type: 'select'
            });
          }
        }
      } else {
        controller.visible = false;
      }
    }
  }

  function updateViewportFromBounds(viewport, bounds) {
    if (bounds !== null && bounds.length === 4) {
      viewport.set(bounds[0] * renderWidth, bounds[1] * renderHeight, bounds[2] * renderWidth, bounds[3] * renderHeight);
    }
  } //


  this.enabled = false;

  this.getController = function (id) {
    var controller = controllers[id];

    if (controller === undefined) {
      controller = new Group();
      controller.matrixAutoUpdate = false;
      controller.visible = false;
      controllers[id] = controller;
    }

    return controller;
  };

  this.getDevice = function () {
    return device;
  };

  this.setDevice = function (value) {
    if (value !== undefined) device = value;
    animation.setContext(value);
  };

  this.setFramebufferScaleFactor = function (value) {
    framebufferScaleFactor = value;
  };

  this.setReferenceSpaceType = function (value) {
    referenceSpaceType = value;
  };

  this.setPoseTarget = function (object) {
    if (object !== undefined) poseTarget = object;
  };

  this.getCamera = function (camera) {
    var userHeight = referenceSpaceType === 'local-floor' ? 1.6 : 0;

    if (isPresenting() === false) {
      camera.position.set(0, userHeight, 0);
      camera.rotation.set(0, 0, 0);
      return camera;
    }

    device.depthNear = camera.near;
    device.depthFar = camera.far;
    device.getFrameData(frameData); //

    if (referenceSpaceType === 'local-floor') {
      var stageParameters = device.stageParameters;

      if (stageParameters) {
        standingMatrix.fromArray(stageParameters.sittingToStandingTransform);
      } else {
        standingMatrix.makeTranslation(0, userHeight, 0);
      }
    }

    var pose = frameData.pose;
    var poseObject = poseTarget !== null ? poseTarget : camera; // We want to manipulate poseObject by its position and quaternion components since users may rely on them.

    poseObject.matrix.copy(standingMatrix);
    poseObject.matrix.decompose(poseObject.position, poseObject.quaternion, poseObject.scale);

    if (pose.orientation !== null) {
      tempQuaternion.fromArray(pose.orientation);
      poseObject.quaternion.multiply(tempQuaternion);
    }

    if (pose.position !== null) {
      tempQuaternion.setFromRotationMatrix(standingMatrix);
      tempPosition.fromArray(pose.position);
      tempPosition.applyQuaternion(tempQuaternion);
      poseObject.position.add(tempPosition);
    }

    poseObject.updateMatrixWorld(); //

    cameraL.near = camera.near;
    cameraR.near = camera.near;
    cameraL.far = camera.far;
    cameraR.far = camera.far;
    cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix);
    cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix); // TODO (mrdoob) Double check this code

    standingMatrixInverse.getInverse(standingMatrix);

    if (referenceSpaceType === 'local-floor') {
      cameraL.matrixWorldInverse.multiply(standingMatrixInverse);
      cameraR.matrixWorldInverse.multiply(standingMatrixInverse);
    }

    var parent = poseObject.parent;

    if (parent !== null) {
      matrixWorldInverse.getInverse(parent.matrixWorld);
      cameraL.matrixWorldInverse.multiply(matrixWorldInverse);
      cameraR.matrixWorldInverse.multiply(matrixWorldInverse);
    } // envMap and Mirror needs camera.matrixWorld


    cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);
    cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);
    cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix);
    cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix);
    setProjectionFromUnion(cameraVR, cameraL, cameraR); //

    var layers = device.getLayers();

    if (layers.length) {
      var layer = layers[0];
      updateViewportFromBounds(cameraL.viewport, layer.leftBounds);
      updateViewportFromBounds(cameraR.viewport, layer.rightBounds);
    }

    updateControllers();
    return cameraVR;
  };

  this.getStandingMatrix = function () {
    return standingMatrix;
  };

  this.isPresenting = isPresenting; // Animation Loop

  var animation = new WebGLAnimation();

  this.setAnimationLoop = function (callback) {
    animation.setAnimationLoop(callback);
    if (isPresenting()) animation.start();
  };

  this.submitFrame = function () {
    if (isPresenting()) device.submitFrame();
  };

  this.dispose = function () {
    if (typeof window !== 'undefined') {
      window.removeEventListener('vrdisplaypresentchange', onVRDisplayPresentChange);
    }
  }; // DEPRECATED


  this.setFrameOfReferenceType = function () {
    console.warn('THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.');
  };
}

Object.assign(WebVRManager.prototype, EventDispatcher.prototype);
/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebXRManager(renderer, gl) {
  var scope = this;
  var session = null;
  var referenceSpace = null;
  var referenceSpaceType = 'local-floor';
  var pose = null;
  var controllers = [];
  var inputSources = [];

  function isPresenting() {
    return session !== null && referenceSpace !== null;
  } //


  var cameraL = new PerspectiveCamera();
  cameraL.layers.enable(1);
  cameraL.viewport = new Vector4();
  var cameraR = new PerspectiveCamera();
  cameraR.layers.enable(2);
  cameraR.viewport = new Vector4();
  var cameraVR = new ArrayCamera([cameraL, cameraR]);
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2); //

  this.enabled = false;

  this.getController = function (id) {
    var controller = controllers[id];

    if (controller === undefined) {
      controller = new Group();
      controller.matrixAutoUpdate = false;
      controller.visible = false;
      controllers[id] = controller;
    }

    return controller;
  }; //


  function onSessionEvent(event) {
    for (var i = 0; i < controllers.length; i++) {
      if (inputSources[i] === event.inputSource) {
        controllers[i].dispatchEvent({
          type: event.type
        });
      }
    }
  }

  function onSessionEnd() {
    renderer.setFramebuffer(null);
    renderer.setRenderTarget(renderer.getRenderTarget()); // Hack #15830

    animation.stop();
    scope.dispatchEvent({
      type: 'sessionend'
    });
  }

  function onRequestReferenceSpace(value) {
    referenceSpace = value;
    animation.setContext(session);
    animation.start();
    scope.dispatchEvent({
      type: 'sessionstart'
    });
  }

  this.setFramebufferScaleFactor = function (value) {};

  this.setReferenceSpaceType = function (value) {
    referenceSpaceType = value;
  };

  this.getSession = function () {
    return session;
  };

  this.setSession = function (value) {
    session = value;

    if (session !== null) {
      session.addEventListener('select', onSessionEvent);
      session.addEventListener('selectstart', onSessionEvent);
      session.addEventListener('selectend', onSessionEvent);
      session.addEventListener('end', onSessionEnd);
      session.updateRenderState({
        baseLayer: new XRWebGLLayer(session, gl)
      });
      session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace); //

      inputSources = session.inputSources;
      session.addEventListener('inputsourceschange', function () {
        inputSources = session.inputSources;
        console.log(inputSources);

        for (var i = 0; i < controllers.length; i++) {
          var controller = controllers[i];
          controller.userData.inputSource = inputSources[i];
        }
      });
    }
  };

  function updateCamera(camera, parent) {
    if (parent === null) {
      camera.matrixWorld.copy(camera.matrix);
    } else {
      camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
    }

    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
  }

  this.getCamera = function (camera) {
    if (isPresenting()) {
      var parent = camera.parent;
      var cameras = cameraVR.cameras;
      updateCamera(cameraVR, parent);

      for (var i = 0; i < cameras.length; i++) {
        updateCamera(cameras[i], parent);
      } // update camera and its children


      camera.matrixWorld.copy(cameraVR.matrixWorld);
      var children = camera.children;

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].updateMatrixWorld(true);
      }

      setProjectionFromUnion(cameraVR, cameraL, cameraR);
      return cameraVR;
    }

    return camera;
  };

  this.isPresenting = isPresenting; // Animation Loop

  var onAnimationFrameCallback = null;

  function onAnimationFrame(time, frame) {
    pose = frame.getViewerPose(referenceSpace);

    if (pose !== null) {
      var views = pose.views;
      var baseLayer = session.renderState.baseLayer;
      renderer.setFramebuffer(baseLayer.framebuffer);

      for (var i = 0; i < views.length; i++) {
        var view = views[i];
        var viewport = baseLayer.getViewport(view);
        var viewMatrix = view.transform.inverse.matrix;
        var camera = cameraVR.cameras[i];
        camera.matrix.fromArray(viewMatrix).getInverse(camera.matrix);
        camera.projectionMatrix.fromArray(view.projectionMatrix);
        camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

        if (i === 0) {
          cameraVR.matrix.copy(camera.matrix);
        }
      }
    } //


    for (var i = 0; i < controllers.length; i++) {
      var controller = controllers[i];
      var inputSource = inputSources[i];

      if (inputSource) {
        var inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

        if (inputPose !== null) {
          controller.matrix.fromArray(inputPose.transform.matrix);
          controller.matrix.decompose(controller.position, controller.rotation, controller.scale);
          controller.visible = true;
          continue;
        }
      }

      controller.visible = false;
    }

    if (onAnimationFrameCallback) onAnimationFrameCallback(time);
  }

  var animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);

  this.setAnimationLoop = function (callback) {
    onAnimationFrameCallback = callback;
  };

  this.dispose = function () {}; // DEPRECATED


  this.getStandingMatrix = function () {
    console.warn('THREE.WebXRManager: getStandingMatrix() is no longer needed.');
    return new Matrix4();
  };

  this.getDevice = function () {
    console.warn('THREE.WebXRManager: getDevice() has been deprecated.');
  };

  this.setDevice = function () {
    console.warn('THREE.WebXRManager: setDevice() has been deprecated.');
  };

  this.setFrameOfReferenceType = function () {
    console.warn('THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.');
  };

  this.submitFrame = function () {};
}

Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author tschw
 */

function WebGLRenderer(parameters) {
  parameters = parameters || {};

  var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
      _context = parameters.context !== undefined ? parameters.context : null,
      _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
      _depth = parameters.depth !== undefined ? parameters.depth : true,
      _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
      _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
      _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
      _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
      _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
      _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

  var currentRenderList = null;
  var currentRenderState = null; // public properties

  this.domElement = _canvas; // Debug configuration container

  this.debug = {
    /**
     * Enables error checking and reporting when shader programs are being compiled
     * @type {boolean}
     */
    checkShaderErrors: true
  }; // clearing

  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true; // scene graph

  this.sortObjects = true; // user-defined clipping

  this.clippingPlanes = [];
  this.localClippingEnabled = false; // physically based shading

  this.gammaFactor = 2.0; // for backwards compatibility

  this.gammaInput = false;
  this.gammaOutput = false; // physical lights

  this.physicallyCorrectLights = false; // tone mapping

  this.toneMapping = LinearToneMapping;
  this.toneMappingExposure = 1.0;
  this.toneMappingWhitePoint = 1.0; // morphs

  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4; // internal properties

  var _this = this,
      _isContextLost = false,
      // internal state cache
  _framebuffer = null,
      _currentActiveCubeFace = 0,
      _currentActiveMipmapLevel = 0,
      _currentRenderTarget = null,
      _currentFramebuffer = null,
      _currentMaterialId = -1,
      // geometry and program caching
  _currentGeometryProgram = {
    geometry: null,
    program: null,
    wireframe: false
  },
      _currentCamera = null,
      _currentArrayCamera = null,
      _currentViewport = new Vector4(),
      _currentScissor = new Vector4(),
      _currentScissorTest = null,
      //
  _width = _canvas.width,
      _height = _canvas.height,
      _pixelRatio = 1,
      _viewport = new Vector4(0, 0, _width, _height),
      _scissor = new Vector4(0, 0, _width, _height),
      _scissorTest = false,
      // frustum
  _frustum = new Frustum(),
      // clipping
  _clipping = new WebGLClipping(),
      _clippingEnabled = false,
      _localClippingEnabled = false,
      // camera matrices cache
  _projScreenMatrix = new Matrix4(),
      _vector3 = new Vector3();

  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  } // initialize


  var _gl;

  try {
    var contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat,
      xrCompatible: true
    }; // event listeners must be registered before WebGL context is created, see #12753

    _canvas.addEventListener('webglcontextlost', onContextLost, false);

    _canvas.addEventListener('webglcontextrestored', onContextRestore, false);

    _gl = _context || _canvas.getContext('webgl', contextAttributes) || _canvas.getContext('experimental-webgl', contextAttributes);

    if (_gl === null) {
      if (_canvas.getContext('webgl') !== null) {
        throw new Error('Error creating WebGL context with your selected attributes.');
      } else {
        throw new Error('Error creating WebGL context.');
      }
    } // Some experimental-webgl implementations do not have getShaderPrecisionFormat


    if (_gl.getShaderPrecisionFormat === undefined) {
      _gl.getShaderPrecisionFormat = function () {
        return {
          'rangeMin': 1,
          'rangeMax': 1,
          'precision': 1
        };
      };
    }
  } catch (error) {
    console.error('THREE.WebGLRenderer: ' + error.message);
    throw error;
  }

  var extensions, capabilities, state, info;
  var properties, textures, attributes, geometries, objects;
  var programCache, renderLists, renderStates;
  var background, morphtargets, bufferRenderer, indexedBufferRenderer;
  var utils;

  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);

    if (!capabilities.isWebGL2) {
      extensions.get('WEBGL_depth_texture');
      extensions.get('OES_texture_float');
      extensions.get('OES_texture_half_float');
      extensions.get('OES_texture_half_float_linear');
      extensions.get('OES_standard_derivatives');
      extensions.get('OES_element_index_uint');
      extensions.get('ANGLE_instanced_arrays');
    }

    extensions.get('OES_texture_float_linear');
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, utils, capabilities);
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    attributes = new WebGLAttributes(_gl);
    geometries = new WebGLGeometries(_gl, attributes, info);
    objects = new WebGLObjects(geometries, info);
    morphtargets = new WebGLMorphtargets(_gl);
    programCache = new WebGLPrograms(_this, extensions, capabilities);
    renderLists = new WebGLRenderLists();
    renderStates = new WebGLRenderStates();
    background = new WebGLBackground(_this, state, objects, _premultipliedAlpha);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.state = state;
    _this.info = info;
  }

  initGLContext(); // vr

  var vr = typeof navigator !== 'undefined' && 'xr' in navigator && 'supportsSession' in navigator.xr ? new WebXRManager(_this, _gl) : new WebVRManager(_this);
  this.vr = vr; // shadow map

  var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
  this.shadowMap = shadowMap; // API

  this.getContext = function () {
    return _gl;
  };

  this.getContextAttributes = function () {
    return _gl.getContextAttributes();
  };

  this.forceContextLoss = function () {
    var extension = extensions.get('WEBGL_lose_context');
    if (extension) extension.loseContext();
  };

  this.forceContextRestore = function () {
    var extension = extensions.get('WEBGL_lose_context');
    if (extension) extension.restoreContext();
  };

  this.getPixelRatio = function () {
    return _pixelRatio;
  };

  this.setPixelRatio = function (value) {
    if (value === undefined) return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };

  this.getSize = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');
      target = new Vector2();
    }

    return target.set(_width, _height);
  };

  this.setSize = function (width, height, updateStyle) {
    if (vr.isPresenting()) {
      console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
      return;
    }

    _width = width;
    _height = height;
    _canvas.width = Math.floor(width * _pixelRatio);
    _canvas.height = Math.floor(height * _pixelRatio);

    if (updateStyle !== false) {
      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';
    }

    this.setViewport(0, 0, width, height);
  };

  this.getDrawingBufferSize = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');
      target = new Vector2();
    }

    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };

  this.setDrawingBufferSize = function (width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas.width = Math.floor(width * pixelRatio);
    _canvas.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };

  this.getCurrentViewport = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');
      target = new Vector4();
    }

    return target.copy(_currentViewport);
  };

  this.getViewport = function (target) {
    return target.copy(_viewport);
  };

  this.setViewport = function (x, y, width, height) {
    if (x.isVector4) {
      _viewport.set(x.x, x.y, x.z, x.w);
    } else {
      _viewport.set(x, y, width, height);
    }

    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };

  this.getScissor = function (target) {
    return target.copy(_scissor);
  };

  this.setScissor = function (x, y, width, height) {
    if (x.isVector4) {
      _scissor.set(x.x, x.y, x.z, x.w);
    } else {
      _scissor.set(x, y, width, height);
    }

    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };

  this.getScissorTest = function () {
    return _scissorTest;
  };

  this.setScissorTest = function (boolean) {
    state.setScissorTest(_scissorTest = boolean);
  }; // Clearing


  this.getClearColor = function () {
    return background.getClearColor();
  };

  this.setClearColor = function () {
    background.setClearColor.apply(background, arguments);
  };

  this.getClearAlpha = function () {
    return background.getClearAlpha();
  };

  this.setClearAlpha = function () {
    background.setClearAlpha.apply(background, arguments);
  };

  this.clear = function (color, depth, stencil) {
    var bits = 0;
    if (color === undefined || color) bits |= 16384;
    if (depth === undefined || depth) bits |= 256;
    if (stencil === undefined || stencil) bits |= 1024;

    _gl.clear(bits);
  };

  this.clearColor = function () {
    this.clear(true, false, false);
  };

  this.clearDepth = function () {
    this.clear(false, true, false);
  };

  this.clearStencil = function () {
    this.clear(false, false, true);
  }; //


  this.dispose = function () {
    _canvas.removeEventListener('webglcontextlost', onContextLost, false);

    _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    objects.dispose();
    vr.dispose();
    animation.stop();
  }; // Events


  function onContextLost(event) {
    event.preventDefault();
    console.log('THREE.WebGLRenderer: Context Lost.');
    _isContextLost = true;
  }

  function onContextRestore()
  /* event */
  {
    console.log('THREE.WebGLRenderer: Context Restored.');
    _isContextLost = false;
    initGLContext();
  }

  function onMaterialDispose(event) {
    var material = event.target;
    material.removeEventListener('dispose', onMaterialDispose);
    deallocateMaterial(material);
  } // Buffer deallocation


  function deallocateMaterial(material) {
    releaseMaterialProgramReference(material);
    properties.remove(material);
  }

  function releaseMaterialProgramReference(material) {
    var programInfo = properties.get(material).program;
    material.program = undefined;

    if (programInfo !== undefined) {
      programCache.releaseProgram(programInfo);
    }
  } // Buffer rendering


  function renderObjectImmediate(object, program) {
    object.render(function (object) {
      _this.renderBufferImmediate(object, program);
    });
  }

  this.renderBufferImmediate = function (object, program) {
    state.initAttributes();
    var buffers = properties.get(object);
    if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
    var programAttributes = program.getAttributes();

    if (object.hasPositions) {
      _gl.bindBuffer(34962, buffers.position);

      _gl.bufferData(34962, object.positionArray, 35048);

      state.enableAttribute(programAttributes.position);

      _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
    }

    if (object.hasNormals) {
      _gl.bindBuffer(34962, buffers.normal);

      _gl.bufferData(34962, object.normalArray, 35048);

      state.enableAttribute(programAttributes.normal);

      _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
    }

    if (object.hasUvs) {
      _gl.bindBuffer(34962, buffers.uv);

      _gl.bufferData(34962, object.uvArray, 35048);

      state.enableAttribute(programAttributes.uv);

      _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
    }

    if (object.hasColors) {
      _gl.bindBuffer(34962, buffers.color);

      _gl.bufferData(34962, object.colorArray, 35048);

      state.enableAttribute(programAttributes.color);

      _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
    }

    state.disableUnusedAttributes();

    _gl.drawArrays(4, 0, object.count);

    object.count = 0;
  };

  this.renderBufferDirect = function (camera, fog, geometry, material, object, group) {
    var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    state.setMaterial(material, frontFaceCW);
    var program = setProgram(camera, fog, material, object);
    var updateBuffers = false;

    if (_currentGeometryProgram.geometry !== geometry.id || _currentGeometryProgram.program !== program.id || _currentGeometryProgram.wireframe !== (material.wireframe === true)) {
      _currentGeometryProgram.geometry = geometry.id;
      _currentGeometryProgram.program = program.id;
      _currentGeometryProgram.wireframe = material.wireframe === true;
      updateBuffers = true;
    }

    if (object.morphTargetInfluences) {
      morphtargets.update(object, geometry, material, program);
      updateBuffers = true;
    } //


    var index = geometry.index;
    var position = geometry.attributes.position;
    var rangeFactor = 1;

    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }

    var attribute;
    var renderer = bufferRenderer;

    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }

    if (updateBuffers) {
      setupVertexAttributes(material, program, geometry);

      if (index !== null) {
        _gl.bindBuffer(34963, attribute.buffer);
      }
    } //


    var dataCount = Infinity;

    if (index !== null) {
      dataCount = index.count;
    } else if (position !== undefined) {
      dataCount = position.count;
    }

    var rangeStart = geometry.drawRange.start * rangeFactor;
    var rangeCount = geometry.drawRange.count * rangeFactor;
    var groupStart = group !== null ? group.start * rangeFactor : 0;
    var groupCount = group !== null ? group.count * rangeFactor : Infinity;
    var drawStart = Math.max(rangeStart, groupStart);
    var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    var drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0) return; //

    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        switch (object.drawMode) {
          case TrianglesDrawMode:
            renderer.setMode(4);
            break;

          case TriangleStripDrawMode:
            renderer.setMode(5);
            break;

          case TriangleFanDrawMode:
            renderer.setMode(6);
            break;
        }
      }
    } else if (object.isLine) {
      var lineWidth = material.linewidth;
      if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

      state.setLineWidth(lineWidth * getTargetPixelRatio());

      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }

    if (geometry && geometry.isInstancedBufferGeometry) {
      if (geometry.maxInstancedCount > 0) {
        renderer.renderInstances(geometry, drawStart, drawCount);
      }
    } else {
      renderer.render(drawStart, drawCount);
    }
  };

  function setupVertexAttributes(material, program, geometry) {
    if (geometry && geometry.isInstancedBufferGeometry && !capabilities.isWebGL2) {
      if (extensions.get('ANGLE_instanced_arrays') === null) {
        console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }

    state.initAttributes();
    var geometryAttributes = geometry.attributes;
    var programAttributes = program.getAttributes();
    var materialDefaultAttributeValues = material.defaultAttributeValues;

    for (var name in programAttributes) {
      var programAttribute = programAttributes[name];

      if (programAttribute >= 0) {
        var geometryAttribute = geometryAttributes[name];

        if (geometryAttribute !== undefined) {
          var normalized = geometryAttribute.normalized;
          var size = geometryAttribute.itemSize;
          var attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore

          if (attribute === undefined) continue;
          var buffer = attribute.buffer;
          var type = attribute.type;
          var bytesPerElement = attribute.bytesPerElement;

          if (geometryAttribute.isInterleavedBufferAttribute) {
            var data = geometryAttribute.data;
            var stride = data.stride;
            var offset = geometryAttribute.offset;

            if (data && data.isInstancedInterleavedBuffer) {
              state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

              if (geometry.maxInstancedCount === undefined) {
                geometry.maxInstancedCount = data.meshPerAttribute * data.count;
              }
            } else {
              state.enableAttribute(programAttribute);
            }

            _gl.bindBuffer(34962, buffer);

            _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

              if (geometry.maxInstancedCount === undefined) {
                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              state.enableAttribute(programAttribute);
            }

            _gl.bindBuffer(34962, buffer);

            _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
          }
        } else if (materialDefaultAttributeValues !== undefined) {
          var value = materialDefaultAttributeValues[name];

          if (value !== undefined) {
            switch (value.length) {
              case 2:
                _gl.vertexAttrib2fv(programAttribute, value);

                break;

              case 3:
                _gl.vertexAttrib3fv(programAttribute, value);

                break;

              case 4:
                _gl.vertexAttrib4fv(programAttribute, value);

                break;

              default:
                _gl.vertexAttrib1fv(programAttribute, value);

            }
          }
        }
      }
    }

    state.disableUnusedAttributes();
  } // Compile


  this.compile = function (scene, camera) {
    currentRenderState = renderStates.get(scene, camera);
    currentRenderState.init();
    scene.traverse(function (object) {
      if (object.isLight) {
        currentRenderState.pushLight(object);

        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights(camera);
    scene.traverse(function (object) {
      if (object.material) {
        if (Array.isArray(object.material)) {
          for (var i = 0; i < object.material.length; i++) {
            initMaterial(object.material[i], scene.fog, object);
          }
        } else {
          initMaterial(object.material, scene.fog, object);
        }
      }
    });
  }; // Animation Loop


  var onAnimationFrameCallback = null;

  function onAnimationFrame(time) {
    if (vr.isPresenting()) return;
    if (onAnimationFrameCallback) onAnimationFrameCallback(time);
  }

  var animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== 'undefined') animation.setContext(window);

  this.setAnimationLoop = function (callback) {
    onAnimationFrameCallback = callback;
    vr.setAnimationLoop(callback);
    animation.start();
  }; // Rendering


  this.render = function (scene, camera) {
    var renderTarget, forceClear;

    if (arguments[2] !== undefined) {
      console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
      renderTarget = arguments[2];
    }

    if (arguments[3] !== undefined) {
      console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
      forceClear = arguments[3];
    }

    if (!(camera && camera.isCamera)) {
      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
      return;
    }

    if (_isContextLost) return; // reset caching for this frame

    _currentGeometryProgram.geometry = null;
    _currentGeometryProgram.program = null;
    _currentGeometryProgram.wireframe = false;
    _currentMaterialId = -1;
    _currentCamera = null; // update scene graph

    if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum

    if (camera.parent === null) camera.updateMatrixWorld();

    if (vr.enabled) {
      camera = vr.getCamera(camera);
    } //


    currentRenderState = renderStates.get(scene, camera);
    currentRenderState.init();
    scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);

    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

    _frustum.setFromMatrix(_projScreenMatrix);

    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, camera);
    currentRenderList.init();
    projectObject(scene, camera, 0, _this.sortObjects);

    if (_this.sortObjects === true) {
      currentRenderList.sort();
    } //


    if (_clippingEnabled) _clipping.beginShadows();
    var shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    currentRenderState.setupLights(camera);
    if (_clippingEnabled) _clipping.endShadows(); //

    if (this.info.autoReset) this.info.reset();

    if (renderTarget !== undefined) {
      this.setRenderTarget(renderTarget);
    } //


    background.render(currentRenderList, scene, camera, forceClear); // render scene

    var opaqueObjects = currentRenderList.opaque;
    var transparentObjects = currentRenderList.transparent;

    if (scene.overrideMaterial) {
      var overrideMaterial = scene.overrideMaterial;
      if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera, overrideMaterial);
      if (transparentObjects.length) renderObjects(transparentObjects, scene, camera, overrideMaterial);
    } else {
      // opaque pass (front-to-back order)
      if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera); // transparent pass (back-to-front order)

      if (transparentObjects.length) renderObjects(transparentObjects, scene, camera);
    } //


    scene.onAfterRender(_this, scene, camera); //

    if (_currentRenderTarget !== null) {
      // Generate mipmap if we're using any kind of mipmap filtering
      textures.updateRenderTargetMipmap(_currentRenderTarget); // resolve multisample renderbuffers to a single-sample texture if necessary

      textures.updateMultisampleRenderTarget(_currentRenderTarget);
    } // Ensure depth buffer writing is enabled so it can be cleared on next render


    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);

    if (vr.enabled) {
      vr.submitFrame();
    } // _gl.finish();


    currentRenderList = null;
    currentRenderState = null;
  };

  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false) return;
    var visible = object.layers.test(camera.layers);

    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true) object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);

        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }

          var geometry = objects.update(object);
          var material = object.material;

          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
        }

        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          object.skeleton.update();
        }

        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }

          var geometry = objects.update(object);
          var material = object.material;

          if (Array.isArray(material)) {
            var groups = geometry.groups;

            for (var i = 0, l = groups.length; i < l; i++) {
              var group = groups[i];
              var groupMaterial = material[group.materialIndex];

              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }

    var children = object.children;

    for (var i = 0, l = children.length; i < l; i++) {
      projectObject(children[i], camera, groupOrder, sortObjects);
    }
  }

  function renderObjects(renderList, scene, camera, overrideMaterial) {
    for (var i = 0, l = renderList.length; i < l; i++) {
      var renderItem = renderList[i];
      var object = renderItem.object;
      var geometry = renderItem.geometry;
      var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
      var group = renderItem.group;

      if (camera.isArrayCamera) {
        _currentArrayCamera = camera;
        var cameras = camera.cameras;

        for (var j = 0, jl = cameras.length; j < jl; j++) {
          var camera2 = cameras[j];

          if (object.layers.test(camera2.layers)) {
            state.viewport(_currentViewport.copy(camera2.viewport));
            currentRenderState.setupLights(camera2);
            renderObject(object, scene, camera2, geometry, material, group);
          }
        }
      } else {
        _currentArrayCamera = null;
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }

  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

    if (object.isImmediateRenderObject) {
      state.setMaterial(material);
      var program = setProgram(camera, scene.fog, material, object);
      _currentGeometryProgram.geometry = null;
      _currentGeometryProgram.program = null;
      _currentGeometryProgram.wireframe = false;
      renderObjectImmediate(object, program);
    } else {
      _this.renderBufferDirect(camera, scene.fog, geometry, material, object, group);
    }

    object.onAfterRender(_this, scene, camera, geometry, material, group);
    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
  }

  function initMaterial(material, fog, object) {
    var materialProperties = properties.get(material);
    var lights = currentRenderState.state.lights;
    var shadowsArray = currentRenderState.state.shadowsArray;
    var lightsStateVersion = lights.state.version;
    var parameters = programCache.getParameters(material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object);
    var code = programCache.getProgramCode(material, parameters);
    var program = materialProperties.program;
    var programChange = true;

    if (program === undefined) {
      // new material
      material.addEventListener('dispose', onMaterialDispose);
    } else if (program.code !== code) {
      // changed glsl or parameters
      releaseMaterialProgramReference(material);
    } else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
      materialProperties.lightsStateVersion = lightsStateVersion;
      programChange = false;
    } else if (parameters.shaderID !== undefined) {
      // same glsl and uniform list
      return;
    } else {
      // only rebuild uniform list
      programChange = false;
    }

    if (programChange) {
      if (parameters.shaderID) {
        var shader = ShaderLib[parameters.shaderID];
        materialProperties.shader = {
          name: material.type,
          uniforms: cloneUniforms(shader.uniforms),
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader
        };
      } else {
        materialProperties.shader = {
          name: material.type,
          uniforms: material.uniforms,
          vertexShader: material.vertexShader,
          fragmentShader: material.fragmentShader
        };
      }

      material.onBeforeCompile(materialProperties.shader, _this); // Computing code again as onBeforeCompile may have changed the shaders

      code = programCache.getProgramCode(material, parameters);
      program = programCache.acquireProgram(material, materialProperties.shader, parameters, code);
      materialProperties.program = program;
      material.program = program;
    }

    var programAttributes = program.getAttributes();

    if (material.morphTargets) {
      material.numSupportedMorphTargets = 0;

      for (var i = 0; i < _this.maxMorphTargets; i++) {
        if (programAttributes['morphTarget' + i] >= 0) {
          material.numSupportedMorphTargets++;
        }
      }
    }

    if (material.morphNormals) {
      material.numSupportedMorphNormals = 0;

      for (var i = 0; i < _this.maxMorphNormals; i++) {
        if (programAttributes['morphNormal' + i] >= 0) {
          material.numSupportedMorphNormals++;
        }
      }
    }

    var uniforms = materialProperties.shader.uniforms;

    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      materialProperties.numClippingPlanes = _clipping.numPlanes;
      materialProperties.numIntersection = _clipping.numIntersection;
      uniforms.clippingPlanes = _clipping.uniform;
    }

    materialProperties.fog = fog; // store the light setup it was created for

    materialProperties.lightsStateVersion = lightsStateVersion;

    if (material.lights) {
      // wire up the material to this renderer's lighting state
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.pointLights.value = lights.state.point;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms
    }

    var progUniforms = materialProperties.program.getUniforms(),
        uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.uniformsList = uniformsList;
  }

  function setProgram(camera, fog, material, object) {
    textures.resetTextureUnits();
    var materialProperties = properties.get(material);
    var lights = currentRenderState.state.lights;

    if (_clippingEnabled) {
      if (_localClippingEnabled || camera !== _currentCamera) {
        var useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup
        // object instead of the material, once it becomes feasible
        // (#8465, #8379)

        _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
      }
    }

    if (material.needsUpdate === false) {
      if (materialProperties.program === undefined) {
        material.needsUpdate = true;
      } else if (material.fog && materialProperties.fog !== fog) {
        material.needsUpdate = true;
      } else if (material.lights && materialProperties.lightsStateVersion !== lights.state.version) {
        material.needsUpdate = true;
      } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
        material.needsUpdate = true;
      }
    }

    if (material.needsUpdate) {
      initMaterial(material, fog, object);
      material.needsUpdate = false;
    }

    var refreshProgram = false;
    var refreshMaterial = false;
    var refreshLights = false;
    var program = materialProperties.program,
        p_uniforms = program.getUniforms(),
        m_uniforms = materialProperties.shader.uniforms;

    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }

    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }

    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
      }

      if (_currentCamera !== camera) {
        _currentCamera = camera; // lighting uniforms depend on the camera so enforce an update
        // now, in case this material supports lights - or later, when
        // the next material that does gets activated:

        refreshMaterial = true; // set to true on material change

        refreshLights = true; // remains set until update done
      } // load material specific uniforms
      // (shader material also gets them for the sake of genericity)


      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
        var uCamPos = p_uniforms.map.cameraPosition;

        if (uCamPos !== undefined) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }

      if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {
        p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
      }
    } // skinning uniforms must be set even if material didn't change
    // auto-setting of texture unit for bone texture must go before other textures
    // not sure why, but otherwise weird things happen


    if (material.skinning) {
      p_uniforms.setOptional(_gl, object, 'bindMatrix');
      p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
      var skeleton = object.skeleton;

      if (skeleton) {
        var bones = skeleton.bones;

        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === undefined) {
            // layout (1 matrix = 4 pixels)
            //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
            //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
            //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
            //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
            //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
            var size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix

            size = _Math.ceilPowerOfTwo(size);
            size = Math.max(size, 4);
            var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel

            boneMatrices.set(skeleton.boneMatrices); // copy current values

            var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
            boneTexture.needsUpdate = true;
            skeleton.boneMatrices = boneMatrices;
            skeleton.boneTexture = boneTexture;
            skeleton.boneTextureSize = size;
          }

          p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
        }
      }
    }

    if (refreshMaterial) {
      p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
      p_uniforms.setValue(_gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint);

      if (material.lights) {
        // the current material requires lighting info
        // note: all lighting uniforms are always set correctly
        // they simply reference the renderer's state for their
        // values
        //
        // use the current material's .needsUpdate flags to set
        // the GL state when required
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      } // refresh uniforms common to several materials


      if (fog && material.fog) {
        refreshUniformsFog(m_uniforms, fog);
      }

      if (material.isMeshBasicMaterial) {
        refreshUniformsCommon(m_uniforms, material);
      } else if (material.isMeshLambertMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsLambert(m_uniforms, material);
      } else if (material.isMeshPhongMaterial) {
        refreshUniformsCommon(m_uniforms, material);

        if (material.isMeshToonMaterial) {
          refreshUniformsToon(m_uniforms, material);
        } else {
          refreshUniformsPhong(m_uniforms, material);
        }
      } else if (material.isMeshStandardMaterial) {
        refreshUniformsCommon(m_uniforms, material);

        if (material.isMeshPhysicalMaterial) {
          refreshUniformsPhysical(m_uniforms, material);
        } else {
          refreshUniformsStandard(m_uniforms, material);
        }
      } else if (material.isMeshMatcapMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsMatcap(m_uniforms, material);
      } else if (material.isMeshDepthMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsDepth(m_uniforms, material);
      } else if (material.isMeshDistanceMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsDistance(m_uniforms, material);
      } else if (material.isMeshNormalMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsNormal(m_uniforms, material);
      } else if (material.isLineBasicMaterial) {
        refreshUniformsLine(m_uniforms, material);

        if (material.isLineDashedMaterial) {
          refreshUniformsDash(m_uniforms, material);
        }
      } else if (material.isPointsMaterial) {
        refreshUniformsPoints(m_uniforms, material);
      } else if (material.isSpriteMaterial) {
        refreshUniformsSprites(m_uniforms, material);
      } else if (material.isShadowMaterial) {
        m_uniforms.color.value.copy(material.color);
        m_uniforms.opacity.value = material.opacity;
      } // RectAreaLight Texture
      // TODO (mrdoob): Find a nicer implementation


      if (m_uniforms.ltc_1 !== undefined) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
      if (m_uniforms.ltc_2 !== undefined) m_uniforms.ltc_2.value = UniformsLib.LTC_2;
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }

    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }

    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, 'center', object.center);
    } // common matrices


    p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
    p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
    p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
    return program;
  } // Uniforms (refresh uniforms objects)


  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;

    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }

    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }

    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }

    if (material.envMap) {
      uniforms.envMap.value = material.envMap; // don't flip CubeTexture envMaps, flip everything else:
      //  WebGLRenderTargetCube will be flipped for backwards compatibility
      //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
      // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future

      uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;
      uniforms.maxMipLevel.value = properties.get(material.envMap).__maxMipLevel;
    }

    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }

    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. specular map
    // 3. normal map
    // 4. bump map
    // 5. alpha map
    // 6. emissive map


    var uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    }

    if (uvScaleMap !== undefined) {
      // backwards compatibility
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }

      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }

  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }

  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }

  function refreshUniformsPoints(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * _pixelRatio;
    uniforms.scale.value = _height * 0.5;
    uniforms.map.value = material.map;

    if (material.map !== null) {
      if (material.map.matrixAutoUpdate === true) {
        material.map.updateMatrix();
      }

      uniforms.uvTransform.value.copy(material.map.matrix);
    }
  }

  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    uniforms.map.value = material.map;

    if (material.map !== null) {
      if (material.map.matrixAutoUpdate === true) {
        material.map.updateMatrix();
      }

      uniforms.uvTransform.value.copy(material.map.matrix);
    }
  }

  function refreshUniformsFog(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);

    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }

  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }

  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsToon(uniforms, material) {
    refreshUniformsPhong(uniforms, material);

    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }

  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;

    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }

    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }

    if (material.envMap) {
      //uniforms.envMap.value = material.envMap; // part of uniforms common
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }

  function refreshUniformsPhysical(uniforms, material) {
    refreshUniformsStandard(uniforms, material);
    uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

    uniforms.clearcoat.value = material.clearcoat;
    uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
    if (material.sheen) uniforms.sheen.value.copy(material.sheen);

    if (material.clearcoatNormalMap) {
      uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
      uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

      if (material.side === BackSide) {
        uniforms.clearcoatNormalScale.value.negate();
      }
    }

    uniforms.transparency.value = material.transparency;
  }

  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }

    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }

  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  } // If uniforms are marked as clean, they don't need to be loaded to the GPU.


  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  } //


  this.setFramebuffer = function (value) {
    if (_framebuffer !== value) _gl.bindFramebuffer(36160, value);
    _framebuffer = value;
  };

  this.getActiveCubeFace = function () {
    return _currentActiveCubeFace;
  };

  this.getActiveMipmapLevel = function () {
    return _currentActiveMipmapLevel;
  };

  this.getRenderTarget = function () {
    return _currentRenderTarget;
  };

  this.setRenderTarget = function (renderTarget, activeCubeFace, activeMipmapLevel) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;

    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
      textures.setupRenderTarget(renderTarget);
    }

    var framebuffer = _framebuffer;
    var isCube = false;

    if (renderTarget) {
      var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

      if (renderTarget.isWebGLRenderTargetCube) {
        framebuffer = __webglFramebuffer[activeCubeFace || 0];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }

      _currentViewport.copy(renderTarget.viewport);

      _currentScissor.copy(renderTarget.scissor);

      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();

      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();

      _currentScissorTest = _scissorTest;
    }

    if (_currentFramebuffer !== framebuffer) {
      _gl.bindFramebuffer(36160, framebuffer);

      _currentFramebuffer = framebuffer;
    }

    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);

    if (isCube) {
      var textureProperties = properties.get(renderTarget.texture);

      _gl.framebufferTexture2D(36160, 36064, 34069 + (activeCubeFace || 0), textureProperties.__webglTexture, activeMipmapLevel || 0);
    }
  };

  this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
      return;
    }

    var framebuffer = properties.get(renderTarget).__webglFramebuffer;

    if (renderTarget.isWebGLRenderTargetCube && activeCubeFaceIndex !== undefined) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }

    if (framebuffer) {
      var restore = false;

      if (framebuffer !== _currentFramebuffer) {
        _gl.bindFramebuffer(36160, framebuffer);

        restore = true;
      }

      try {
        var texture = renderTarget.texture;
        var textureFormat = texture.format;
        var textureType = texture.type;

        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
          return;
        }

        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && // IE11, Edge and Chrome Mac < 52 (#9513)
        !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
        !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get('EXT_color_buffer_float') : extensions.get('EXT_color_buffer_half_float')))) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
          return;
        }

        if (_gl.checkFramebufferStatus(36160) === 36053) {
          // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
          if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } else {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
        }
      } finally {
        if (restore) {
          _gl.bindFramebuffer(36160, _currentFramebuffer);
        }
      }
    }
  };

  this.copyFramebufferToTexture = function (position, texture, level) {
    var width = texture.image.width;
    var height = texture.image.height;
    var glFormat = utils.convert(texture.format);
    textures.setTexture2D(texture, 0);

    _gl.copyTexImage2D(3553, level || 0, glFormat, position.x, position.y, width, height, 0);
  };

  this.copyTextureToTexture = function (position, srcTexture, dstTexture, level) {
    var width = srcTexture.image.width;
    var height = srcTexture.image.height;
    var glFormat = utils.convert(dstTexture.format);
    var glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);

    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      _gl.texSubImage2D(3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image);
    }
  };

  if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
      detail: this
    })); // eslint-disable-line no-undef

  }
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */


function FogExp2(color, density) {
  this.name = '';
  this.color = new Color(color);
  this.density = density !== undefined ? density : 0.00025;
}

Object.assign(FogExp2.prototype, {
  isFogExp2: true,
  clone: function () {
    return new FogExp2(this.color, this.density);
  },
  toJSON: function ()
  /* meta */
  {
    return {
      type: 'FogExp2',
      color: this.color.getHex(),
      density: this.density
    };
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Fog(color, near, far) {
  this.name = '';
  this.color = new Color(color);
  this.near = near !== undefined ? near : 1;
  this.far = far !== undefined ? far : 1000;
}

Object.assign(Fog.prototype, {
  isFog: true,
  clone: function () {
    return new Fog(this.color, this.near, this.far);
  },
  toJSON: function ()
  /* meta */
  {
    return {
      type: 'Fog',
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
});
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InterleavedBuffer(array, stride) {
  this.array = array;
  this.stride = stride;
  this.count = array !== undefined ? array.length / stride : 0;
  this.dynamic = false;
  this.updateRange = {
    offset: 0,
    count: -1
  };
  this.version = 0;
}

Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {
  set: function (value) {
    if (value === true) this.version++;
  }
});
Object.assign(InterleavedBuffer.prototype, {
  isInterleavedBuffer: true,
  onUploadCallback: function () {},
  setArray: function (array) {
    if (Array.isArray(array)) {
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    }

    this.count = array !== undefined ? array.length / this.stride : 0;
    this.array = array;
    return this;
  },
  setDynamic: function (value) {
    this.dynamic = value;
    return this;
  },
  copy: function (source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.dynamic = source.dynamic;
    return this;
  },
  copyAt: function (index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;

    for (var i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }

    return this;
  },
  set: function (value, offset) {
    if (offset === undefined) offset = 0;
    this.array.set(value, offset);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  onUpload: function (callback) {
    this.onUploadCallback = callback;
    return this;
  }
});
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset;
  this.normalized = normalized === true;
}

Object.defineProperties(InterleavedBufferAttribute.prototype, {
  count: {
    get: function () {
      return this.data.count;
    }
  },
  array: {
    get: function () {
      return this.data.array;
    }
  }
});
Object.assign(InterleavedBufferAttribute.prototype, {
  isInterleavedBufferAttribute: true,
  setX: function (index, x) {
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  },
  setY: function (index, y) {
    this.data.array[index * this.data.stride + this.offset + 1] = y;
    return this;
  },
  setZ: function (index, z) {
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  },
  setW: function (index, w) {
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  },
  getX: function (index) {
    return this.data.array[index * this.data.stride + this.offset];
  },
  getY: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  },
  getZ: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  },
  getW: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  },
  setXY: function (index, x, y) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    return this;
  },
  setXYZ: function (index, x, y, z) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    return this;
  },
  setXYZW: function (index, x, y, z, w) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

function SpriteMaterial(parameters) {
  Material.call(this);
  this.type = 'SpriteMaterial';
  this.color = new Color(0xffffff);
  this.map = null;
  this.rotation = 0;
  this.sizeAttenuation = true;
  this.lights = false;
  this.transparent = true;
  this.setValues(parameters);
}

SpriteMaterial.prototype = Object.create(Material.prototype);
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;

SpriteMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.rotation = source.rotation;
  this.sizeAttenuation = source.sizeAttenuation;
  return this;
};
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */


var _geometry;

var _intersectPoint = new Vector3();

var _worldScale = new Vector3();

var _mvPosition = new Vector3();

var _alignedPosition = new Vector2();

var _rotatedPosition = new Vector2();

var _viewWorldMatrix = new Matrix4();

var _vA$1 = new Vector3();

var _vB$1 = new Vector3();

var _vC$1 = new Vector3();

var _uvA$1 = new Vector2();

var _uvB$1 = new Vector2();

var _uvC$1 = new Vector2();

function Sprite(material) {
  Object3D.call(this);
  this.type = 'Sprite';

  if (_geometry === undefined) {
    _geometry = new BufferGeometry();
    var float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
    var interleavedBuffer = new InterleavedBuffer(float32Array, 5);

    _geometry.setIndex([0, 1, 2, 0, 2, 3]);

    _geometry.addAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));

    _geometry.addAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
  }

  this.geometry = _geometry;
  this.material = material !== undefined ? material : new SpriteMaterial();
  this.center = new Vector2(0.5, 0.5);
}

Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Sprite,
  isSprite: true,
  raycast: function (raycaster, intersects) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }

    _worldScale.setFromMatrixScale(this.matrixWorld);

    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);

    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);

    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);

    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }

    var rotation = this.material.rotation;
    var sin, cos;

    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }

    var center = this.center;
    transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

    _uvA$1.set(0, 0);

    _uvB$1.set(1, 0);

    _uvC$1.set(1, 1); // check first triangle


    var intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);

    if (intersect === null) {
      // check second triangle
      transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

      _uvB$1.set(0, 1);

      intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);

      if (intersect === null) {
        return;
      }
    }

    var distance = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects.push({
      distance: distance,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
      face: null,
      object: this
    });
  },
  clone: function () {
    return new this.constructor(this.material).copy(this);
  },
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    if (source.center !== undefined) this.center.copy(source.center);
    return this;
  }
});

function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  // compute position in camera space
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero


  if (sin !== undefined) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }

  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y; // transform to world space

  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */


var _v1$4 = new Vector3();

var _v2$2 = new Vector3();

function LOD() {
  Object3D.call(this);
  this.type = 'LOD';
  Object.defineProperties(this, {
    levels: {
      enumerable: true,
      value: []
    }
  });
  this.autoUpdate = true;
}

LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: LOD,
  isLOD: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source, false);
    var levels = source.levels;

    for (var i = 0, l = levels.length; i < l; i++) {
      var level = levels[i];
      this.addLevel(level.object.clone(), level.distance);
    }

    return this;
  },
  addLevel: function (object, distance) {
    if (distance === undefined) distance = 0;
    distance = Math.abs(distance);
    var levels = this.levels;

    for (var l = 0; l < levels.length; l++) {
      if (distance < levels[l].distance) {
        break;
      }
    }

    levels.splice(l, 0, {
      distance: distance,
      object: object
    });
    this.add(object);
    return this;
  },
  getObjectForDistance: function (distance) {
    var levels = this.levels;

    for (var i = 1, l = levels.length; i < l; i++) {
      if (distance < levels[i].distance) {
        break;
      }
    }

    return levels[i - 1].object;
  },
  raycast: function (raycaster, intersects) {
    _v1$4.setFromMatrixPosition(this.matrixWorld);

    var distance = raycaster.ray.origin.distanceTo(_v1$4);
    this.getObjectForDistance(distance).raycast(raycaster, intersects);
  },
  update: function (camera) {
    var levels = this.levels;

    if (levels.length > 1) {
      _v1$4.setFromMatrixPosition(camera.matrixWorld);

      _v2$2.setFromMatrixPosition(this.matrixWorld);

      var distance = _v1$4.distanceTo(_v2$2);

      levels[0].object.visible = true;

      for (var i = 1, l = levels.length; i < l; i++) {
        if (distance >= levels[i].distance) {
          levels[i - 1].object.visible = false;
          levels[i].object.visible = true;
        } else {
          break;
        }
      }

      for (; i < l; i++) {
        levels[i].object.visible = false;
      }
    }
  },
  toJSON: function (meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.levels = [];
    var levels = this.levels;

    for (var i = 0, l = levels.length; i < l; i++) {
      var level = levels[i];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance
      });
    }

    return data;
  }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function SkinnedMesh(geometry, material) {
  if (geometry && geometry.isGeometry) {
    console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
  }

  Mesh.call(this, geometry, material);
  this.type = 'SkinnedMesh';
  this.bindMode = 'attached';
  this.bindMatrix = new Matrix4();
  this.bindMatrixInverse = new Matrix4();
}

SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: SkinnedMesh,
  isSkinnedMesh: true,
  bind: function (skeleton, bindMatrix) {
    this.skeleton = skeleton;

    if (bindMatrix === undefined) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }

    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.getInverse(bindMatrix);
  },
  pose: function () {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function () {
    var vector = new Vector4();
    var skinWeight = this.geometry.attributes.skinWeight;

    for (var i = 0, l = skinWeight.count; i < l; i++) {
      vector.x = skinWeight.getX(i);
      vector.y = skinWeight.getY(i);
      vector.z = skinWeight.getZ(i);
      vector.w = skinWeight.getW(i);
      var scale = 1.0 / vector.manhattanLength();

      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0); // do something reasonable
      }

      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
    }
  },
  updateMatrixWorld: function (force) {
    Mesh.prototype.updateMatrixWorld.call(this, force);

    if (this.bindMode === 'attached') {
      this.bindMatrixInverse.getInverse(this.matrixWorld);
    } else if (this.bindMode === 'detached') {
      this.bindMatrixInverse.getInverse(this.bindMatrix);
    } else {
      console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
    }
  },
  clone: function () {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

var _offsetMatrix = new Matrix4();

var _identityMatrix = new Matrix4();

function Skeleton(bones, boneInverses) {
  // copy the bone array
  bones = bones || [];
  this.bones = bones.slice(0);
  this.boneMatrices = new Float32Array(this.bones.length * 16); // use the supplied bone inverses or calculate the inverses

  if (boneInverses === undefined) {
    this.calculateInverses();
  } else {
    if (this.bones.length === boneInverses.length) {
      this.boneInverses = boneInverses.slice(0);
    } else {
      console.warn('THREE.Skeleton boneInverses is the wrong length.');
      this.boneInverses = [];

      for (var i = 0, il = this.bones.length; i < il; i++) {
        this.boneInverses.push(new Matrix4());
      }
    }
  }
}

Object.assign(Skeleton.prototype, {
  calculateInverses: function () {
    this.boneInverses = [];

    for (var i = 0, il = this.bones.length; i < il; i++) {
      var inverse = new Matrix4();

      if (this.bones[i]) {
        inverse.getInverse(this.bones[i].matrixWorld);
      }

      this.boneInverses.push(inverse);
    }
  },
  pose: function () {
    var bone, i, il; // recover the bind-time world matrices

    for (i = 0, il = this.bones.length; i < il; i++) {
      bone = this.bones[i];

      if (bone) {
        bone.matrixWorld.getInverse(this.boneInverses[i]);
      }
    } // compute the local matrices, positions, rotations and scales


    for (i = 0, il = this.bones.length; i < il; i++) {
      bone = this.bones[i];

      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.getInverse(bone.parent.matrixWorld);
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }

        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  },
  update: function () {
    var bones = this.bones;
    var boneInverses = this.boneInverses;
    var boneMatrices = this.boneMatrices;
    var boneTexture = this.boneTexture; // flatten bone matrices to array

    for (var i = 0, il = bones.length; i < il; i++) {
      // compute the offset between the current and the original transform
      var matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;

      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);

      _offsetMatrix.toArray(boneMatrices, i * 16);
    }

    if (boneTexture !== undefined) {
      boneTexture.needsUpdate = true;
    }
  },
  clone: function () {
    return new Skeleton(this.bones, this.boneInverses);
  },
  getBoneByName: function (name) {
    for (var i = 0, il = this.bones.length; i < il; i++) {
      var bone = this.bones[i];

      if (bone.name === name) {
        return bone;
      }
    }

    return undefined;
  }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function Bone() {
  Object3D.call(this);
  this.type = 'Bone';
}

Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Bone,
  isBone: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

function LineBasicMaterial(parameters) {
  Material.call(this);
  this.type = 'LineBasicMaterial';
  this.color = new Color(0xffffff);
  this.linewidth = 1;
  this.linecap = 'round';
  this.linejoin = 'round';
  this.lights = false;
  this.setValues(parameters);
}

LineBasicMaterial.prototype = Object.create(Material.prototype);
LineBasicMaterial.prototype.constructor = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = true;

LineBasicMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.linewidth = source.linewidth;
  this.linecap = source.linecap;
  this.linejoin = source.linejoin;
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */


var _start = new Vector3();

var _end = new Vector3();

var _inverseMatrix$1 = new Matrix4();

var _ray$1 = new Ray();

var _sphere$2 = new Sphere();

function Line(geometry, material, mode) {
  if (mode === 1) {
    console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');
  }

  Object3D.call(this);
  this.type = 'Line';
  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  this.material = material !== undefined ? material : new LineBasicMaterial({
    color: Math.random() * 0xffffff
  });
}

Line.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Line,
  isLine: true,
  computeLineDistances: function () {
    var geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      // we assume non-indexed geometry
      if (geometry.index === null) {
        var positionAttribute = geometry.attributes.position;
        var lineDistances = [0];

        for (var i = 1, l = positionAttribute.count; i < l; i++) {
          _start.fromBufferAttribute(positionAttribute, i - 1);

          _end.fromBufferAttribute(positionAttribute, i);

          lineDistances[i] = lineDistances[i - 1];
          lineDistances[i] += _start.distanceTo(_end);
        }

        geometry.addAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
      }
    } else if (geometry.isGeometry) {
      var vertices = geometry.vertices;
      var lineDistances = geometry.lineDistances;
      lineDistances[0] = 0;

      for (var i = 1, l = vertices.length; i < l; i++) {
        lineDistances[i] = lineDistances[i - 1];
        lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);
      }
    }

    return this;
  },
  raycast: function (raycaster, intersects) {
    var precision = raycaster.linePrecision;
    var geometry = this.geometry;
    var matrixWorld = this.matrixWorld; // Checking boundingSphere distance to ray

    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

    _sphere$2.copy(geometry.boundingSphere);

    _sphere$2.applyMatrix4(matrixWorld);

    _sphere$2.radius += precision;
    if (raycaster.ray.intersectsSphere(_sphere$2) === false) return; //

    _inverseMatrix$1.getInverse(matrixWorld);

    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);

    var localPrecision = precision / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    var localPrecisionSq = localPrecision * localPrecision;
    var vStart = new Vector3();
    var vEnd = new Vector3();
    var interSegment = new Vector3();
    var interRay = new Vector3();
    var step = this && this.isLineSegments ? 2 : 1;

    if (geometry.isBufferGeometry) {
      var index = geometry.index;
      var attributes = geometry.attributes;
      var positions = attributes.position.array;

      if (index !== null) {
        var indices = index.array;

        for (var i = 0, l = indices.length - 1; i < l; i += step) {
          var a = indices[i];
          var b = indices[i + 1];
          vStart.fromArray(positions, a * 3);
          vEnd.fromArray(positions, b * 3);

          var distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

          if (distSq > localPrecisionSq) continue;
          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

          var distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far) continue;
          intersects.push({
            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
          vStart.fromArray(positions, 3 * i);
          vEnd.fromArray(positions, 3 * i + 3);

          var distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

          if (distSq > localPrecisionSq) continue;
          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

          var distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far) continue;
          intersects.push({
            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry.isGeometry) {
      var vertices = geometry.vertices;
      var nbVertices = vertices.length;

      for (var i = 0; i < nbVertices - 1; i += step) {
        var distSq = _ray$1.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);

        if (distSq > localPrecisionSq) continue;
        interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

        var distance = raycaster.ray.origin.distanceTo(interRay);
        if (distance < raycaster.near || distance > raycaster.far) continue;
        intersects.push({
          distance: distance,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: interSegment.clone().applyMatrix4(this.matrixWorld),
          index: i,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  },
  clone: function () {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

var _start$1 = new Vector3();

var _end$1 = new Vector3();

function LineSegments(geometry, material) {
  Line.call(this, geometry, material);
  this.type = 'LineSegments';
}

LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineSegments,
  isLineSegments: true,
  computeLineDistances: function () {
    var geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      // we assume non-indexed geometry
      if (geometry.index === null) {
        var positionAttribute = geometry.attributes.position;
        var lineDistances = [];

        for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
          _start$1.fromBufferAttribute(positionAttribute, i);

          _end$1.fromBufferAttribute(positionAttribute, i + 1);

          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
          lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
        }

        geometry.addAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
      }
    } else if (geometry.isGeometry) {
      var vertices = geometry.vertices;
      var lineDistances = geometry.lineDistances;

      for (var i = 0, l = vertices.length; i < l; i += 2) {
        _start$1.copy(vertices[i]);

        _end$1.copy(vertices[i + 1]);

        lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
        lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
      }
    }

    return this;
  }
});
/**
 * @author mgreter / http://github.com/mgreter
 */

function LineLoop(geometry, material) {
  Line.call(this, geometry, material);
  this.type = 'LineLoop';
}

LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineLoop,
  isLineLoop: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */

function PointsMaterial(parameters) {
  Material.call(this);
  this.type = 'PointsMaterial';
  this.color = new Color(0xffffff);
  this.map = null;
  this.size = 1;
  this.sizeAttenuation = true;
  this.morphTargets = false;
  this.lights = false;
  this.setValues(parameters);
}

PointsMaterial.prototype = Object.create(Material.prototype);
PointsMaterial.prototype.constructor = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;

PointsMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.size = source.size;
  this.sizeAttenuation = source.sizeAttenuation;
  this.morphTargets = source.morphTargets;
  return this;
};
/**
 * @author alteredq / http://alteredqualia.com/
 */


var _inverseMatrix$2 = new Matrix4();

var _ray$2 = new Ray();

var _sphere$3 = new Sphere();

var _position$1 = new Vector3();

function Points(geometry, material) {
  Object3D.call(this);
  this.type = 'Points';
  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  this.material = material !== undefined ? material : new PointsMaterial({
    color: Math.random() * 0xffffff
  });
  this.updateMorphTargets();
}

Points.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Points,
  isPoints: true,
  raycast: function (raycaster, intersects) {
    var geometry = this.geometry;
    var matrixWorld = this.matrixWorld;
    var threshold = raycaster.params.Points.threshold; // Checking boundingSphere distance to ray

    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

    _sphere$3.copy(geometry.boundingSphere);

    _sphere$3.applyMatrix4(matrixWorld);

    _sphere$3.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$3) === false) return; //

    _inverseMatrix$2.getInverse(matrixWorld);

    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);

    var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    var localThresholdSq = localThreshold * localThreshold;

    if (geometry.isBufferGeometry) {
      var index = geometry.index;
      var attributes = geometry.attributes;
      var positions = attributes.position.array;

      if (index !== null) {
        var indices = index.array;

        for (var i = 0, il = indices.length; i < il; i++) {
          var a = indices[i];

          _position$1.fromArray(positions, a * 3);

          testPoint(_position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      } else {
        for (var i = 0, l = positions.length / 3; i < l; i++) {
          _position$1.fromArray(positions, i * 3);

          testPoint(_position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      }
    } else {
      var vertices = geometry.vertices;

      for (var i = 0, l = vertices.length; i < l; i++) {
        testPoint(vertices[i], i, localThresholdSq, matrixWorld, raycaster, intersects, this);
      }
    }
  },
  updateMorphTargets: function () {
    var geometry = this.geometry;
    var m, ml, name;

    if (geometry.isBufferGeometry) {
      var morphAttributes = geometry.morphAttributes;
      var keys = Object.keys(morphAttributes);

      if (keys.length > 0) {
        var morphAttribute = morphAttributes[keys[0]];

        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};

          for (m = 0, ml = morphAttribute.length; m < ml; m++) {
            name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      var morphTargets = geometry.morphTargets;

      if (morphTargets !== undefined && morphTargets.length > 0) {
        console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  },
  clone: function () {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});

function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
  var rayPointDistanceSq = _ray$2.distanceSqToPoint(point);

  if (rayPointDistanceSq < localThresholdSq) {
    var intersectPoint = new Vector3();

    _ray$2.closestPointToPoint(point, intersectPoint);

    intersectPoint.applyMatrix4(matrixWorld);
    var distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects.push({
      distance: distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index: index,
      face: null,
      object: object
    });
  }
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.format = format !== undefined ? format : RGBFormat;
  this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
  this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
  this.generateMipmaps = false;
}

VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
  constructor: VideoTexture,
  isVideoTexture: true,
  update: function () {
    var video = this.image;

    if (video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */

function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.image = {
    width: width,
    height: height
  };
  this.mipmaps = mipmaps; // no flipping for cube textures
  // (also flipping doesn't work for compressed textures )

  this.flipY = false; // can't generate mipmaps for compressed textures
  // mips must be embedded in DDS files

  this.generateMipmaps = false;
}

CompressedTexture.prototype = Object.create(Texture.prototype);
CompressedTexture.prototype.constructor = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = true;
/**
 * @author mrdoob / http://mrdoob.com/
 */

function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.needsUpdate = true;
}

CanvasTexture.prototype = Object.create(Texture.prototype);
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;
/**
 * @author Matt DesLauriers / @mattdesl
 * @author atix / arthursilber.de
 */

function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
  format = format !== undefined ? format : DepthFormat;

  if (format !== DepthFormat && format !== DepthStencilFormat) {
    throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
  }

  if (type === undefined && format === DepthFormat) type = UnsignedShortType;
  if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.image = {
    width: width,
    height: height
  };
  this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
  this.flipY = false;
  this.generateMipmaps = false;
}

DepthTexture.prototype = Object.create(Texture.prototype);
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

function WireframeGeometry(geometry) {
  BufferGeometry.call(this);
  this.type = 'WireframeGeometry'; // buffer

  var vertices = []; // helper variables

  var i, j, l, o, ol;
  var edge = [0, 0],
      edges = {},
      e,
      edge1,
      edge2;
  var key,
      keys = ['a', 'b', 'c'];
  var vertex; // different logic for Geometry and BufferGeometry

  if (geometry && geometry.isGeometry) {
    // create a data structure that contains all edges without duplicates
    var faces = geometry.faces;

    for (i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];

      for (j = 0; j < 3; j++) {
        edge1 = face[keys[j]];
        edge2 = face[keys[(j + 1) % 3]];
        edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates

        edge[1] = Math.max(edge1, edge2);
        key = edge[0] + ',' + edge[1];

        if (edges[key] === undefined) {
          edges[key] = {
            index1: edge[0],
            index2: edge[1]
          };
        }
      }
    } // generate vertices


    for (key in edges) {
      e = edges[key];
      vertex = geometry.vertices[e.index1];
      vertices.push(vertex.x, vertex.y, vertex.z);
      vertex = geometry.vertices[e.index2];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  } else if (geometry && geometry.isBufferGeometry) {
    var position, indices, groups;
    var group, start, count;
    var index1, index2;
    vertex = new Vector3();

    if (geometry.index !== null) {
      // indexed BufferGeometry
      position = geometry.attributes.position;
      indices = geometry.index;
      groups = geometry.groups;

      if (groups.length === 0) {
        groups = [{
          start: 0,
          count: indices.count,
          materialIndex: 0
        }];
      } // create a data structure that contains all eges without duplicates


      for (o = 0, ol = groups.length; o < ol; ++o) {
        group = groups[o];
        start = group.start;
        count = group.count;

        for (i = start, l = start + count; i < l; i += 3) {
          for (j = 0; j < 3; j++) {
            edge1 = indices.getX(i + j);
            edge2 = indices.getX(i + (j + 1) % 3);
            edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates

            edge[1] = Math.max(edge1, edge2);
            key = edge[0] + ',' + edge[1];

            if (edges[key] === undefined) {
              edges[key] = {
                index1: edge[0],
                index2: edge[1]
              };
            }
          }
        }
      } // generate vertices


      for (key in edges) {
        e = edges[key];
        vertex.fromBufferAttribute(position, e.index1);
        vertices.push(vertex.x, vertex.y, vertex.z);
        vertex.fromBufferAttribute(position, e.index2);
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    } else {
      // non-indexed BufferGeometry
      position = geometry.attributes.position;

      for (i = 0, l = position.count / 3; i < l; i++) {
        for (j = 0; j < 3; j++) {
          // three edges per triangle, an edge is represented as (index1, index2)
          // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
          index1 = 3 * i + j;
          vertex.fromBufferAttribute(position, index1);
          vertices.push(vertex.x, vertex.y, vertex.z);
          index2 = 3 * i + (j + 1) % 3;
          vertex.fromBufferAttribute(position, index2);
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      }
    }
  } // build geometry


  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
}

WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
WireframeGeometry.prototype.constructor = WireframeGeometry;
/**
 * @author zz85 / https://github.com/zz85
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 */
// ParametricGeometry

function ParametricGeometry(func, slices, stacks) {
  Geometry.call(this);
  this.type = 'ParametricGeometry';
  this.parameters = {
    func: func,
    slices: slices,
    stacks: stacks
  };
  this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
  this.mergeVertices();
}

ParametricGeometry.prototype = Object.create(Geometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry; // ParametricBufferGeometry

function ParametricBufferGeometry(func, slices, stacks) {
  BufferGeometry.call(this);
  this.type = 'ParametricBufferGeometry';
  this.parameters = {
    func: func,
    slices: slices,
    stacks: stacks
  }; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var EPS = 0.00001;
  var normal = new Vector3();
  var p0 = new Vector3(),
      p1 = new Vector3();
  var pu = new Vector3(),
      pv = new Vector3();
  var i, j;

  if (func.length < 3) {
    console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
  } // generate vertices, normals and uvs


  var sliceCount = slices + 1;

  for (i = 0; i <= stacks; i++) {
    var v = i / stacks;

    for (j = 0; j <= slices; j++) {
      var u = j / slices; // vertex

      func(u, v, p0);
      vertices.push(p0.x, p0.y, p0.z); // normal
      // approximate tangent vectors via finite differences

      if (u - EPS >= 0) {
        func(u - EPS, v, p1);
        pu.subVectors(p0, p1);
      } else {
        func(u + EPS, v, p1);
        pu.subVectors(p1, p0);
      }

      if (v - EPS >= 0) {
        func(u, v - EPS, p1);
        pv.subVectors(p0, p1);
      } else {
        func(u, v + EPS, p1);
        pv.subVectors(p1, p0);
      } // cross product of tangent vectors returns surface normal


      normal.crossVectors(pu, pv).normalize();
      normals.push(normal.x, normal.y, normal.z); // uv

      uvs.push(u, v);
    }
  } // generate indices


  for (i = 0; i < stacks; i++) {
    for (j = 0; j < slices; j++) {
      var a = i * sliceCount + j;
      var b = i * sliceCount + j + 1;
      var c = (i + 1) * sliceCount + j + 1;
      var d = (i + 1) * sliceCount + j; // faces one and two

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */
// PolyhedronGeometry

function PolyhedronGeometry(vertices, indices, radius, detail) {
  Geometry.call(this);
  this.type = 'PolyhedronGeometry';
  this.parameters = {
    vertices: vertices,
    indices: indices,
    radius: radius,
    detail: detail
  };
  this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
  this.mergeVertices();
}

PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
PolyhedronGeometry.prototype.constructor = PolyhedronGeometry; // PolyhedronBufferGeometry

function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
  BufferGeometry.call(this);
  this.type = 'PolyhedronBufferGeometry';
  this.parameters = {
    vertices: vertices,
    indices: indices,
    radius: radius,
    detail: detail
  };
  radius = radius || 1;
  detail = detail || 0; // default buffer data

  var vertexBuffer = [];
  var uvBuffer = []; // the subdivision creates the vertex buffer data

  subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius

  applyRadius(radius); // finally, create the uv data

  generateUVs(); // build non-indexed geometry

  this.addAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
  this.addAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));

  if (detail === 0) {
    this.computeVertexNormals(); // flat normals
  } else {
    this.normalizeNormals(); // smooth normals
  } // helper functions


  function subdivide(detail) {
    var a = new Vector3();
    var b = new Vector3();
    var c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value

    for (var i = 0; i < indices.length; i += 3) {
      // get the vertices of the face
      getVertexByIndex(indices[i + 0], a);
      getVertexByIndex(indices[i + 1], b);
      getVertexByIndex(indices[i + 2], c); // perform subdivision

      subdivideFace(a, b, c, detail);
    }
  }

  function subdivideFace(a, b, c, detail) {
    var cols = Math.pow(2, detail); // we use this multidimensional array as a data structure for creating the subdivision

    var v = [];
    var i, j; // construct all of the vertices for this subdivision

    for (i = 0; i <= cols; i++) {
      v[i] = [];
      var aj = a.clone().lerp(c, i / cols);
      var bj = b.clone().lerp(c, i / cols);
      var rows = cols - i;

      for (j = 0; j <= rows; j++) {
        if (j === 0 && i === cols) {
          v[i][j] = aj;
        } else {
          v[i][j] = aj.clone().lerp(bj, j / rows);
        }
      }
    } // construct all of the faces


    for (i = 0; i < cols; i++) {
      for (j = 0; j < 2 * (cols - i) - 1; j++) {
        var k = Math.floor(j / 2);

        if (j % 2 === 0) {
          pushVertex(v[i][k + 1]);
          pushVertex(v[i + 1][k]);
          pushVertex(v[i][k]);
        } else {
          pushVertex(v[i][k + 1]);
          pushVertex(v[i + 1][k + 1]);
          pushVertex(v[i + 1][k]);
        }
      }
    }
  }

  function applyRadius(radius) {
    var vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex

    for (var i = 0; i < vertexBuffer.length; i += 3) {
      vertex.x = vertexBuffer[i + 0];
      vertex.y = vertexBuffer[i + 1];
      vertex.z = vertexBuffer[i + 2];
      vertex.normalize().multiplyScalar(radius);
      vertexBuffer[i + 0] = vertex.x;
      vertexBuffer[i + 1] = vertex.y;
      vertexBuffer[i + 2] = vertex.z;
    }
  }

  function generateUVs() {
    var vertex = new Vector3();

    for (var i = 0; i < vertexBuffer.length; i += 3) {
      vertex.x = vertexBuffer[i + 0];
      vertex.y = vertexBuffer[i + 1];
      vertex.z = vertexBuffer[i + 2];
      var u = azimuth(vertex) / 2 / Math.PI + 0.5;
      var v = inclination(vertex) / Math.PI + 0.5;
      uvBuffer.push(u, 1 - v);
    }

    correctUVs();
    correctSeam();
  }

  function correctSeam() {
    // handle case when face straddles the seam, see #3269
    for (var i = 0; i < uvBuffer.length; i += 6) {
      // uv data of a single face
      var x0 = uvBuffer[i + 0];
      var x1 = uvBuffer[i + 2];
      var x2 = uvBuffer[i + 4];
      var max = Math.max(x0, x1, x2);
      var min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary

      if (max > 0.9 && min < 0.1) {
        if (x0 < 0.2) uvBuffer[i + 0] += 1;
        if (x1 < 0.2) uvBuffer[i + 2] += 1;
        if (x2 < 0.2) uvBuffer[i + 4] += 1;
      }
    }
  }

  function pushVertex(vertex) {
    vertexBuffer.push(vertex.x, vertex.y, vertex.z);
  }

  function getVertexByIndex(index, vertex) {
    var stride = index * 3;
    vertex.x = vertices[stride + 0];
    vertex.y = vertices[stride + 1];
    vertex.z = vertices[stride + 2];
  }

  function correctUVs() {
    var a = new Vector3();
    var b = new Vector3();
    var c = new Vector3();
    var centroid = new Vector3();
    var uvA = new Vector2();
    var uvB = new Vector2();
    var uvC = new Vector2();

    for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
      a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
      b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
      c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
      uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
      uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
      uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
      centroid.copy(a).add(b).add(c).divideScalar(3);
      var azi = azimuth(centroid);
      correctUV(uvA, j + 0, a, azi);
      correctUV(uvB, j + 2, b, azi);
      correctUV(uvC, j + 4, c, azi);
    }
  }

  function correctUV(uv, stride, vector, azimuth) {
    if (azimuth < 0 && uv.x === 1) {
      uvBuffer[stride] = uv.x - 1;
    }

    if (vector.x === 0 && vector.z === 0) {
      uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
    }
  } // Angle around the Y axis, counter-clockwise when looking from above.


  function azimuth(vector) {
    return Math.atan2(vector.z, -vector.x);
  } // Angle above the XZ plane.


  function inclination(vector) {
    return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
  }
}

PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */
// TetrahedronGeometry

function TetrahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = 'TetrahedronGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
  this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}

TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
TetrahedronGeometry.prototype.constructor = TetrahedronGeometry; // TetrahedronBufferGeometry

function TetrahedronBufferGeometry(radius, detail) {
  var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
  var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = 'TetrahedronBufferGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
}

TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */
// OctahedronGeometry

function OctahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = 'OctahedronGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
  this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}

OctahedronGeometry.prototype = Object.create(Geometry.prototype);
OctahedronGeometry.prototype.constructor = OctahedronGeometry; // OctahedronBufferGeometry

function OctahedronBufferGeometry(radius, detail) {
  var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
  var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = 'OctahedronBufferGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
}

OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */
// IcosahedronGeometry

function IcosahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = 'IcosahedronGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
  this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}

IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
IcosahedronGeometry.prototype.constructor = IcosahedronGeometry; // IcosahedronBufferGeometry

function IcosahedronBufferGeometry(radius, detail) {
  var t = (1 + Math.sqrt(5)) / 2;
  var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
  var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = 'IcosahedronBufferGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
}

IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
/**
 * @author Abe Pazos / https://hamoid.com
 * @author Mugen87 / https://github.com/Mugen87
 */
// DodecahedronGeometry

function DodecahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = 'DodecahedronGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
  this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}

DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
DodecahedronGeometry.prototype.constructor = DodecahedronGeometry; // DodecahedronBufferGeometry

function DodecahedronBufferGeometry(radius, detail) {
  var t = (1 + Math.sqrt(5)) / 2;
  var r = 1 / t;
  var vertices = [// (±1, ±1, ±1)
  -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, ±1/φ, ±φ)
  0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (±1/φ, ±φ, 0)
  -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (±φ, 0, ±1/φ)
  -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
  var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = 'DodecahedronBufferGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
}

DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
/**
 * @author oosmoxiecode / https://github.com/oosmoxiecode
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 * @author Mugen87 / https://github.com/Mugen87
 *
 */
// TubeGeometry

function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
  Geometry.call(this);
  this.type = 'TubeGeometry';
  this.parameters = {
    path: path,
    tubularSegments: tubularSegments,
    radius: radius,
    radialSegments: radialSegments,
    closed: closed
  };
  if (taper !== undefined) console.warn('THREE.TubeGeometry: taper has been removed.');
  var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed); // expose internals

  this.tangents = bufferGeometry.tangents;
  this.normals = bufferGeometry.normals;
  this.binormals = bufferGeometry.binormals; // create geometry

  this.fromBufferGeometry(bufferGeometry);
  this.mergeVertices();
}

TubeGeometry.prototype = Object.create(Geometry.prototype);
TubeGeometry.prototype.constructor = TubeGeometry; // TubeBufferGeometry

function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
  BufferGeometry.call(this);
  this.type = 'TubeBufferGeometry';
  this.parameters = {
    path: path,
    tubularSegments: tubularSegments,
    radius: radius,
    radialSegments: radialSegments,
    closed: closed
  };
  tubularSegments = tubularSegments || 64;
  radius = radius || 1;
  radialSegments = radialSegments || 8;
  closed = closed || false;
  var frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals

  this.tangents = frames.tangents;
  this.normals = frames.normals;
  this.binormals = frames.binormals; // helper variables

  var vertex = new Vector3();
  var normal = new Vector3();
  var uv = new Vector2();
  var P = new Vector3();
  var i, j; // buffer

  var vertices = [];
  var normals = [];
  var uvs = [];
  var indices = []; // create buffer data

  generateBufferData(); // build geometry

  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions

  function generateBufferData() {
    for (i = 0; i < tubularSegments; i++) {
      generateSegment(i);
    } // if the geometry is not closed, generate the last row of vertices and normals
    // at the regular position on the given path
    //
    // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)


    generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.
    // this makes it easy compute correct values for closed geometries

    generateUVs(); // finally create faces

    generateIndices();
  }

  function generateSegment(i) {
    // we use getPointAt to sample evenly distributed points from the given path
    P = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal

    var N = frames.normals[i];
    var B = frames.binormals[i]; // generate normals and vertices for the current segment

    for (j = 0; j <= radialSegments; j++) {
      var v = j / radialSegments * Math.PI * 2;
      var sin = Math.sin(v);
      var cos = -Math.cos(v); // normal

      normal.x = cos * N.x + sin * B.x;
      normal.y = cos * N.y + sin * B.y;
      normal.z = cos * N.z + sin * B.z;
      normal.normalize();
      normals.push(normal.x, normal.y, normal.z); // vertex

      vertex.x = P.x + radius * normal.x;
      vertex.y = P.y + radius * normal.y;
      vertex.z = P.z + radius * normal.z;
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  }

  function generateIndices() {
    for (j = 1; j <= tubularSegments; j++) {
      for (i = 1; i <= radialSegments; i++) {
        var a = (radialSegments + 1) * (j - 1) + (i - 1);
        var b = (radialSegments + 1) * j + (i - 1);
        var c = (radialSegments + 1) * j + i;
        var d = (radialSegments + 1) * (j - 1) + i; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
  }

  function generateUVs() {
    for (i = 0; i <= tubularSegments; i++) {
      for (j = 0; j <= radialSegments; j++) {
        uv.x = i / tubularSegments;
        uv.y = j / radialSegments;
        uvs.push(uv.x, uv.y);
      }
    }
  }
}

TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

TubeBufferGeometry.prototype.toJSON = function () {
  var data = BufferGeometry.prototype.toJSON.call(this);
  data.path = this.parameters.path.toJSON();
  return data;
};
/**
 * @author oosmoxiecode
 * @author Mugen87 / https://github.com/Mugen87
 *
 * based on http://www.blackpawn.com/texts/pqtorus/
 */
// TorusKnotGeometry


function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
  Geometry.call(this);
  this.type = 'TorusKnotGeometry';
  this.parameters = {
    radius: radius,
    tube: tube,
    tubularSegments: tubularSegments,
    radialSegments: radialSegments,
    p: p,
    q: q
  };
  if (heightScale !== undefined) console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');
  this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
  this.mergeVertices();
}

TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
TorusKnotGeometry.prototype.constructor = TorusKnotGeometry; // TorusKnotBufferGeometry

function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
  BufferGeometry.call(this);
  this.type = 'TorusKnotBufferGeometry';
  this.parameters = {
    radius: radius,
    tube: tube,
    tubularSegments: tubularSegments,
    radialSegments: radialSegments,
    p: p,
    q: q
  };
  radius = radius || 1;
  tube = tube || 0.4;
  tubularSegments = Math.floor(tubularSegments) || 64;
  radialSegments = Math.floor(radialSegments) || 8;
  p = p || 2;
  q = q || 3; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // helper variables

  var i, j;
  var vertex = new Vector3();
  var normal = new Vector3();
  var P1 = new Vector3();
  var P2 = new Vector3();
  var B = new Vector3();
  var T = new Vector3();
  var N = new Vector3(); // generate vertices, normals and uvs

  for (i = 0; i <= tubularSegments; ++i) {
    // the radian "u" is used to calculate the position on the torus curve of the current tubular segement
    var u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
    // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

    calculatePositionOnCurve(u, p, q, radius, P1);
    calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis

    T.subVectors(P2, P1);
    N.addVectors(P2, P1);
    B.crossVectors(T, N);
    N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it

    B.normalize();
    N.normalize();

    for (j = 0; j <= radialSegments; ++j) {
      // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
      // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
      var v = j / radialSegments * Math.PI * 2;
      var cx = -tube * Math.cos(v);
      var cy = tube * Math.sin(v); // now calculate the final vertex position.
      // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

      vertex.x = P1.x + (cx * N.x + cy * B.x);
      vertex.y = P1.y + (cx * N.y + cy * B.y);
      vertex.z = P1.z + (cx * N.z + cy * B.z);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

      normal.subVectors(vertex, P1).normalize();
      normals.push(normal.x, normal.y, normal.z); // uv

      uvs.push(i / tubularSegments);
      uvs.push(j / radialSegments);
    }
  } // generate indices


  for (j = 1; j <= tubularSegments; j++) {
    for (i = 1; i <= radialSegments; i++) {
      // indices
      var a = (radialSegments + 1) * (j - 1) + (i - 1);
      var b = (radialSegments + 1) * j + (i - 1);
      var c = (radialSegments + 1) * j + i;
      var d = (radialSegments + 1) * (j - 1) + i; // faces

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve

  function calculatePositionOnCurve(u, p, q, radius, position) {
    var cu = Math.cos(u);
    var su = Math.sin(u);
    var quOverP = q / p * u;
    var cs = Math.cos(quOverP);
    position.x = radius * (2 + cs) * 0.5 * cu;
    position.y = radius * (2 + cs) * su * 0.5;
    position.z = radius * Math.sin(quOverP) * 0.5;
  }
}

TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */
// TorusGeometry

function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
  Geometry.call(this);
  this.type = 'TorusGeometry';
  this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    arc: arc
  };
  this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
  this.mergeVertices();
}

TorusGeometry.prototype = Object.create(Geometry.prototype);
TorusGeometry.prototype.constructor = TorusGeometry; // TorusBufferGeometry

function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
  BufferGeometry.call(this);
  this.type = 'TorusBufferGeometry';
  this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    arc: arc
  };
  radius = radius || 1;
  tube = tube || 0.4;
  radialSegments = Math.floor(radialSegments) || 8;
  tubularSegments = Math.floor(tubularSegments) || 6;
  arc = arc || Math.PI * 2; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // helper variables

  var center = new Vector3();
  var vertex = new Vector3();
  var normal = new Vector3();
  var j, i; // generate vertices, normals and uvs

  for (j = 0; j <= radialSegments; j++) {
    for (i = 0; i <= tubularSegments; i++) {
      var u = i / tubularSegments * arc;
      var v = j / radialSegments * Math.PI * 2; // vertex

      vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
      vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
      vertex.z = tube * Math.sin(v);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      center.x = radius * Math.cos(u);
      center.y = radius * Math.sin(u);
      normal.subVectors(vertex, center).normalize();
      normals.push(normal.x, normal.y, normal.z); // uv

      uvs.push(i / tubularSegments);
      uvs.push(j / radialSegments);
    }
  } // generate indices


  for (j = 1; j <= radialSegments; j++) {
    for (i = 1; i <= tubularSegments; i++) {
      // indices
      var a = (tubularSegments + 1) * j + i - 1;
      var b = (tubularSegments + 1) * (j - 1) + i - 1;
      var c = (tubularSegments + 1) * (j - 1) + i;
      var d = (tubularSegments + 1) * j + i; // faces

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
/**
 * @author Mugen87 / https://github.com/Mugen87
 * Port from https://github.com/mapbox/earcut (v2.1.5)
 */

var Earcut = {
  triangulate: function (data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];

      for (var i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      } // minX, minY and invSize are later used to transform coords into integers for z-order calculation


      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
}; // create a circular doubly linked list from polygon points in the specified winding order

function linkedList(data, start, end, dim, clockwise) {
  var i, last;

  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }

  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }

  return last;
} // eliminate colinear or duplicate points


function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  var p = start,
      again;

  do {
    again = false;

    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);

  return end;
} // main ear slicing loop which triangulates a polygon (given as a linked list)


function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return; // interlink polygon nodes in z-order

  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  var stop = ear,
      prev,
      next; // iterate through ears, slicing them one by one

  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;

    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      // cut off the triangle
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear); // skipping the next vertex leads to less sliver triangles

      ear = next.next;
      stop = next.next;
      continue;
    }

    ear = next; // if we looped through the whole remaining polygon and can't find any more ears

    if (ear === stop) {
      // try filtering points and slicing again
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
      } else if (pass === 1) {
        ear = cureLocalIntersections(ear, triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }

      break;
    }
  }
} // check whether a polygon node forms a valid ear with adjacent nodes


function isEar(ear) {
  var a = ear.prev,
      b = ear,
      c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // now make sure we don't have other points inside the potential ear

  var p = ear.next.next;

  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }

  return true;
}

function isEarHashed(ear, minX, minY, invSize) {
  var a = ear.prev,
      b = ear,
      c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // triangle bbox; min & max are calculated like this for speed

  var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
      minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
      maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
      maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;

  var minZ = zOrder(minTX, minTY, minX, minY, invSize),
      maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  var p = ear.prevZ,
      n = ear.nextZ; // look for points inside the triangle in both directions

  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  } // look for remaining points in decreasing z-order


  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  } // look for remaining points in increasing z-order


  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }

  return true;
} // go through all polygon nodes and cure small local self-intersections


function cureLocalIntersections(start, triangles, dim) {
  var p = start;

  do {
    var a = p.prev,
        b = p.next.next;

    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim); // remove two nodes involved

      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }

    p = p.next;
  } while (p !== start);

  return p;
} // try splitting polygon into two and triangulate them independently


function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  // look for a valid diagonal that divides the polygon into two
  var a = start;

  do {
    var b = a.next.next;

    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        // split the polygon in two by the diagonal
        var c = splitPolygon(a, b); // filter colinear points around the cuts

        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next); // run earcut on each half

        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }

      b = b.next;
    }

    a = a.next;
  } while (a !== start);
} // link every hole into the outer loop, producing a single-ring polygon without holes


function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [],
      i,
      len,
      start,
      end,
      list;

  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }

  queue.sort(compareX); // process holes from left to right

  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }

  return outerNode;
}

function compareX(a, b) {
  return a.x - b.x;
} // find a bridge between vertices that connects hole with an outer ring and and link it


function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);

  if (outerNode) {
    var b = splitPolygon(outerNode, hole);
    filterPoints(b, b.next);
  }
} // David Eberly's algorithm for finding a bridge between hole and outer polygon


function findHoleBridge(hole, outerNode) {
  var p = outerNode,
      hx = hole.x,
      hy = hole.y,
      qx = -Infinity,
      m; // find a segment intersected by a ray from the hole's leftmost point to the left;
  // segment's endpoint with lesser x will be potential connection point

  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

      if (x <= hx && x > qx) {
        qx = x;

        if (x === hx) {
          if (hy === p.y) return p;
          if (hy === p.next.y) return p.next;
        }

        m = p.x < p.next.x ? p : p.next;
      }
    }

    p = p.next;
  } while (p !== outerNode);

  if (!m) return null;
  if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint
  // look for points inside the triangle of hole point, segment intersection and endpoint;
  // if there are no points found, we have a valid connection;
  // otherwise choose the point of the minimum angle with the ray as connection point

  var stop = m,
      mx = m.x,
      my = m.y,
      tanMin = Infinity,
      tan;
  p = m.next;

  while (p !== stop) {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

      if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
        m = p;
        tanMin = tan;
      }
    }

    p = p.next;
  }

  return m;
} // interlink polygon nodes in z-order


function indexCurve(start, minX, minY, invSize) {
  var p = start;

  do {
    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);

  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
} // Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


function sortLinked(list) {
  var i,
      p,
      q,
      e,
      tail,
      numMerges,
      pSize,
      qSize,
      inSize = 1;

  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;

    while (p) {
      numMerges++;
      q = p;
      pSize = 0;

      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }

      qSize = inSize;

      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }

        if (tail) tail.nextZ = e;else list = e;
        e.prevZ = tail;
        tail = e;
      }

      p = q;
    }

    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);

  return list;
} // z-order of a point given coords and inverse of the longer side of data bbox


function zOrder(x, y, minX, minY, invSize) {
  // coords are transformed into non-negative 15-bit integer range
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 0x00FF00FF;
  x = (x | x << 4) & 0x0F0F0F0F;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y = (y | y << 8) & 0x00FF00FF;
  y = (y | y << 4) & 0x0F0F0F0F;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
} // find the leftmost node of a polygon ring


function getLeftmost(start) {
  var p = start,
      leftmost = start;

  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);

  return leftmost;
} // check if a point lies within a convex triangle


function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
} // signed area of a triangle


function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
} // check if two points are equal


function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
} // check if two segments intersect


function intersects(p1, q1, p2, q2) {
  if (equals(p1, p2) && equals(q1, q2) || equals(p1, q2) && equals(p2, q1)) return true;
  return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
} // check if a polygon diagonal intersects any polygon segments


function intersectsPolygon(a, b) {
  var p = a;

  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);

  return false;
} // check if a polygon diagonal is locally inside the polygon


function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
} // check if the middle point of a polygon diagonal is inside the polygon


function middleInside(a, b) {
  var p = a,
      inside = false,
      px = (a.x + b.x) / 2,
      py = (a.y + b.y) / 2;

  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
    p = p.next;
  } while (p !== a);

  return inside;
} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring


function splitPolygon(a, b) {
  var a2 = new Node(a.i, a.x, a.y),
      b2 = new Node(b.i, b.x, b.y),
      an = a.next,
      bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
} // create a node and optionally link it with previous one (in a circular doubly linked list)


function insertNode(i, x, y, last) {
  var p = new Node(i, x, y);

  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }

  return p;
}

function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
  // vertex index in coordinates array
  this.i = i; // vertex coordinates

  this.x = x;
  this.y = y; // previous and next vertex nodes in a polygon ring

  this.prev = null;
  this.next = null; // z-order curve value

  this.z = null; // previous and next nodes in z-order

  this.prevZ = null;
  this.nextZ = null; // indicates whether this is a steiner point

  this.steiner = false;
}

function signedArea(data, start, end, dim) {
  var sum = 0;

  for (var i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }

  return sum;
}
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */


var ShapeUtils = {
  // calculate area of the contour polygon
  area: function (contour) {
    var n = contour.length;
    var a = 0.0;

    for (var p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }

    return a * 0.5;
  },
  isClockWise: function (pts) {
    return ShapeUtils.area(pts) < 0;
  },
  triangulateShape: function (contour, holes) {
    var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]

    var holeIndices = []; // array of hole indices

    var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

    removeDupEndPts(contour);
    addContour(vertices, contour); //

    var holeIndex = contour.length;
    holes.forEach(removeDupEndPts);

    for (var i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    } //


    var triangles = Earcut.triangulate(vertices, holeIndices); //

    for (var i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }

    return faces;
  }
};
exports.ShapeUtils = ShapeUtils;

function removeDupEndPts(points) {
  var l = points.length;

  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}

function addContour(vertices, contour) {
  for (var i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */
// ExtrudeGeometry


function ExtrudeGeometry(shapes, options) {
  Geometry.call(this);
  this.type = 'ExtrudeGeometry';
  this.parameters = {
    shapes: shapes,
    options: options
  };
  this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
  this.mergeVertices();
}

ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

ExtrudeGeometry.prototype.toJSON = function () {
  var data = Geometry.prototype.toJSON.call(this);
  var shapes = this.parameters.shapes;
  var options = this.parameters.options;
  return toJSON(shapes, options, data);
}; // ExtrudeBufferGeometry


function ExtrudeBufferGeometry(shapes, options) {
  BufferGeometry.call(this);
  this.type = 'ExtrudeBufferGeometry';
  this.parameters = {
    shapes: shapes,
    options: options
  };
  shapes = Array.isArray(shapes) ? shapes : [shapes];
  var scope = this;
  var verticesArray = [];
  var uvArray = [];

  for (var i = 0, l = shapes.length; i < l; i++) {
    var shape = shapes[i];
    addShape(shape);
  } // build geometry


  this.addAttribute('position', new Float32BufferAttribute(verticesArray, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvArray, 2));
  this.computeVertexNormals(); // functions

  function addShape(shape) {
    var placeholder = []; // options

    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
    var steps = options.steps !== undefined ? options.steps : 1;
    var depth = options.depth !== undefined ? options.depth : 100;
    var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
    var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
    var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
    var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
    var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
    var extrudePath = options.extrudePath;
    var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options

    if (options.amount !== undefined) {
      console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
      depth = options.amount;
    } //


    var extrudePts,
        extrudeByPath = false;
    var splineTube, binormal, normal, position2;

    if (extrudePath) {
      extrudePts = extrudePath.getSpacedPoints(steps);
      extrudeByPath = true;
      bevelEnabled = false; // bevels not supported for path extrusion
      // SETUP TNB variables
      // TODO1 - have a .isClosed in spline?

      splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

      binormal = new Vector3();
      normal = new Vector3();
      position2 = new Vector3();
    } // Safeguards if bevels are not enabled


    if (!bevelEnabled) {
      bevelSegments = 0;
      bevelThickness = 0;
      bevelSize = 0;
      bevelOffset = 0;
    } // Variables initialization


    var ahole, h, hl; // looping of holes

    var shapePoints = shape.extractPoints(curveSegments);
    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;
    var reverse = !ShapeUtils.isClockWise(vertices);

    if (reverse) {
      vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...

      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];

        if (ShapeUtils.isClockWise(ahole)) {
          holes[h] = ahole.reverse();
        }
      }
    }

    var faces = ShapeUtils.triangulateShape(vertices, holes);
    /* Vertices */

    var contour = vertices; // vertices has all points but contour has only points of circumference

    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      vertices = vertices.concat(ahole);
    }

    function scalePt2(pt, vec, size) {
      if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
      return vec.clone().multiplyScalar(size).add(pt);
    }

    var b,
        bs,
        t,
        z,
        vert,
        vlen = vertices.length,
        face,
        flen = faces.length; // Find directions for point movement

    function getBevelVec(inPt, inPrev, inNext) {
      // computes for inPt the corresponding point inPt' on a new contour
      //   shifted by 1 unit (length of normalized vector) to the left
      // if we walk along contour clockwise, this new contour is outside the old one
      //
      // inPt' is the intersection of the two lines parallel to the two
      //  adjacent edges of inPt at a distance of 1 unit on the left side.
      var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
      // good reading for geometry algorithms (here: line-line intersection)
      // http://geomalgorithms.com/a05-_intersect-1.html

      var v_prev_x = inPt.x - inPrev.x,
          v_prev_y = inPt.y - inPrev.y;
      var v_next_x = inNext.x - inPt.x,
          v_next_y = inNext.y - inPt.y;
      var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges

      var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

      if (Math.abs(collinear0) > Number.EPSILON) {
        // not collinear
        // length of vectors for normalizing
        var v_prev_len = Math.sqrt(v_prev_lensq);
        var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left

        var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
        var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
        var ptNextShift_x = inNext.x - v_next_y / v_next_len;
        var ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point

        var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point

        v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
        v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly
        //  but prevent crazy spikes

        var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;

        if (v_trans_lensq <= 2) {
          return new Vector2(v_trans_x, v_trans_y);
        } else {
          shrink_by = Math.sqrt(v_trans_lensq / 2);
        }
      } else {
        // handle special case of collinear edges
        var direction_eq = false; // assumes: opposite

        if (v_prev_x > Number.EPSILON) {
          if (v_next_x > Number.EPSILON) {
            direction_eq = true;
          }
        } else {
          if (v_prev_x < -Number.EPSILON) {
            if (v_next_x < -Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
              direction_eq = true;
            }
          }
        }

        if (direction_eq) {
          // console.log("Warning: lines are a straight sequence");
          v_trans_x = -v_prev_y;
          v_trans_y = v_prev_x;
          shrink_by = Math.sqrt(v_prev_lensq);
        } else {
          // console.log("Warning: lines are a straight spike");
          v_trans_x = v_prev_x;
          v_trans_y = v_prev_y;
          shrink_by = Math.sqrt(v_prev_lensq / 2);
        }
      }

      return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
    }

    var contourMovements = [];

    for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
      if (j === il) j = 0;
      if (k === il) k = 0; //  (j)---(i)---(k)
      // console.log('i,j,k', i, j , k)

      contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
    }

    var holesMovements = [],
        oneHoleMovements,
        verticesMovements = contourMovements.concat();

    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      oneHoleMovements = [];

      for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il) j = 0;
        if (k === il) k = 0; //  (j)---(i)---(k)

        oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
      }

      holesMovements.push(oneHoleMovements);
      verticesMovements = verticesMovements.concat(oneHoleMovements);
    } // Loop bevelSegments, 1 for the front, 1 for the back


    for (b = 0; b < bevelSegments; b++) {
      //for ( b = bevelSegments; b > 0; b -- ) {
      t = b / bevelSegments;
      z = bevelThickness * Math.cos(t * Math.PI / 2);
      bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

      for (i = 0, il = contour.length; i < il; i++) {
        vert = scalePt2(contour[i], contourMovements[i], bs);
        v(vert.x, vert.y, -z);
      } // expand holes


      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = holesMovements[h];

        for (i = 0, il = ahole.length; i < il; i++) {
          vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
          v(vert.x, vert.y, -z);
        }
      }
    }

    bs = bevelSize + bevelOffset; // Back facing vertices

    for (i = 0; i < vlen; i++) {
      vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

      if (!extrudeByPath) {
        v(vert.x, vert.y, 0);
      } else {
        // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
        normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
        binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
        position2.copy(extrudePts[0]).add(normal).add(binormal);
        v(position2.x, position2.y, position2.z);
      }
    } // Add stepped vertices...
    // Including front facing vertices


    var s;

    for (s = 1; s <= steps; s++) {
      for (i = 0; i < vlen; i++) {
        vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

        if (!extrudeByPath) {
          v(vert.x, vert.y, depth / steps * s);
        } else {
          // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
          normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
          position2.copy(extrudePts[s]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
    } // Add bevel segments planes
    //for ( b = 1; b <= bevelSegments; b ++ ) {


    for (b = bevelSegments - 1; b >= 0; b--) {
      t = b / bevelSegments;
      z = bevelThickness * Math.cos(t * Math.PI / 2);
      bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

      for (i = 0, il = contour.length; i < il; i++) {
        vert = scalePt2(contour[i], contourMovements[i], bs);
        v(vert.x, vert.y, depth + z);
      } // expand holes


      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = holesMovements[h];

        for (i = 0, il = ahole.length; i < il; i++) {
          vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

          if (!extrudeByPath) {
            v(vert.x, vert.y, depth + z);
          } else {
            v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
          }
        }
      }
    }
    /* Faces */
    // Top and bottom faces


    buildLidFaces(); // Sides faces

    buildSideFaces(); /////  Internal functions

    function buildLidFaces() {
      var start = verticesArray.length / 3;

      if (bevelEnabled) {
        var layer = 0; // steps + 1

        var offset = vlen * layer; // Bottom faces

        for (i = 0; i < flen; i++) {
          face = faces[i];
          f3(face[2] + offset, face[1] + offset, face[0] + offset);
        }

        layer = steps + bevelSegments * 2;
        offset = vlen * layer; // Top faces

        for (i = 0; i < flen; i++) {
          face = faces[i];
          f3(face[0] + offset, face[1] + offset, face[2] + offset);
        }
      } else {
        // Bottom faces
        for (i = 0; i < flen; i++) {
          face = faces[i];
          f3(face[2], face[1], face[0]);
        } // Top faces


        for (i = 0; i < flen; i++) {
          face = faces[i];
          f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
        }
      }

      scope.addGroup(start, verticesArray.length / 3 - start, 0);
    } // Create faces for the z-sides of the shape


    function buildSideFaces() {
      var start = verticesArray.length / 3;
      var layeroffset = 0;
      sidewalls(contour, layeroffset);
      layeroffset += contour.length;

      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        sidewalls(ahole, layeroffset); //, true

        layeroffset += ahole.length;
      }

      scope.addGroup(start, verticesArray.length / 3 - start, 1);
    }

    function sidewalls(contour, layeroffset) {
      var j, k;
      i = contour.length;

      while (--i >= 0) {
        j = i;
        k = i - 1;
        if (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);

        var s = 0,
            sl = steps + bevelSegments * 2;

        for (s = 0; s < sl; s++) {
          var slen1 = vlen * s;
          var slen2 = vlen * (s + 1);
          var a = layeroffset + j + slen1,
              b = layeroffset + k + slen1,
              c = layeroffset + k + slen2,
              d = layeroffset + j + slen2;
          f4(a, b, c, d);
        }
      }
    }

    function v(x, y, z) {
      placeholder.push(x);
      placeholder.push(y);
      placeholder.push(z);
    }

    function f3(a, b, c) {
      addVertex(a);
      addVertex(b);
      addVertex(c);
      var nextIndex = verticesArray.length / 3;
      var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
      addUV(uvs[0]);
      addUV(uvs[1]);
      addUV(uvs[2]);
    }

    function f4(a, b, c, d) {
      addVertex(a);
      addVertex(b);
      addVertex(d);
      addVertex(b);
      addVertex(c);
      addVertex(d);
      var nextIndex = verticesArray.length / 3;
      var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
      addUV(uvs[0]);
      addUV(uvs[1]);
      addUV(uvs[3]);
      addUV(uvs[1]);
      addUV(uvs[2]);
      addUV(uvs[3]);
    }

    function addVertex(index) {
      verticesArray.push(placeholder[index * 3 + 0]);
      verticesArray.push(placeholder[index * 3 + 1]);
      verticesArray.push(placeholder[index * 3 + 2]);
    }

    function addUV(vector2) {
      uvArray.push(vector2.x);
      uvArray.push(vector2.y);
    }
  }
}

ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

ExtrudeBufferGeometry.prototype.toJSON = function () {
  var data = BufferGeometry.prototype.toJSON.call(this);
  var shapes = this.parameters.shapes;
  var options = this.parameters.options;
  return toJSON(shapes, options, data);
}; //


var WorldUVGenerator = {
  generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
    var a_x = vertices[indexA * 3];
    var a_y = vertices[indexA * 3 + 1];
    var b_x = vertices[indexB * 3];
    var b_y = vertices[indexB * 3 + 1];
    var c_x = vertices[indexC * 3];
    var c_y = vertices[indexC * 3 + 1];
    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
  },
  generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
    var a_x = vertices[indexA * 3];
    var a_y = vertices[indexA * 3 + 1];
    var a_z = vertices[indexA * 3 + 2];
    var b_x = vertices[indexB * 3];
    var b_y = vertices[indexB * 3 + 1];
    var b_z = vertices[indexB * 3 + 2];
    var c_x = vertices[indexC * 3];
    var c_y = vertices[indexC * 3 + 1];
    var c_z = vertices[indexC * 3 + 2];
    var d_x = vertices[indexD * 3];
    var d_y = vertices[indexD * 3 + 1];
    var d_z = vertices[indexD * 3 + 2];

    if (Math.abs(a_y - b_y) < 0.01) {
      return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
    } else {
      return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
    }
  }
};

function toJSON(shapes, options, data) {
  //
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (var i = 0, l = shapes.length; i < l; i++) {
      var shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  } //


  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */
// TextGeometry


function TextGeometry(text, parameters) {
  Geometry.call(this);
  this.type = 'TextGeometry';
  this.parameters = {
    text: text,
    parameters: parameters
  };
  this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
  this.mergeVertices();
}

TextGeometry.prototype = Object.create(Geometry.prototype);
TextGeometry.prototype.constructor = TextGeometry; // TextBufferGeometry

function TextBufferGeometry(text, parameters) {
  parameters = parameters || {};
  var font = parameters.font;

  if (!(font && font.isFont)) {
    console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
    return new Geometry();
  }

  var shapes = font.generateShapes(text, parameters.size); // translate parameters to ExtrudeGeometry API

  parameters.depth = parameters.height !== undefined ? parameters.height : 50; // defaults

  if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
  if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
  if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
  ExtrudeBufferGeometry.call(this, shapes, parameters);
  this.type = 'TextBufferGeometry';
}

TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
TextBufferGeometry.prototype.constructor = TextBufferGeometry;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 */
// SphereGeometry

function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = 'SphereGeometry';
  this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
  this.mergeVertices();
}

SphereGeometry.prototype = Object.create(Geometry.prototype);
SphereGeometry.prototype.constructor = SphereGeometry; // SphereBufferGeometry

function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = 'SphereBufferGeometry';
  this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  radius = radius || 1;
  widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
  heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
  phiStart = phiStart !== undefined ? phiStart : 0;
  phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
  var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
  var ix, iy;
  var index = 0;
  var grid = [];
  var vertex = new Vector3();
  var normal = new Vector3(); // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // generate vertices, normals and uvs

  for (iy = 0; iy <= heightSegments; iy++) {
    var verticesRow = [];
    var v = iy / heightSegments; // special case for the poles

    var uOffset = 0;

    if (iy == 0 && thetaStart == 0) {
      uOffset = 0.5 / widthSegments;
    } else if (iy == heightSegments && thetaEnd == Math.PI) {
      uOffset = -0.5 / widthSegments;
    }

    for (ix = 0; ix <= widthSegments; ix++) {
      var u = ix / widthSegments; // vertex

      vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
      vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      normal.copy(vertex).normalize();
      normals.push(normal.x, normal.y, normal.z); // uv

      uvs.push(u + uOffset, 1 - v);
      verticesRow.push(index++);
    }

    grid.push(verticesRow);
  } // indices


  for (iy = 0; iy < heightSegments; iy++) {
    for (ix = 0; ix < widthSegments; ix++) {
      var a = grid[iy][ix + 1];
      var b = grid[iy][ix];
      var c = grid[iy + 1][ix];
      var d = grid[iy + 1][ix + 1];
      if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
      if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
/**
 * @author Kaleb Murphy
 * @author Mugen87 / https://github.com/Mugen87
 */
// RingGeometry

function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = 'RingGeometry';
  this.parameters = {
    innerRadius: innerRadius,
    outerRadius: outerRadius,
    thetaSegments: thetaSegments,
    phiSegments: phiSegments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
  this.mergeVertices();
}

RingGeometry.prototype = Object.create(Geometry.prototype);
RingGeometry.prototype.constructor = RingGeometry; // RingBufferGeometry

function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = 'RingBufferGeometry';
  this.parameters = {
    innerRadius: innerRadius,
    outerRadius: outerRadius,
    thetaSegments: thetaSegments,
    phiSegments: phiSegments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  innerRadius = innerRadius || 0.5;
  outerRadius = outerRadius || 1;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
  thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
  phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // some helper variables

  var segment;
  var radius = innerRadius;
  var radiusStep = (outerRadius - innerRadius) / phiSegments;
  var vertex = new Vector3();
  var uv = new Vector2();
  var j, i; // generate vertices, normals and uvs

  for (j = 0; j <= phiSegments; j++) {
    for (i = 0; i <= thetaSegments; i++) {
      // values are generate from the inside of the ring to the outside
      segment = thetaStart + i / thetaSegments * thetaLength; // vertex

      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      normals.push(0, 0, 1); // uv

      uv.x = (vertex.x / outerRadius + 1) / 2;
      uv.y = (vertex.y / outerRadius + 1) / 2;
      uvs.push(uv.x, uv.y);
    } // increase the radius for next row of vertices


    radius += radiusStep;
  } // indices


  for (j = 0; j < phiSegments; j++) {
    var thetaSegmentLevel = j * (thetaSegments + 1);

    for (i = 0; i < thetaSegments; i++) {
      segment = i + thetaSegmentLevel;
      var a = segment;
      var b = segment + thetaSegments + 1;
      var c = segment + thetaSegments + 2;
      var d = segment + 1; // faces

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
RingBufferGeometry.prototype.constructor = RingBufferGeometry;
/**
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 * @author Mugen87 / https://github.com/Mugen87
 */
// LatheGeometry

function LatheGeometry(points, segments, phiStart, phiLength) {
  Geometry.call(this);
  this.type = 'LatheGeometry';
  this.parameters = {
    points: points,
    segments: segments,
    phiStart: phiStart,
    phiLength: phiLength
  };
  this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
  this.mergeVertices();
}

LatheGeometry.prototype = Object.create(Geometry.prototype);
LatheGeometry.prototype.constructor = LatheGeometry; // LatheBufferGeometry

function LatheBufferGeometry(points, segments, phiStart, phiLength) {
  BufferGeometry.call(this);
  this.type = 'LatheBufferGeometry';
  this.parameters = {
    points: points,
    segments: segments,
    phiStart: phiStart,
    phiLength: phiLength
  };
  segments = Math.floor(segments) || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || Math.PI * 2; // clamp phiLength so it's in range of [ 0, 2PI ]

  phiLength = _Math.clamp(phiLength, 0, Math.PI * 2); // buffers

  var indices = [];
  var vertices = [];
  var uvs = []; // helper variables

  var base;
  var inverseSegments = 1.0 / segments;
  var vertex = new Vector3();
  var uv = new Vector2();
  var i, j; // generate vertices and uvs

  for (i = 0; i <= segments; i++) {
    var phi = phiStart + i * inverseSegments * phiLength;
    var sin = Math.sin(phi);
    var cos = Math.cos(phi);

    for (j = 0; j <= points.length - 1; j++) {
      // vertex
      vertex.x = points[j].x * sin;
      vertex.y = points[j].y;
      vertex.z = points[j].x * cos;
      vertices.push(vertex.x, vertex.y, vertex.z); // uv

      uv.x = i / segments;
      uv.y = j / (points.length - 1);
      uvs.push(uv.x, uv.y);
    }
  } // indices


  for (i = 0; i < segments; i++) {
    for (j = 0; j < points.length - 1; j++) {
      base = j + i * points.length;
      var a = base;
      var b = base + points.length;
      var c = base + points.length + 1;
      var d = base + 1; // faces

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals

  this.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.
  // because the corresponding vertices are identical (but still have different UVs).

  if (phiLength === Math.PI * 2) {
    var normals = this.attributes.normal.array;
    var n1 = new Vector3();
    var n2 = new Vector3();
    var n = new Vector3(); // this is the buffer offset for the last line of vertices

    base = segments * points.length * 3;

    for (i = 0, j = 0; i < points.length; i++, j += 3) {
      // select the normal of the vertex in the first line
      n1.x = normals[j + 0];
      n1.y = normals[j + 1];
      n1.z = normals[j + 2]; // select the normal of the vertex in the last line

      n2.x = normals[base + j + 0];
      n2.y = normals[base + j + 1];
      n2.z = normals[base + j + 2]; // average normals

      n.addVectors(n1, n2).normalize(); // assign the new values to both normals

      normals[j + 0] = normals[base + j + 0] = n.x;
      normals[j + 1] = normals[base + j + 1] = n.y;
      normals[j + 2] = normals[base + j + 2] = n.z;
    }
  }
}

LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
/**
 * @author jonobr1 / http://jonobr1.com
 * @author Mugen87 / https://github.com/Mugen87
 */
// ShapeGeometry

function ShapeGeometry(shapes, curveSegments) {
  Geometry.call(this);
  this.type = 'ShapeGeometry';

  if (typeof curveSegments === 'object') {
    console.warn('THREE.ShapeGeometry: Options parameter has been removed.');
    curveSegments = curveSegments.curveSegments;
  }

  this.parameters = {
    shapes: shapes,
    curveSegments: curveSegments
  };
  this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
  this.mergeVertices();
}

ShapeGeometry.prototype = Object.create(Geometry.prototype);
ShapeGeometry.prototype.constructor = ShapeGeometry;

ShapeGeometry.prototype.toJSON = function () {
  var data = Geometry.prototype.toJSON.call(this);
  var shapes = this.parameters.shapes;
  return toJSON$1(shapes, data);
}; // ShapeBufferGeometry


function ShapeBufferGeometry(shapes, curveSegments) {
  BufferGeometry.call(this);
  this.type = 'ShapeBufferGeometry';
  this.parameters = {
    shapes: shapes,
    curveSegments: curveSegments
  };
  curveSegments = curveSegments || 12; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // helper variables

  var groupStart = 0;
  var groupCount = 0; // allow single and array values for "shapes" parameter

  if (Array.isArray(shapes) === false) {
    addShape(shapes);
  } else {
    for (var i = 0; i < shapes.length; i++) {
      addShape(shapes[i]);
      this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

      groupStart += groupCount;
      groupCount = 0;
    }
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions

  function addShape(shape) {
    var i, l, shapeHole;
    var indexOffset = vertices.length / 3;
    var points = shape.extractPoints(curveSegments);
    var shapeVertices = points.shape;
    var shapeHoles = points.holes; // check direction of vertices

    if (ShapeUtils.isClockWise(shapeVertices) === false) {
      shapeVertices = shapeVertices.reverse();
    }

    for (i = 0, l = shapeHoles.length; i < l; i++) {
      shapeHole = shapeHoles[i];

      if (ShapeUtils.isClockWise(shapeHole) === true) {
        shapeHoles[i] = shapeHole.reverse();
      }
    }

    var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array

    for (i = 0, l = shapeHoles.length; i < l; i++) {
      shapeHole = shapeHoles[i];
      shapeVertices = shapeVertices.concat(shapeHole);
    } // vertices, normals, uvs


    for (i = 0, l = shapeVertices.length; i < l; i++) {
      var vertex = shapeVertices[i];
      vertices.push(vertex.x, vertex.y, 0);
      normals.push(0, 0, 1);
      uvs.push(vertex.x, vertex.y); // world uvs
    } // incides


    for (i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];
      var a = face[0] + indexOffset;
      var b = face[1] + indexOffset;
      var c = face[2] + indexOffset;
      indices.push(a, b, c);
      groupCount += 3;
    }
  }
}

ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

ShapeBufferGeometry.prototype.toJSON = function () {
  var data = BufferGeometry.prototype.toJSON.call(this);
  var shapes = this.parameters.shapes;
  return toJSON$1(shapes, data);
}; //


function toJSON$1(shapes, data) {
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (var i = 0, l = shapes.length; i < l; i++) {
      var shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }

  return data;
}
/**
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */


function EdgesGeometry(geometry, thresholdAngle) {
  BufferGeometry.call(this);
  this.type = 'EdgesGeometry';
  this.parameters = {
    thresholdAngle: thresholdAngle
  };
  thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1; // buffer

  var vertices = []; // helper variables

  var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);
  var edge = [0, 0],
      edges = {},
      edge1,
      edge2;
  var key,
      keys = ['a', 'b', 'c']; // prepare source geometry

  var geometry2;

  if (geometry.isBufferGeometry) {
    geometry2 = new Geometry();
    geometry2.fromBufferGeometry(geometry);
  } else {
    geometry2 = geometry.clone();
  }

  geometry2.mergeVertices();
  geometry2.computeFaceNormals();
  var sourceVertices = geometry2.vertices;
  var faces = geometry2.faces; // now create a data structure where each entry represents an edge with its adjoining faces

  for (var i = 0, l = faces.length; i < l; i++) {
    var face = faces[i];

    for (var j = 0; j < 3; j++) {
      edge1 = face[keys[j]];
      edge2 = face[keys[(j + 1) % 3]];
      edge[0] = Math.min(edge1, edge2);
      edge[1] = Math.max(edge1, edge2);
      key = edge[0] + ',' + edge[1];

      if (edges[key] === undefined) {
        edges[key] = {
          index1: edge[0],
          index2: edge[1],
          face1: i,
          face2: undefined
        };
      } else {
        edges[key].face2 = i;
      }
    }
  } // generate vertices


  for (key in edges) {
    var e = edges[key]; // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

    if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
      var vertex = sourceVertices[e.index1];
      vertices.push(vertex.x, vertex.y, vertex.z);
      vertex = sourceVertices[e.index2];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  } // build geometry


  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
}

EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
EdgesGeometry.prototype.constructor = EdgesGeometry;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */
// CylinderGeometry

function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = 'CylinderGeometry';
  this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
  this.mergeVertices();
}

CylinderGeometry.prototype = Object.create(Geometry.prototype);
CylinderGeometry.prototype.constructor = CylinderGeometry; // CylinderBufferGeometry

function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = 'CylinderBufferGeometry';
  this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  var scope = this;
  radiusTop = radiusTop !== undefined ? radiusTop : 1;
  radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
  height = height || 1;
  radialSegments = Math.floor(radialSegments) || 8;
  heightSegments = Math.floor(heightSegments) || 1;
  openEnded = openEnded !== undefined ? openEnded : false;
  thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // helper variables

  var index = 0;
  var indexArray = [];
  var halfHeight = height / 2;
  var groupStart = 0; // generate geometry

  generateTorso();

  if (openEnded === false) {
    if (radiusTop > 0) generateCap(true);
    if (radiusBottom > 0) generateCap(false);
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

  function generateTorso() {
    var x, y;
    var normal = new Vector3();
    var vertex = new Vector3();
    var groupCount = 0; // this will be used to calculate the normal

    var slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs

    for (y = 0; y <= heightSegments; y++) {
      var indexRow = [];
      var v = y / heightSegments; // calculate the radius of the current row

      var radius = v * (radiusBottom - radiusTop) + radiusTop;

      for (x = 0; x <= radialSegments; x++) {
        var u = x / radialSegments;
        var theta = u * thetaLength + thetaStart;
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta); // vertex

        vertex.x = radius * sinTheta;
        vertex.y = -v * height + halfHeight;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normal.set(sinTheta, slope, cosTheta).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(u, 1 - v); // save index of vertex in respective row

        indexRow.push(index++);
      } // now save vertices of the row in our index array


      indexArray.push(indexRow);
    } // generate indices


    for (x = 0; x < radialSegments; x++) {
      for (y = 0; y < heightSegments; y++) {
        // we use the index array to access the correct indices
        var a = indexArray[y][x];
        var b = indexArray[y + 1][x];
        var c = indexArray[y + 1][x + 1];
        var d = indexArray[y][x + 1]; // faces

        indices.push(a, b, d);
        indices.push(b, c, d); // update group counter

        groupCount += 6;
      }
    } // add a group to the geometry. this will ensure multi material support


    scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups

    groupStart += groupCount;
  }

  function generateCap(top) {
    var x, centerIndexStart, centerIndexEnd;
    var uv = new Vector2();
    var vertex = new Vector3();
    var groupCount = 0;
    var radius = top === true ? radiusTop : radiusBottom;
    var sign = top === true ? 1 : -1; // save the index of the first center vertex

    centerIndexStart = index; // first we generate the center vertex data of the cap.
    // because the geometry needs one set of uvs per face,
    // we must generate a center vertex per face/segment

    for (x = 1; x <= radialSegments; x++) {
      // vertex
      vertices.push(0, halfHeight * sign, 0); // normal

      normals.push(0, sign, 0); // uv

      uvs.push(0.5, 0.5); // increase index

      index++;
    } // save the index of the last center vertex


    centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs

    for (x = 0; x <= radialSegments; x++) {
      var u = x / radialSegments;
      var theta = u * thetaLength + thetaStart;
      var cosTheta = Math.cos(theta);
      var sinTheta = Math.sin(theta); // vertex

      vertex.x = radius * sinTheta;
      vertex.y = halfHeight * sign;
      vertex.z = radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      normals.push(0, sign, 0); // uv

      uv.x = cosTheta * 0.5 + 0.5;
      uv.y = sinTheta * 0.5 * sign + 0.5;
      uvs.push(uv.x, uv.y); // increase index

      index++;
    } // generate indices


    for (x = 0; x < radialSegments; x++) {
      var c = centerIndexStart + x;
      var i = centerIndexEnd + x;

      if (top === true) {
        // face top
        indices.push(i, i + 1, c);
      } else {
        // face bottom
        indices.push(i + 1, i, c);
      }

      groupCount += 3;
    } // add a group to the geometry. this will ensure multi material support


    scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups

    groupStart += groupCount;
  }
}

CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
/**
 * @author abelnation / http://github.com/abelnation
 */
// ConeGeometry

function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
  this.type = 'ConeGeometry';
  this.parameters = {
    radius: radius,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
}

ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
ConeGeometry.prototype.constructor = ConeGeometry; // ConeBufferGeometry

function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
  this.type = 'ConeBufferGeometry';
  this.parameters = {
    radius: radius,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
}

ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 * @author hughes
 */
// CircleGeometry

function CircleGeometry(radius, segments, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = 'CircleGeometry';
  this.parameters = {
    radius: radius,
    segments: segments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
  this.mergeVertices();
}

CircleGeometry.prototype = Object.create(Geometry.prototype);
CircleGeometry.prototype.constructor = CircleGeometry; // CircleBufferGeometry

function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = 'CircleBufferGeometry';
  this.parameters = {
    radius: radius,
    segments: segments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  radius = radius || 1;
  segments = segments !== undefined ? Math.max(3, segments) : 8;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2; // buffers

  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = []; // helper variables

  var i, s;
  var vertex = new Vector3();
  var uv = new Vector2(); // center point

  vertices.push(0, 0, 0);
  normals.push(0, 0, 1);
  uvs.push(0.5, 0.5);

  for (s = 0, i = 3; s <= segments; s++, i += 3) {
    var segment = thetaStart + s / segments * thetaLength; // vertex

    vertex.x = radius * Math.cos(segment);
    vertex.y = radius * Math.sin(segment);
    vertices.push(vertex.x, vertex.y, vertex.z); // normal

    normals.push(0, 0, 1); // uvs

    uv.x = (vertices[i] / radius + 1) / 2;
    uv.y = (vertices[i + 1] / radius + 1) / 2;
    uvs.push(uv.x, uv.y);
  } // indices


  for (i = 1; i <= segments; i++) {
    indices.push(i, i + 1, 0);
  } // build geometry


  this.setIndex(indices);
  this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
var Geometries =
/*#__PURE__*/
Object.freeze({
  WireframeGeometry: WireframeGeometry,
  ParametricGeometry: ParametricGeometry,
  ParametricBufferGeometry: ParametricBufferGeometry,
  TetrahedronGeometry: TetrahedronGeometry,
  TetrahedronBufferGeometry: TetrahedronBufferGeometry,
  OctahedronGeometry: OctahedronGeometry,
  OctahedronBufferGeometry: OctahedronBufferGeometry,
  IcosahedronGeometry: IcosahedronGeometry,
  IcosahedronBufferGeometry: IcosahedronBufferGeometry,
  DodecahedronGeometry: DodecahedronGeometry,
  DodecahedronBufferGeometry: DodecahedronBufferGeometry,
  PolyhedronGeometry: PolyhedronGeometry,
  PolyhedronBufferGeometry: PolyhedronBufferGeometry,
  TubeGeometry: TubeGeometry,
  TubeBufferGeometry: TubeBufferGeometry,
  TorusKnotGeometry: TorusKnotGeometry,
  TorusKnotBufferGeometry: TorusKnotBufferGeometry,
  TorusGeometry: TorusGeometry,
  TorusBufferGeometry: TorusBufferGeometry,
  TextGeometry: TextGeometry,
  TextBufferGeometry: TextBufferGeometry,
  SphereGeometry: SphereGeometry,
  SphereBufferGeometry: SphereBufferGeometry,
  RingGeometry: RingGeometry,
  RingBufferGeometry: RingBufferGeometry,
  PlaneGeometry: PlaneGeometry,
  PlaneBufferGeometry: PlaneBufferGeometry,
  LatheGeometry: LatheGeometry,
  LatheBufferGeometry: LatheBufferGeometry,
  ShapeGeometry: ShapeGeometry,
  ShapeBufferGeometry: ShapeBufferGeometry,
  ExtrudeGeometry: ExtrudeGeometry,
  ExtrudeBufferGeometry: ExtrudeBufferGeometry,
  EdgesGeometry: EdgesGeometry,
  ConeGeometry: ConeGeometry,
  ConeBufferGeometry: ConeBufferGeometry,
  CylinderGeometry: CylinderGeometry,
  CylinderBufferGeometry: CylinderBufferGeometry,
  CircleGeometry: CircleGeometry,
  CircleBufferGeometry: CircleBufferGeometry,
  BoxGeometry: BoxGeometry,
  BoxBufferGeometry: BoxBufferGeometry
});
/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  color: <THREE.Color>
 * }
 */

function ShadowMaterial(parameters) {
  Material.call(this);
  this.type = 'ShadowMaterial';
  this.color = new Color(0x000000);
  this.transparent = true;
  this.setValues(parameters);
}

ShadowMaterial.prototype = Object.create(Material.prototype);
ShadowMaterial.prototype.constructor = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = true;

ShadowMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */


function RawShaderMaterial(parameters) {
  ShaderMaterial.call(this, parameters);
  this.type = 'RawShaderMaterial';
}

RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
RawShaderMaterial.prototype.constructor = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = true;
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshStandardMaterial(parameters) {
  Material.call(this);
  this.defines = {
    'STANDARD': ''
  };
  this.type = 'MeshStandardMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.roughness = 0.5;
  this.metalness = 0.5;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.roughnessMap = null;
  this.metalnessMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.envMapIntensity = 1.0;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

MeshStandardMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.defines = {
    'STANDARD': ''
  };
  this.color.copy(source.color);
  this.roughness = source.roughness;
  this.metalness = source.metalness;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.roughnessMap = source.roughnessMap;
  this.metalnessMap = source.metalnessMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.envMapIntensity = source.envMapIntensity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  reflectivity: <float>
 *  clearcoat: <float>
 *  clearcoatRoughness: <float>
 *
 *  sheen: <Color>
 *
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 * }
 */


function MeshPhysicalMaterial(parameters) {
  MeshStandardMaterial.call(this);
  this.defines = {
    'STANDARD': '',
    'PHYSICAL': ''
  };
  this.type = 'MeshPhysicalMaterial';
  this.reflectivity = 0.5; // maps to F0 = 0.04

  this.clearcoat = 0.0;
  this.clearcoatRoughness = 0.0;
  this.sheen = null; // null will disable sheen bsdf

  this.clearcoatNormalScale = new Vector2(1, 1);
  this.clearcoatNormalMap = null;
  this.transparency = 0.0;
  this.setValues(parameters);
}

MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

MeshPhysicalMaterial.prototype.copy = function (source) {
  MeshStandardMaterial.prototype.copy.call(this, source);
  this.defines = {
    'STANDARD': '',
    'PHYSICAL': ''
  };
  this.reflectivity = source.reflectivity;
  this.clearcoat = source.clearcoat;
  this.clearcoatRoughness = source.clearcoatRoughness;
  if (source.sheen) this.sheen = (this.sheen || new Color()).copy(source.sheen);else this.sheen = null;
  this.clearcoatNormalMap = source.clearcoatNormalMap;
  this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
  this.transparency = source.transparency;
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshPhongMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshPhongMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.specular = new Color(0x111111);
  this.shininess = 30;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshPhongMaterial.prototype = Object.create(Material.prototype);
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

MeshPhongMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.specular.copy(source.specular);
  this.shininess = source.shininess;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * @author takahirox / http://github.com/takahirox
 *
 * parameters = {
 *  gradientMap: new THREE.Texture( <Image> )
 * }
 */


function MeshToonMaterial(parameters) {
  MeshPhongMaterial.call(this);
  this.defines = {
    'TOON': ''
  };
  this.type = 'MeshToonMaterial';
  this.gradientMap = null;
  this.setValues(parameters);
}

MeshToonMaterial.prototype = Object.create(MeshPhongMaterial.prototype);
MeshToonMaterial.prototype.constructor = MeshToonMaterial;
MeshToonMaterial.prototype.isMeshToonMaterial = true;

MeshToonMaterial.prototype.copy = function (source) {
  MeshPhongMaterial.prototype.copy.call(this, source);
  this.gradientMap = source.gradientMap;
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshNormalMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshNormalMaterial';
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshNormalMaterial.prototype = Object.create(Material.prototype);
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

MeshNormalMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshLambertMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshLambertMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshLambertMaterial.prototype = Object.create(Material.prototype);
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

MeshLambertMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshMatcapMaterial(parameters) {
  Material.call(this);
  this.defines = {
    'MATCAP': ''
  };
  this.type = 'MeshMatcapMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.matcap = null;
  this.map = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.alphaMap = null;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.lights = false;
  this.setValues(parameters);
}

MeshMatcapMaterial.prototype = Object.create(Material.prototype);
MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

MeshMatcapMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.defines = {
    'MATCAP': ''
  };
  this.color.copy(source.color);
  this.matcap = source.matcap;
  this.map = source.map;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.alphaMap = source.alphaMap;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */


function LineDashedMaterial(parameters) {
  LineBasicMaterial.call(this);
  this.type = 'LineDashedMaterial';
  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.setValues(parameters);
}

LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
LineDashedMaterial.prototype.constructor = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;

LineDashedMaterial.prototype.copy = function (source) {
  LineBasicMaterial.prototype.copy.call(this, source);
  this.scale = source.scale;
  this.dashSize = source.dashSize;
  this.gapSize = source.gapSize;
  return this;
};

var Materials =
/*#__PURE__*/
Object.freeze({
  ShadowMaterial: ShadowMaterial,
  SpriteMaterial: SpriteMaterial,
  RawShaderMaterial: RawShaderMaterial,
  ShaderMaterial: ShaderMaterial,
  PointsMaterial: PointsMaterial,
  MeshPhysicalMaterial: MeshPhysicalMaterial,
  MeshStandardMaterial: MeshStandardMaterial,
  MeshPhongMaterial: MeshPhongMaterial,
  MeshToonMaterial: MeshToonMaterial,
  MeshNormalMaterial: MeshNormalMaterial,
  MeshLambertMaterial: MeshLambertMaterial,
  MeshDepthMaterial: MeshDepthMaterial,
  MeshDistanceMaterial: MeshDistanceMaterial,
  MeshBasicMaterial: MeshBasicMaterial,
  MeshMatcapMaterial: MeshMatcapMaterial,
  LineDashedMaterial: LineDashedMaterial,
  LineBasicMaterial: LineBasicMaterial,
  Material: Material
});
/**
 * @author tschw
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

var AnimationUtils = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function (array, from, to) {
    if (AnimationUtils.isTypedArray(array)) {
      // in ios9 array.subarray(from, undefined) will return empty array
      // but array.subarray(from) or array.subarray(from, len) is correct
      return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
    }

    return array.slice(from, to);
  },
  // converts an array to a specific type
  convertArray: function (array, type, forceClone) {
    if (!array || // let 'undefined' and 'null' pass
    !forceClone && array.constructor === type) return array;

    if (typeof type.BYTES_PER_ELEMENT === 'number') {
      return new type(array); // create typed array
    }

    return Array.prototype.slice.call(array); // create Array
  },
  isTypedArray: function (object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function (times) {
    function compareTime(i, j) {
      return times[i] - times[j];
    }

    var n = times.length;
    var result = new Array(n);

    for (var i = 0; i !== n; ++i) result[i] = i;

    result.sort(compareTime);
    return result;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function (values, stride, order) {
    var nValues = values.length;
    var result = new values.constructor(nValues);

    for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
      var srcOffset = order[i] * stride;

      for (var j = 0; j !== stride; ++j) {
        result[dstOffset++] = values[srcOffset + j];
      }
    }

    return result;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function (jsonKeys, times, values, valuePropertyName) {
    var i = 1,
        key = jsonKeys[0];

    while (key !== undefined && key[valuePropertyName] === undefined) {
      key = jsonKeys[i++];
    }

    if (key === undefined) return; // no data

    var value = key[valuePropertyName];
    if (value === undefined) return; // no data

    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          values.push.apply(values, value); // push all elements
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    } else if (value.toArray !== undefined) {
      // ...assume THREE.Math-ish
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          value.toArray(values, values.length);
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    } else {
      // otherwise push as-is
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          values.push(value);
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    }
  }
};
/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 * @author tschw
 */

exports.AnimationUtils = AnimationUtils;

function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  this.parameterPositions = parameterPositions;
  this._cachedIndex = 0;
  this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
  this.sampleValues = sampleValues;
  this.valueSize = sampleSize;
}

Object.assign(Interpolant.prototype, {
  evaluate: function (t) {
    var pp = this.parameterPositions,
        i1 = this._cachedIndex,
        t1 = pp[i1],
        t0 = pp[i1 - 1];

    validate_interval: {
      seek: {
        var right;

        linear_scan: {
          //- See http://jsperf.com/comparison-to-undefined/3
          //- slower code:
          //-
          //- 				if ( t >= t1 || t1 === undefined ) {
          forward_scan: if (!(t < t1)) {
            for (var giveUpAt = i1 + 2;;) {
              if (t1 === undefined) {
                if (t < t0) break forward_scan; // after end

                i1 = pp.length;
                this._cachedIndex = i1;
                return this.afterEnd_(i1 - 1, t, t0);
              }

              if (i1 === giveUpAt) break; // this loop

              t0 = t1;
              t1 = pp[++i1];

              if (t < t1) {
                // we have arrived at the sought interval
                break seek;
              }
            } // prepare binary search on the right side of the index


            right = pp.length;
            break linear_scan;
          } //- slower code:
          //-					if ( t < t0 || t0 === undefined ) {


          if (!(t >= t0)) {
            // looping?
            var t1global = pp[1];

            if (t < t1global) {
              i1 = 2; // + 1, using the scan for the details

              t0 = t1global;
            } // linear reverse scan


            for (var giveUpAt = i1 - 2;;) {
              if (t0 === undefined) {
                // before start
                this._cachedIndex = 0;
                return this.beforeStart_(0, t, t1);
              }

              if (i1 === giveUpAt) break; // this loop

              t1 = t0;
              t0 = pp[--i1 - 1];

              if (t >= t0) {
                // we have arrived at the sought interval
                break seek;
              }
            } // prepare binary search on the left side of the index


            right = i1;
            i1 = 0;
            break linear_scan;
          } // the interval is valid


          break validate_interval;
        } // linear scan
        // binary search


        while (i1 < right) {
          var mid = i1 + right >>> 1;

          if (t < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }

        t1 = pp[i1];
        t0 = pp[i1 - 1]; // check boundary cases, again

        if (t0 === undefined) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t, t1);
        }

        if (t1 === undefined) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t);
        }
      } // seek


      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    } // validate_interval


    return this.interpolate_(i1, t0, t, t1);
  },
  settings: null,
  // optional, subclass-specific settings structure
  // Note: The indirection allows central control of many interpolants.
  // --- Protected interface
  DefaultSettings_: {},
  getSettings_: function () {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function (index) {
    // copies a sample value to the result buffer
    var result = this.resultBuffer,
        values = this.sampleValues,
        stride = this.valueSize,
        offset = index * stride;

    for (var i = 0; i !== stride; ++i) {
      result[i] = values[offset + i];
    }

    return result;
  },
  // Template methods for derived classes:
  interpolate_: function ()
  /* i1, t0, t, t1 */
  {
    throw new Error('call to abstract method'); // implementations shall return this.resultBuffer
  },
  intervalChanged_: function ()
  /* i1, t0, t1 */
  {// empty
  }
}); //!\ DECLARE ALIAS AFTER assign prototype !

Object.assign(Interpolant.prototype, {
  //( 0, t, t0 ), returns this.resultBuffer
  beforeStart_: Interpolant.prototype.copySampleValue_,
  //( N-1, tN-1, t ), returns this.resultBuffer
  afterEnd_: Interpolant.prototype.copySampleValue_
});
/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @author tschw
 */

function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  this._weightPrev = -0;
  this._offsetPrev = -0;
  this._weightNext = -0;
  this._offsetNext = -0;
}

CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: CubicInterpolant,
  DefaultSettings_: {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  },
  intervalChanged_: function (i1, t0, t1) {
    var pp = this.parameterPositions,
        iPrev = i1 - 2,
        iNext = i1 + 1,
        tPrev = pp[iPrev],
        tNext = pp[iNext];

    if (tPrev === undefined) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          // f'(t0) = 0
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;

        case WrapAroundEnding:
          // use the other end of the curve
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;

        default:
          // ZeroCurvatureEnding
          // f''(t0) = 0 a.k.a. Natural Spline
          iPrev = i1;
          tPrev = t1;
      }
    }

    if (tNext === undefined) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          // f'(tN) = 0
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;

        case WrapAroundEnding:
          // use the other end of the curve
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;

        default:
          // ZeroCurvatureEnding
          // f''(tN) = 0, a.k.a. Natural Spline
          iNext = i1 - 1;
          tNext = t0;
      }
    }

    var halfDt = (t1 - t0) * 0.5,
        stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  },
  interpolate_: function (i1, t0, t, t1) {
    var result = this.resultBuffer,
        values = this.sampleValues,
        stride = this.valueSize,
        o1 = i1 * stride,
        o0 = o1 - stride,
        oP = this._offsetPrev,
        oN = this._offsetNext,
        wP = this._weightPrev,
        wN = this._weightNext,
        p = (t - t0) / (t1 - t0),
        pp = p * p,
        ppp = pp * p; // evaluate polynomials

    var sP = -wP * ppp + 2 * wP * pp - wP * p;
    var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    var sN = wN * ppp - wN * pp; // combine data linearly

    for (var i = 0; i !== stride; ++i) {
      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
    }

    return result;
  }
});
/**
 * @author tschw
 */

function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}

LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: LinearInterpolant,
  interpolate_: function (i1, t0, t, t1) {
    var result = this.resultBuffer,
        values = this.sampleValues,
        stride = this.valueSize,
        offset1 = i1 * stride,
        offset0 = offset1 - stride,
        weight1 = (t - t0) / (t1 - t0),
        weight0 = 1 - weight1;

    for (var i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }

    return result;
  }
});
/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 *
 * @author tschw
 */

function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}

DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: DiscreteInterpolant,
  interpolate_: function (i1
  /*, t0, t, t1 */
  ) {
    return this.copySampleValue_(i1 - 1);
  }
});
/**
 *
 * A timed sequence of keyframes for a specific property.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function KeyframeTrack(name, times, values, interpolation) {
  if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
  if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
  this.name = name;
  this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
  this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
  this.setInterpolation(interpolation || this.DefaultInterpolation);
} // Static methods


Object.assign(KeyframeTrack, {
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  toJSON: function (track) {
    var trackType = track.constructor;
    var json; // derived classes can define a static toJSON method

    if (trackType.toJSON !== undefined) {
      json = trackType.toJSON(track);
    } else {
      // by default, we assume the data can be serialized as-is
      json = {
        'name': track.name,
        'times': AnimationUtils.convertArray(track.times, Array),
        'values': AnimationUtils.convertArray(track.values, Array)
      };
      var interpolation = track.getInterpolation();

      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }

    json.type = track.ValueTypeName; // mandatory

    return json;
  }
});
Object.assign(KeyframeTrack.prototype, {
  constructor: KeyframeTrack,
  TimeBufferType: Float32Array,
  ValueBufferType: Float32Array,
  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodDiscrete: function (result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodLinear: function (result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodSmooth: function (result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  setInterpolation: function (interpolation) {
    var factoryMethod;

    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;

      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;

      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }

    if (factoryMethod === undefined) {
      var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;

      if (this.createInterpolant === undefined) {
        // fall back to default, unless the default itself is messed up
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message); // fatal, in this case
        }
      }

      console.warn('THREE.KeyframeTrack:', message);
      return this;
    }

    this.createInterpolant = factoryMethod;
    return this;
  },
  getInterpolation: function () {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;

      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;

      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  },
  getValueSize: function () {
    return this.values.length / this.times.length;
  },
  // move all keyframes either forwards or backwards in time
  shift: function (timeOffset) {
    if (timeOffset !== 0.0) {
      var times = this.times;

      for (var i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
      }
    }

    return this;
  },
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale: function (timeScale) {
    if (timeScale !== 1.0) {
      var times = this.times;

      for (var i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
      }
    }

    return this;
  },
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim: function (startTime, endTime) {
    var times = this.times,
        nKeys = times.length,
        from = 0,
        to = nKeys - 1;

    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }

    while (to !== -1 && times[to] > endTime) {
      --to;
    }

    ++to; // inclusive -> exclusive bound

    if (from !== 0 || to !== nKeys) {
      // empty tracks are forbidden, so keep at least one keyframe
      if (from >= to) to = Math.max(to, 1), from = to - 1;
      var stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
    }

    return this;
  },
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate: function () {
    var valid = true;
    var valueSize = this.getValueSize();

    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
      valid = false;
    }

    var times = this.times,
        values = this.values,
        nKeys = times.length;

    if (nKeys === 0) {
      console.error('THREE.KeyframeTrack: Track is empty.', this);
      valid = false;
    }

    var prevTime = null;

    for (var i = 0; i !== nKeys; i++) {
      var currTime = times[i];

      if (typeof currTime === 'number' && isNaN(currTime)) {
        console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
        valid = false;
        break;
      }

      if (prevTime !== null && prevTime > currTime) {
        console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
        valid = false;
        break;
      }

      prevTime = currTime;
    }

    if (values !== undefined) {
      if (AnimationUtils.isTypedArray(values)) {
        for (var i = 0, n = values.length; i !== n; ++i) {
          var value = values[i];

          if (isNaN(value)) {
            console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
            valid = false;
            break;
          }
        }
      }
    }

    return valid;
  },
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize: function () {
    var times = this.times,
        values = this.values,
        stride = this.getValueSize(),
        smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
        writeIndex = 1,
        lastIndex = times.length - 1;

    for (var i = 1; i < lastIndex; ++i) {
      var keep = false;
      var time = times[i];
      var timeNext = times[i + 1]; // remove adjacent keyframes scheduled at the same time

      if (time !== timeNext && (i !== 1 || time !== time[0])) {
        if (!smoothInterpolation) {
          // remove unnecessary keyframes same as their neighbors
          var offset = i * stride,
              offsetP = offset - stride,
              offsetN = offset + stride;

          for (var j = 0; j !== stride; ++j) {
            var value = values[offset + j];

            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      } // in-place compaction


      if (keep) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          var readOffset = i * stride,
              writeOffset = writeIndex * stride;

          for (var j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }

        ++writeIndex;
      }
    } // flush last keyframe (compaction looks ahead)


    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];

      for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }

      ++writeIndex;
    }

    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    }

    return this;
  },
  clone: function () {
    var times = AnimationUtils.arraySlice(this.times, 0);
    var values = AnimationUtils.arraySlice(this.values, 0);
    var TypedKeyframeTrack = this.constructor;
    var track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.

    track.createInterpolant = this.createInterpolant;
    return track;
  }
});
/**
 *
 * A Track of Boolean keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function BooleanKeyframeTrack(name, times, values) {
  KeyframeTrack.call(this, name, times, values);
}

BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: BooleanKeyframeTrack,
  ValueTypeName: 'bool',
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: undefined,
  InterpolantFactoryMethodSmooth: undefined // Note: Actually this track could have a optimized / compressed
  // representation of a single value and a custom interpolant that
  // computes "firstValue ^ isOdd( index )".

});
/**
 *
 * A Track of keyframe values that represent color.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function ColorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: ColorKeyframeTrack,
  ValueTypeName: 'color' // ValueBufferType is inherited
  // DefaultInterpolation is inherited
  // Note: Very basic implementation and nothing special yet.
  // However, this is the place for color space parameterization.

});
/**
 *
 * A Track of numeric keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function NumberKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: NumberKeyframeTrack,
  ValueTypeName: 'number' // ValueBufferType is inherited
  // DefaultInterpolation is inherited

});
/**
 * Spherical linear unit quaternion interpolant.
 *
 * @author tschw
 */

function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}

QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: QuaternionLinearInterpolant,
  interpolate_: function (i1, t0, t, t1) {
    var result = this.resultBuffer,
        values = this.sampleValues,
        stride = this.valueSize,
        offset = i1 * stride,
        alpha = (t - t0) / (t1 - t0);

    for (var end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }

    return result;
  }
});
/**
 *
 * A Track of quaternion keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function QuaternionKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: QuaternionKeyframeTrack,
  ValueTypeName: 'quaternion',
  // ValueBufferType is inherited
  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodLinear: function (result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodSmooth: undefined // not yet implemented

});
/**
 *
 * A Track that interpolates Strings
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function StringKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: StringKeyframeTrack,
  ValueTypeName: 'string',
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: undefined,
  InterpolantFactoryMethodSmooth: undefined
});
/**
 *
 * A Track of vectored keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function VectorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: VectorKeyframeTrack,
  ValueTypeName: 'vector' // ValueBufferType is inherited
  // DefaultInterpolation is inherited

});
/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

function AnimationClip(name, duration, tracks) {
  this.name = name;
  this.tracks = tracks;
  this.duration = duration !== undefined ? duration : -1;
  this.uuid = _Math.generateUUID(); // this means it should figure out its duration by scanning the tracks

  if (this.duration < 0) {
    this.resetDuration();
  }
}

function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case 'scalar':
    case 'double':
    case 'float':
    case 'number':
    case 'integer':
      return NumberKeyframeTrack;

    case 'vector':
    case 'vector2':
    case 'vector3':
    case 'vector4':
      return VectorKeyframeTrack;

    case 'color':
      return ColorKeyframeTrack;

    case 'quaternion':
      return QuaternionKeyframeTrack;

    case 'bool':
    case 'boolean':
      return BooleanKeyframeTrack;

    case 'string':
      return StringKeyframeTrack;
  }

  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
}

function parseKeyframeTrack(json) {
  if (json.type === undefined) {
    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
  }

  var trackType = getTrackTypeForValueTypeName(json.type);

  if (json.times === undefined) {
    var times = [],
        values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, 'value');
    json.times = times;
    json.values = values;
  } // derived classes can define a static parse method


  if (trackType.parse !== undefined) {
    return trackType.parse(json);
  } else {
    // by default, we assume a constructor compatible with the base
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}

Object.assign(AnimationClip, {
  parse: function (json) {
    var tracks = [],
        jsonTracks = json.tracks,
        frameTime = 1.0 / (json.fps || 1.0);

    for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
    }

    return new AnimationClip(json.name, json.duration, tracks);
  },
  toJSON: function (clip) {
    var tracks = [],
        clipTracks = clip.tracks;
    var json = {
      'name': clip.name,
      'duration': clip.duration,
      'tracks': tracks,
      'uuid': clip.uuid
    };

    for (var i = 0, n = clipTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
    }

    return json;
  },
  CreateFromMorphTargetSequence: function (name, morphTargetSequence, fps, noLoop) {
    var numMorphTargets = morphTargetSequence.length;
    var tracks = [];

    for (var i = 0; i < numMorphTargets; i++) {
      var times = [];
      var values = [];
      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
      values.push(0, 1, 0);
      var order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the
      // last frame as well for perfect loop.

      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }

      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
    }

    return new AnimationClip(name, -1, tracks);
  },
  findByName: function (objectOrClipArray, name) {
    var clipArray = objectOrClipArray;

    if (!Array.isArray(objectOrClipArray)) {
      var o = objectOrClipArray;
      clipArray = o.geometry && o.geometry.animations || o.animations;
    }

    for (var i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name) {
        return clipArray[i];
      }
    }

    return null;
  },
  CreateClipsFromMorphTargetSequences: function (morphTargets, fps, noLoop) {
    var animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences
    // such flamingo_flyA_003, flamingo_run1_003, crdeath0059

    var pattern = /^([\w-]*?)([\d]+)$/; // sort morph target names into animation groups based
    // patterns like Walk_001, Walk_002, Run_001, Run_002

    for (var i = 0, il = morphTargets.length; i < il; i++) {
      var morphTarget = morphTargets[i];
      var parts = morphTarget.name.match(pattern);

      if (parts && parts.length > 1) {
        var name = parts[1];
        var animationMorphTargets = animationToMorphTargets[name];

        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }

        animationMorphTargets.push(morphTarget);
      }
    }

    var clips = [];

    for (var name in animationToMorphTargets) {
      clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }

    return clips;
  },
  // parse the animation.hierarchy format
  parseAnimation: function (animation, bones) {
    if (!animation) {
      console.error('THREE.AnimationClip: No animation in JSONLoader data.');
      return null;
    }

    var addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
      // only return track if there are actually keys.
      if (animationKeys.length !== 0) {
        var times = [];
        var values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again

        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };

    var tracks = [];
    var clipName = animation.name || 'default'; // automatic length determination in AnimationClip.

    var duration = animation.length || -1;
    var fps = animation.fps || 30;
    var hierarchyTracks = animation.hierarchy || [];

    for (var h = 0; h < hierarchyTracks.length; h++) {
      var animationKeys = hierarchyTracks[h].keys; // skip empty tracks

      if (!animationKeys || animationKeys.length === 0) continue; // process morph targets

      if (animationKeys[0].morphTargets) {
        // figure out all morph targets used in this track
        var morphTargetNames = {};

        for (var k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
            }
          }
        } // create a track for each morph target with all zero
        // morphTargetInfluences except for the keys in which
        // the morphTarget is named.


        for (var morphTargetName in morphTargetNames) {
          var times = [];
          var values = [];

          for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
            var animationKey = animationKeys[k];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }

          tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
        }

        duration = morphTargetNames.length * (fps || 1.0);
      } else {
        // ...assume skeletal animation
        var boneName = '.bones[' + bones[h].name + ']';
        addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
      }
    }

    if (tracks.length === 0) {
      return null;
    }

    var clip = new AnimationClip(clipName, duration, tracks);
    return clip;
  }
});
Object.assign(AnimationClip.prototype, {
  resetDuration: function () {
    var tracks = this.tracks,
        duration = 0;

    for (var i = 0, n = tracks.length; i !== n; ++i) {
      var track = this.tracks[i];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }

    this.duration = duration;
    return this;
  },
  trim: function () {
    for (var i = 0; i < this.tracks.length; i++) {
      this.tracks[i].trim(0, this.duration);
    }

    return this;
  },
  validate: function () {
    var valid = true;

    for (var i = 0; i < this.tracks.length; i++) {
      valid = valid && this.tracks[i].validate();
    }

    return valid;
  },
  optimize: function () {
    for (var i = 0; i < this.tracks.length; i++) {
      this.tracks[i].optimize();
    }

    return this;
  },
  clone: function () {
    var tracks = [];

    for (var i = 0; i < this.tracks.length; i++) {
      tracks.push(this.tracks[i].clone());
    }

    return new AnimationClip(this.name, this.duration, tracks);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

var Cache = {
  enabled: false,
  files: {},
  add: function (key, file) {
    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );

    this.files[key] = file;
  },
  get: function (key) {
    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );

    return this.files[key];
  },
  remove: function (key) {
    delete this.files[key];
  },
  clear: function () {
    this.files = {};
  }
};
/**
 * @author mrdoob / http://mrdoob.com/
 */

exports.Cache = Cache;

function LoadingManager(onLoad, onProgress, onError) {
  var scope = this;
  var isLoading = false;
  var itemsLoaded = 0;
  var itemsTotal = 0;
  var urlModifier = undefined; // Refer to #5689 for the reason why we don't set .onStart
  // in the constructor

  this.onStart = undefined;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;

  this.itemStart = function (url) {
    itemsTotal++;

    if (isLoading === false) {
      if (scope.onStart !== undefined) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }

    isLoading = true;
  };

  this.itemEnd = function (url) {
    itemsLoaded++;

    if (scope.onProgress !== undefined) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }

    if (itemsLoaded === itemsTotal) {
      isLoading = false;

      if (scope.onLoad !== undefined) {
        scope.onLoad();
      }
    }
  };

  this.itemError = function (url) {
    if (scope.onError !== undefined) {
      scope.onError(url);
    }
  };

  this.resolveURL = function (url) {
    if (urlModifier) {
      return urlModifier(url);
    }

    return url;
  };

  this.setURLModifier = function (transform) {
    urlModifier = transform;
    return this;
  };
}

var DefaultLoadingManager = new LoadingManager();
/**
 * @author alteredq / http://alteredqualia.com/
 */

exports.DefaultLoadingManager = DefaultLoadingManager;

function Loader(manager) {
  this.manager = manager !== undefined ? manager : DefaultLoadingManager;
  this.crossOrigin = 'anonymous';
  this.path = '';
  this.resourcePath = '';
}

Object.assign(Loader.prototype, {
  load: function ()
  /* url, onLoad, onProgress, onError */
  {},
  parse: function ()
  /* data */
  {},
  setCrossOrigin: function (crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  },
  setPath: function (path) {
    this.path = path;
    return this;
  },
  setResourcePath: function (resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
}); //

Loader.Handlers = {
  handlers: [],
  add: function (regex, loader) {
    this.handlers.push(regex, loader);
  },
  get: function (file) {
    var handlers = this.handlers;

    for (var i = 0, l = handlers.length; i < l; i += 2) {
      var regex = handlers[i];
      var loader = handlers[i + 1];

      if (regex.test(file)) {
        return loader;
      }
    }

    return null;
  }
};
/**
 * @author mrdoob / http://mrdoob.com/
 */

var loading = {};

function FileLoader(manager) {
  Loader.call(this, manager);
}

FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: FileLoader,
  load: function (url, onLoad, onProgress, onError) {
    if (url === undefined) url = '';
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    var scope = this;
    var cached = Cache.get(url);

    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    } // Check if request is duplicate


    if (loading[url] !== undefined) {
      loading[url].push({
        onLoad: onLoad,
        onProgress: onProgress,
        onError: onError
      });
      return;
    } // Check for data: URI


    var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    var dataUriRegexResult = url.match(dataUriRegex); // Safari can not handle Data URIs through XMLHttpRequest so process manually

    if (dataUriRegexResult) {
      var mimeType = dataUriRegexResult[1];
      var isBase64 = !!dataUriRegexResult[2];
      var data = dataUriRegexResult[3];
      data = decodeURIComponent(data);
      if (isBase64) data = atob(data);

      try {
        var response;
        var responseType = (this.responseType || '').toLowerCase();

        switch (responseType) {
          case 'arraybuffer':
          case 'blob':
            var view = new Uint8Array(data.length);

            for (var i = 0; i < data.length; i++) {
              view[i] = data.charCodeAt(i);
            }

            if (responseType === 'blob') {
              response = new Blob([view.buffer], {
                type: mimeType
              });
            } else {
              response = view.buffer;
            }

            break;

          case 'document':
            var parser = new DOMParser();
            response = parser.parseFromString(data, mimeType);
            break;

          case 'json':
            response = JSON.parse(data);
            break;

          default:
            // 'text' or other
            response = data;
            break;
        } // Wait for next browser tick like standard XMLHttpRequest event dispatching does


        setTimeout(function () {
          if (onLoad) onLoad(response);
          scope.manager.itemEnd(url);
        }, 0);
      } catch (error) {
        // Wait for next browser tick like standard XMLHttpRequest event dispatching does
        setTimeout(function () {
          if (onError) onError(error);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, 0);
      }
    } else {
      // Initialise array for duplicate requests
      loading[url] = [];
      loading[url].push({
        onLoad: onLoad,
        onProgress: onProgress,
        onError: onError
      });
      var request = new XMLHttpRequest();
      request.open('GET', url, true);
      request.addEventListener('load', function (event) {
        var response = this.response;
        Cache.add(url, response);
        var callbacks = loading[url];
        delete loading[url];

        if (this.status === 200 || this.status === 0) {
          // Some browsers return HTTP Status 0 when using non-http protocol
          // e.g. 'file://' or 'data://'. Handle as success.
          if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.');

          for (var i = 0, il = callbacks.length; i < il; i++) {
            var callback = callbacks[i];
            if (callback.onLoad) callback.onLoad(response);
          }

          scope.manager.itemEnd(url);
        } else {
          for (var i = 0, il = callbacks.length; i < il; i++) {
            var callback = callbacks[i];
            if (callback.onError) callback.onError(event);
          }

          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
      }, false);
      request.addEventListener('progress', function (event) {
        var callbacks = loading[url];

        for (var i = 0, il = callbacks.length; i < il; i++) {
          var callback = callbacks[i];
          if (callback.onProgress) callback.onProgress(event);
        }
      }, false);
      request.addEventListener('error', function (event) {
        var callbacks = loading[url];
        delete loading[url];

        for (var i = 0, il = callbacks.length; i < il; i++) {
          var callback = callbacks[i];
          if (callback.onError) callback.onError(event);
        }

        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      request.addEventListener('abort', function (event) {
        var callbacks = loading[url];
        delete loading[url];

        for (var i = 0, il = callbacks.length; i < il; i++) {
          var callback = callbacks[i];
          if (callback.onError) callback.onError(event);
        }

        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      if (this.responseType !== undefined) request.responseType = this.responseType;
      if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
      if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

      for (var header in this.requestHeader) {
        request.setRequestHeader(header, this.requestHeader[header]);
      }

      request.send(null);
    }

    scope.manager.itemStart(url);
    return request;
  },
  setResponseType: function (value) {
    this.responseType = value;
    return this;
  },
  setWithCredentials: function (value) {
    this.withCredentials = value;
    return this;
  },
  setMimeType: function (value) {
    this.mimeType = value;
    return this;
  },
  setRequestHeader: function (value) {
    this.requestHeader = value;
    return this;
  }
});
/**
 * @author bhouston / http://clara.io/
 */

function AnimationLoader(manager) {
  Loader.call(this, manager);
}

AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: AnimationLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.load(url, function (text) {
      onLoad(scope.parse(JSON.parse(text)));
    }, onProgress, onError);
  },
  parse: function (json) {
    var animations = [];

    for (var i = 0; i < json.length; i++) {
      var clip = AnimationClip.parse(json[i]);
      animations.push(clip);
    }

    return animations;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

function CompressedTextureLoader(manager) {
  Loader.call(this, manager); // override in sub classes

  this._parser = null;
}

CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: CompressedTextureLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var images = [];
    var texture = new CompressedTexture();
    texture.image = images;
    var loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType('arraybuffer');

    function loadTexture(i) {
      loader.load(url[i], function (buffer) {
        var texDatas = scope._parser(buffer, true);

        images[i] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;

        if (loaded === 6) {
          if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, onProgress, onError);
    }

    if (Array.isArray(url)) {
      var loaded = 0;

      for (var i = 0, il = url.length; i < il; ++i) {
        loadTexture(i);
      }
    } else {
      // compressed cubemap texture stored in a single DDS file
      loader.load(url, function (buffer) {
        var texDatas = scope._parser(buffer, true);

        if (texDatas.isCubemap) {
          var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

          for (var f = 0; f < faces; f++) {
            images[f] = {
              mipmaps: []
            };

            for (var i = 0; i < texDatas.mipmapCount; i++) {
              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
              images[f].format = texDatas.format;
              images[f].width = texDatas.width;
              images[f].height = texDatas.height;
            }
          }
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }

        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }

        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad) onLoad(texture);
      }, onProgress, onError);
    }

    return texture;
  }
});
/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

function DataTextureLoader(manager) {
  Loader.call(this, manager); // override in sub classes

  this._parser = null;
}

DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: DataTextureLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var texture = new DataTexture();
    var loader = new FileLoader(this.manager);
    loader.setResponseType('arraybuffer');
    loader.setPath(this.path);
    loader.load(url, function (buffer) {
      var texData = scope._parser(buffer);

      if (!texData) return;

      if (texData.image !== undefined) {
        texture.image = texData.image;
      } else if (texData.data !== undefined) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }

      texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearMipmapLinearFilter;
      texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

      if (texData.format !== undefined) {
        texture.format = texData.format;
      }

      if (texData.type !== undefined) {
        texture.type = texData.type;
      }

      if (texData.mipmaps !== undefined) {
        texture.mipmaps = texData.mipmaps;
      }

      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }

      texture.needsUpdate = true;
      if (onLoad) onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function ImageLoader(manager) {
  Loader.call(this, manager);
}

ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ImageLoader,
  load: function (url, onLoad, onProgress, onError) {
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    var scope = this;
    var cached = Cache.get(url);

    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }

    var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');

    function onImageLoad() {
      image.removeEventListener('load', onImageLoad, false);
      image.removeEventListener('error', onImageError, false);
      Cache.add(url, this);
      if (onLoad) onLoad(this);
      scope.manager.itemEnd(url);
    }

    function onImageError(event) {
      image.removeEventListener('load', onImageLoad, false);
      image.removeEventListener('error', onImageError, false);
      if (onError) onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }

    image.addEventListener('load', onImageLoad, false);
    image.addEventListener('error', onImageError, false);

    if (url.substr(0, 5) !== 'data:') {
      if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
    }

    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function CubeTextureLoader(manager) {
  Loader.call(this, manager);
}

CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: CubeTextureLoader,
  load: function (urls, onLoad, onProgress, onError) {
    var texture = new CubeTexture();
    var loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    var loaded = 0;

    function loadTexture(i) {
      loader.load(urls[i], function (image) {
        texture.images[i] = image;
        loaded++;

        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, undefined, onError);
    }

    for (var i = 0; i < urls.length; ++i) {
      loadTexture(i);
    }

    return texture;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function TextureLoader(manager) {
  Loader.call(this, manager);
}

TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: TextureLoader,
  load: function (url, onLoad, onProgress, onError) {
    var texture = new Texture();
    var loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function (image) {
      texture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.

      var isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? RGBFormat : RGBAFormat;
      texture.needsUpdate = true;

      if (onLoad !== undefined) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

function Curve() {
  this.type = 'Curve';
  this.arcLengthDivisions = 200;
}

Object.assign(Curve.prototype, {
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint: function ()
  /* t, optionalTarget */
  {
    console.warn('THREE.Curve: .getPoint() not implemented.');
    return null;
  },
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt: function (u, optionalTarget) {
    var t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  },
  // Get sequence of points using getPoint( t )
  getPoints: function (divisions) {
    if (divisions === undefined) divisions = 5;
    var points = [];

    for (var d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }

    return points;
  },
  // Get sequence of points using getPointAt( u )
  getSpacedPoints: function (divisions) {
    if (divisions === undefined) divisions = 5;
    var points = [];

    for (var d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }

    return points;
  },
  // Get total curve arc length
  getLength: function () {
    var lengths = this.getLengths();
    return lengths[lengths.length - 1];
  },
  // Get list of cumulative segment lengths
  getLengths: function (divisions) {
    if (divisions === undefined) divisions = this.arcLengthDivisions;

    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }

    this.needsUpdate = false;
    var cache = [];
    var current,
        last = this.getPoint(0);
    var p,
        sum = 0;
    cache.push(0);

    for (p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }

    this.cacheArcLengths = cache;
    return cache; // { sums: cache, sum: sum }; Sum is in the last element.
  },
  updateArcLengths: function () {
    this.needsUpdate = true;
    this.getLengths();
  },
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping: function (u, distance) {
    var arcLengths = this.getLengths();
    var i = 0,
        il = arcLengths.length;
    var targetArcLength; // The targeted u distance value to get

    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    } // binary search for the index with largest value smaller than target u distance


    var low = 0,
        high = il - 1,
        comparison;

    while (low <= high) {
      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

      comparison = arcLengths[i] - targetArcLength;

      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break; // DONE
      }
    }

    i = high;

    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    } // we could get finer grain at lengths, or use simple interpolation between two points


    var lengthBefore = arcLengths[i];
    var lengthAfter = arcLengths[i + 1];
    var segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points

    var segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t

    var t = (i + segmentFraction) / (il - 1);
    return t;
  },
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent: function (t) {
    var delta = 0.0001;
    var t1 = t - delta;
    var t2 = t + delta; // Capping in case of danger

    if (t1 < 0) t1 = 0;
    if (t2 > 1) t2 = 1;
    var pt1 = this.getPoint(t1);
    var pt2 = this.getPoint(t2);
    var vec = pt2.clone().sub(pt1);
    return vec.normalize();
  },
  getTangentAt: function (u) {
    var t = this.getUtoTmapping(u);
    return this.getTangent(t);
  },
  computeFrenetFrames: function (segments, closed) {
    // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
    var normal = new Vector3();
    var tangents = [];
    var normals = [];
    var binormals = [];
    var vec = new Vector3();
    var mat = new Matrix4();
    var i, u, theta; // compute the tangent vectors for each segment on the curve

    for (i = 0; i <= segments; i++) {
      u = i / segments;
      tangents[i] = this.getTangentAt(u);
      tangents[i].normalize();
    } // select an initial normal vector perpendicular to the first tangent vector,
    // and in the direction of the minimum tangent xyz component


    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    var min = Number.MAX_VALUE;
    var tx = Math.abs(tangents[0].x);
    var ty = Math.abs(tangents[0].y);
    var tz = Math.abs(tangents[0].z);

    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }

    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }

    if (tz <= min) {
      normal.set(0, 0, 1);
    }

    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve

    for (i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);

      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }

      binormals[i].crossVectors(tangents[i], normals[i]);
    } // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same


    if (closed === true) {
      theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;

      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }

      for (i = 1; i <= segments; i++) {
        // twist a little...
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }

    return {
      tangents: tangents,
      normals: normals,
      binormals: binormals
    };
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  },
  toJSON: function () {
    var data = {
      metadata: {
        version: 4.5,
        type: 'Curve',
        generator: 'Curve.toJSON'
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  },
  fromJSON: function (json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
});

function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
  Curve.call(this);
  this.type = 'EllipseCurve';
  this.aX = aX || 0;
  this.aY = aY || 0;
  this.xRadius = xRadius || 1;
  this.yRadius = yRadius || 1;
  this.aStartAngle = aStartAngle || 0;
  this.aEndAngle = aEndAngle || 2 * Math.PI;
  this.aClockwise = aClockwise || false;
  this.aRotation = aRotation || 0;
}

EllipseCurve.prototype = Object.create(Curve.prototype);
EllipseCurve.prototype.constructor = EllipseCurve;
EllipseCurve.prototype.isEllipseCurve = true;

EllipseCurve.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector2();
  var twoPi = Math.PI * 2;
  var deltaAngle = this.aEndAngle - this.aStartAngle;
  var samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI

  while (deltaAngle < 0) deltaAngle += twoPi;

  while (deltaAngle > twoPi) deltaAngle -= twoPi;

  if (deltaAngle < Number.EPSILON) {
    if (samePoints) {
      deltaAngle = 0;
    } else {
      deltaAngle = twoPi;
    }
  }

  if (this.aClockwise === true && !samePoints) {
    if (deltaAngle === twoPi) {
      deltaAngle = -twoPi;
    } else {
      deltaAngle = deltaAngle - twoPi;
    }
  }

  var angle = this.aStartAngle + t * deltaAngle;
  var x = this.aX + this.xRadius * Math.cos(angle);
  var y = this.aY + this.yRadius * Math.sin(angle);

  if (this.aRotation !== 0) {
    var cos = Math.cos(this.aRotation);
    var sin = Math.sin(this.aRotation);
    var tx = x - this.aX;
    var ty = y - this.aY; // Rotate the point about the center of the ellipse.

    x = tx * cos - ty * sin + this.aX;
    y = tx * sin + ty * cos + this.aY;
  }

  return point.set(x, y);
};

EllipseCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.aX = source.aX;
  this.aY = source.aY;
  this.xRadius = source.xRadius;
  this.yRadius = source.yRadius;
  this.aStartAngle = source.aStartAngle;
  this.aEndAngle = source.aEndAngle;
  this.aClockwise = source.aClockwise;
  this.aRotation = source.aRotation;
  return this;
};

EllipseCurve.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.aX = this.aX;
  data.aY = this.aY;
  data.xRadius = this.xRadius;
  data.yRadius = this.yRadius;
  data.aStartAngle = this.aStartAngle;
  data.aEndAngle = this.aEndAngle;
  data.aClockwise = this.aClockwise;
  data.aRotation = this.aRotation;
  return data;
};

EllipseCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.aX = json.aX;
  this.aY = json.aY;
  this.xRadius = json.xRadius;
  this.yRadius = json.yRadius;
  this.aStartAngle = json.aStartAngle;
  this.aEndAngle = json.aEndAngle;
  this.aClockwise = json.aClockwise;
  this.aRotation = json.aRotation;
  return this;
};

function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
  EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
  this.type = 'ArcCurve';
}

ArcCurve.prototype = Object.create(EllipseCurve.prototype);
ArcCurve.prototype.constructor = ArcCurve;
ArcCurve.prototype.isArcCurve = true;
/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {
  var c0 = 0,
      c1 = 0,
      c2 = 0,
      c3 = 0;
  /*
   * Compute coefficients for a cubic polynomial
   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
   * such that
   *   p(0) = x0, p(1) = x1
   *  and
   *   p'(0) = t0, p'(1) = t1.
   */

  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }

  return {
    initCatmullRom: function (x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
      // compute tangents when parameterized in [t1,t2]
      var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]

      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function (t) {
      var t2 = t * t;
      var t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
} //


var tmp = new Vector3();
var px = new CubicPoly(),
    py = new CubicPoly(),
    pz = new CubicPoly();

function CatmullRomCurve3(points, closed, curveType, tension) {
  Curve.call(this);
  this.type = 'CatmullRomCurve3';
  this.points = points || [];
  this.closed = closed || false;
  this.curveType = curveType || 'centripetal';
  this.tension = tension || 0.5;
}

CatmullRomCurve3.prototype = Object.create(Curve.prototype);
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

CatmullRomCurve3.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector3();
  var points = this.points;
  var l = points.length;
  var p = (l - (this.closed ? 0 : 1)) * t;
  var intPoint = Math.floor(p);
  var weight = p - intPoint;

  if (this.closed) {
    intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
  } else if (weight === 0 && intPoint === l - 1) {
    intPoint = l - 2;
    weight = 1;
  }

  var p0, p1, p2, p3; // 4 points

  if (this.closed || intPoint > 0) {
    p0 = points[(intPoint - 1) % l];
  } else {
    // extrapolate first point
    tmp.subVectors(points[0], points[1]).add(points[0]);
    p0 = tmp;
  }

  p1 = points[intPoint % l];
  p2 = points[(intPoint + 1) % l];

  if (this.closed || intPoint + 2 < l) {
    p3 = points[(intPoint + 2) % l];
  } else {
    // extrapolate last point
    tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
    p3 = tmp;
  }

  if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
    // init Centripetal / Chordal Catmull-Rom
    var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
    var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
    var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
    var dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points

    if (dt1 < 1e-4) dt1 = 1.0;
    if (dt0 < 1e-4) dt0 = dt1;
    if (dt2 < 1e-4) dt2 = dt1;
    px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
    py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
    pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
  } else if (this.curveType === 'catmullrom') {
    px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
    py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
    pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
  }

  point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
  return point;
};

CatmullRomCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.points = [];

  for (var i = 0, l = source.points.length; i < l; i++) {
    var point = source.points[i];
    this.points.push(point.clone());
  }

  this.closed = source.closed;
  this.curveType = source.curveType;
  this.tension = source.tension;
  return this;
};

CatmullRomCurve3.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.points = [];

  for (var i = 0, l = this.points.length; i < l; i++) {
    var point = this.points[i];
    data.points.push(point.toArray());
  }

  data.closed = this.closed;
  data.curveType = this.curveType;
  data.tension = this.tension;
  return data;
};

CatmullRomCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.points = [];

  for (var i = 0, l = json.points.length; i < l; i++) {
    var point = json.points[i];
    this.points.push(new Vector3().fromArray(point));
  }

  this.closed = json.closed;
  this.curveType = json.curveType;
  this.tension = json.tension;
  return this;
};
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bézier_curve
 */


function CatmullRom(t, p0, p1, p2, p3) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  var t2 = t * t;
  var t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
} //


function QuadraticBezierP0(t, p) {
  var k = 1 - t;
  return k * k * p;
}

function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}

function QuadraticBezierP2(t, p) {
  return t * t * p;
}

function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
} //


function CubicBezierP0(t, p) {
  var k = 1 - t;
  return k * k * k * p;
}

function CubicBezierP1(t, p) {
  var k = 1 - t;
  return 3 * k * k * t * p;
}

function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}

function CubicBezierP3(t, p) {
  return t * t * t * p;
}

function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}

function CubicBezierCurve(v0, v1, v2, v3) {
  Curve.call(this);
  this.type = 'CubicBezierCurve';
  this.v0 = v0 || new Vector2();
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
  this.v3 = v3 || new Vector2();
}

CubicBezierCurve.prototype = Object.create(Curve.prototype);
CubicBezierCurve.prototype.constructor = CubicBezierCurve;
CubicBezierCurve.prototype.isCubicBezierCurve = true;

CubicBezierCurve.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector2();
  var v0 = this.v0,
      v1 = this.v1,
      v2 = this.v2,
      v3 = this.v3;
  point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
  return point;
};

CubicBezierCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  this.v3.copy(source.v3);
  return this;
};

CubicBezierCurve.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  data.v3 = this.v3.toArray();
  return data;
};

CubicBezierCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  this.v3.fromArray(json.v3);
  return this;
};

function CubicBezierCurve3(v0, v1, v2, v3) {
  Curve.call(this);
  this.type = 'CubicBezierCurve3';
  this.v0 = v0 || new Vector3();
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
  this.v3 = v3 || new Vector3();
}

CubicBezierCurve3.prototype = Object.create(Curve.prototype);
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

CubicBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector3();
  var v0 = this.v0,
      v1 = this.v1,
      v2 = this.v2,
      v3 = this.v3;
  point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
  return point;
};

CubicBezierCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  this.v3.copy(source.v3);
  return this;
};

CubicBezierCurve3.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  data.v3 = this.v3.toArray();
  return data;
};

CubicBezierCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  this.v3.fromArray(json.v3);
  return this;
};

function LineCurve(v1, v2) {
  Curve.call(this);
  this.type = 'LineCurve';
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
}

LineCurve.prototype = Object.create(Curve.prototype);
LineCurve.prototype.constructor = LineCurve;
LineCurve.prototype.isLineCurve = true;

LineCurve.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector2();

  if (t === 1) {
    point.copy(this.v2);
  } else {
    point.copy(this.v2).sub(this.v1);
    point.multiplyScalar(t).add(this.v1);
  }

  return point;
}; // Line curve is linear, so we can overwrite default getPointAt


LineCurve.prototype.getPointAt = function (u, optionalTarget) {
  return this.getPoint(u, optionalTarget);
};

LineCurve.prototype.getTangent = function ()
/* t */
{
  var tangent = this.v2.clone().sub(this.v1);
  return tangent.normalize();
};

LineCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};

LineCurve.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};

LineCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};

function LineCurve3(v1, v2) {
  Curve.call(this);
  this.type = 'LineCurve3';
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
}

LineCurve3.prototype = Object.create(Curve.prototype);
LineCurve3.prototype.constructor = LineCurve3;
LineCurve3.prototype.isLineCurve3 = true;

LineCurve3.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector3();

  if (t === 1) {
    point.copy(this.v2);
  } else {
    point.copy(this.v2).sub(this.v1);
    point.multiplyScalar(t).add(this.v1);
  }

  return point;
}; // Line curve is linear, so we can overwrite default getPointAt


LineCurve3.prototype.getPointAt = function (u, optionalTarget) {
  return this.getPoint(u, optionalTarget);
};

LineCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};

LineCurve3.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};

LineCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};

function QuadraticBezierCurve(v0, v1, v2) {
  Curve.call(this);
  this.type = 'QuadraticBezierCurve';
  this.v0 = v0 || new Vector2();
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
}

QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

QuadraticBezierCurve.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector2();
  var v0 = this.v0,
      v1 = this.v1,
      v2 = this.v2;
  point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
  return point;
};

QuadraticBezierCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};

QuadraticBezierCurve.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};

QuadraticBezierCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};

function QuadraticBezierCurve3(v0, v1, v2) {
  Curve.call(this);
  this.type = 'QuadraticBezierCurve3';
  this.v0 = v0 || new Vector3();
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
}

QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

QuadraticBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector3();
  var v0 = this.v0,
      v1 = this.v1,
      v2 = this.v2;
  point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
  return point;
};

QuadraticBezierCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};

QuadraticBezierCurve3.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};

QuadraticBezierCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};

function SplineCurve(points
/* array of Vector2 */
) {
  Curve.call(this);
  this.type = 'SplineCurve';
  this.points = points || [];
}

SplineCurve.prototype = Object.create(Curve.prototype);
SplineCurve.prototype.constructor = SplineCurve;
SplineCurve.prototype.isSplineCurve = true;

SplineCurve.prototype.getPoint = function (t, optionalTarget) {
  var point = optionalTarget || new Vector2();
  var points = this.points;
  var p = (points.length - 1) * t;
  var intPoint = Math.floor(p);
  var weight = p - intPoint;
  var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
  var p1 = points[intPoint];
  var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
  var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
  point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
  return point;
};

SplineCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.points = [];

  for (var i = 0, l = source.points.length; i < l; i++) {
    var point = source.points[i];
    this.points.push(point.clone());
  }

  return this;
};

SplineCurve.prototype.toJSON = function () {
  var data = Curve.prototype.toJSON.call(this);
  data.points = [];

  for (var i = 0, l = this.points.length; i < l; i++) {
    var point = this.points[i];
    data.points.push(point.toArray());
  }

  return data;
};

SplineCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.points = [];

  for (var i = 0, l = json.points.length; i < l; i++) {
    var point = json.points[i];
    this.points.push(new Vector2().fromArray(point));
  }

  return this;
};

var Curves =
/*#__PURE__*/
Object.freeze({
  ArcCurve: ArcCurve,
  CatmullRomCurve3: CatmullRomCurve3,
  CubicBezierCurve: CubicBezierCurve,
  CubicBezierCurve3: CubicBezierCurve3,
  EllipseCurve: EllipseCurve,
  LineCurve: LineCurve,
  LineCurve3: LineCurve3,
  QuadraticBezierCurve: QuadraticBezierCurve,
  QuadraticBezierCurve3: QuadraticBezierCurve3,
  SplineCurve: SplineCurve
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

function CurvePath() {
  Curve.call(this);
  this.type = 'CurvePath';
  this.curves = [];
  this.autoClose = false; // Automatically closes the path
}

CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
  constructor: CurvePath,
  add: function (curve) {
    this.curves.push(curve);
  },
  closePath: function () {
    // Add a line curve if start and end of lines are not connected
    var startPoint = this.curves[0].getPoint(0);
    var endPoint = this.curves[this.curves.length - 1].getPoint(1);

    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  },
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint: function (t) {
    var d = t * this.getLength();
    var curveLengths = this.getCurveLengths();
    var i = 0; // To think about boundaries points.

    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        var diff = curveLengths[i] - d;
        var curve = this.curves[i];
        var segmentLength = curve.getLength();
        var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u);
      }

      i++;
    }

    return null; // loop where sum != 0, sum > d , sum+1 <d
  },
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength: function () {
    var lens = this.getCurveLengths();
    return lens[lens.length - 1];
  },
  // cacheLengths must be recalculated.
  updateArcLengths: function () {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  },
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths: function () {
    // We use cache values if curves and cache array are same length
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    } // Get length of sub-curve
    // Push sums into cached array


    var lengths = [],
        sums = 0;

    for (var i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }

    this.cacheLengths = lengths;
    return lengths;
  },
  getSpacedPoints: function (divisions) {
    if (divisions === undefined) divisions = 40;
    var points = [];

    for (var i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }

    if (this.autoClose) {
      points.push(points[0]);
    }

    return points;
  },
  getPoints: function (divisions) {
    divisions = divisions || 12;
    var points = [],
        last;

    for (var i = 0, curves = this.curves; i < curves.length; i++) {
      var curve = curves[i];
      var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      var pts = curve.getPoints(resolution);

      for (var j = 0; j < pts.length; j++) {
        var point = pts[j];
        if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

        points.push(point);
        last = point;
      }
    }

    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }

    return points;
  },
  copy: function (source) {
    Curve.prototype.copy.call(this, source);
    this.curves = [];

    for (var i = 0, l = source.curves.length; i < l; i++) {
      var curve = source.curves[i];
      this.curves.push(curve.clone());
    }

    this.autoClose = source.autoClose;
    return this;
  },
  toJSON: function () {
    var data = Curve.prototype.toJSON.call(this);
    data.autoClose = this.autoClose;
    data.curves = [];

    for (var i = 0, l = this.curves.length; i < l; i++) {
      var curve = this.curves[i];
      data.curves.push(curve.toJSON());
    }

    return data;
  },
  fromJSON: function (json) {
    Curve.prototype.fromJSON.call(this, json);
    this.autoClose = json.autoClose;
    this.curves = [];

    for (var i = 0, l = json.curves.length; i < l; i++) {
      var curve = json.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }

    return this;
  }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 **/

function Path(points) {
  CurvePath.call(this);
  this.type = 'Path';
  this.currentPoint = new Vector2();

  if (points) {
    this.setFromPoints(points);
  }
}

Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
  constructor: Path,
  setFromPoints: function (points) {
    this.moveTo(points[0].x, points[0].y);

    for (var i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y);
    }
  },
  moveTo: function (x, y) {
    this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?
  },
  lineTo: function (x, y) {
    var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
    this.curves.push(curve);
    this.currentPoint.set(x, y);
  },
  quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
    var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
  },
  bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
  },
  splineThru: function (pts
  /*Array of Vector*/
  ) {
    var npts = [this.currentPoint.clone()].concat(pts);
    var curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
  },
  arc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    var x0 = this.currentPoint.x;
    var y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
  },
  absarc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
  },
  ellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    var x0 = this.currentPoint.x;
    var y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
  },
  absellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

    if (this.curves.length > 0) {
      // if a previous curve is present, attempt to join
      var firstPoint = curve.getPoint(0);

      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }

    this.curves.push(curve);
    var lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
  },
  copy: function (source) {
    CurvePath.prototype.copy.call(this, source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  },
  toJSON: function () {
    var data = CurvePath.prototype.toJSON.call(this);
    data.currentPoint = this.currentPoint.toArray();
    return data;
  },
  fromJSON: function (json) {
    CurvePath.prototype.fromJSON.call(this, json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/
// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

function Shape(points) {
  Path.call(this, points);
  this.uuid = _Math.generateUUID();
  this.type = 'Shape';
  this.holes = [];
}

Shape.prototype = Object.assign(Object.create(Path.prototype), {
  constructor: Shape,
  getPointsHoles: function (divisions) {
    var holesPts = [];

    for (var i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }

    return holesPts;
  },
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints: function (divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  },
  copy: function (source) {
    Path.prototype.copy.call(this, source);
    this.holes = [];

    for (var i = 0, l = source.holes.length; i < l; i++) {
      var hole = source.holes[i];
      this.holes.push(hole.clone());
    }

    return this;
  },
  toJSON: function () {
    var data = Path.prototype.toJSON.call(this);
    data.uuid = this.uuid;
    data.holes = [];

    for (var i = 0, l = this.holes.length; i < l; i++) {
      var hole = this.holes[i];
      data.holes.push(hole.toJSON());
    }

    return data;
  },
  fromJSON: function (json) {
    Path.prototype.fromJSON.call(this, json);
    this.uuid = json.uuid;
    this.holes = [];

    for (var i = 0, l = json.holes.length; i < l; i++) {
      var hole = json.holes[i];
      this.holes.push(new Path().fromJSON(hole));
    }

    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Light(color, intensity) {
  Object3D.call(this);
  this.type = 'Light';
  this.color = new Color(color);
  this.intensity = intensity !== undefined ? intensity : 1;
  this.receiveShadow = undefined;
}

Light.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Light,
  isLight: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  },
  toJSON: function (meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== undefined) data.object.distance = this.distance;
    if (this.angle !== undefined) data.object.angle = this.angle;
    if (this.decay !== undefined) data.object.decay = this.decay;
    if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
    if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
    return data;
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */

function HemisphereLight(skyColor, groundColor, intensity) {
  Light.call(this, skyColor, intensity);
  this.type = 'HemisphereLight';
  this.castShadow = undefined;
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.groundColor = new Color(groundColor);
}

HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: HemisphereLight,
  isHemisphereLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function LightShadow(camera) {
  this.camera = camera;
  this.bias = 0;
  this.radius = 1;
  this.mapSize = new Vector2(512, 512);
  this.map = null;
  this.mapPass = null;
  this.matrix = new Matrix4();
  this._frustum = new Frustum();
  this._frameExtents = new Vector2(1, 1);
  this._viewportCount = 1;
  this._viewports = [new Vector4(0, 0, 1, 1)];
}

Object.assign(LightShadow.prototype, {
  _projScreenMatrix: new Matrix4(),
  _lightPositionWorld: new Vector3(),
  _lookTarget: new Vector3(),
  getViewportCount: function () {
    return this._viewportCount;
  },
  getFrustum: function () {
    return this._frustum;
  },
  updateMatrices: function (light) {
    var shadowCamera = this.camera,
        shadowMatrix = this.matrix,
        projScreenMatrix = this._projScreenMatrix,
        lookTarget = this._lookTarget,
        lightPositionWorld = this._lightPositionWorld;
    lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(lightPositionWorld);
    lookTarget.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(lookTarget);
    shadowCamera.updateMatrixWorld();
    projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);

    this._frustum.setFromMatrix(projScreenMatrix);

    shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  },
  getViewport: function (viewportIndex) {
    return this._viewports[viewportIndex];
  },
  getFrameExtents: function () {
    return this._frameExtents;
  },
  copy: function (source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  toJSON: function () {
    var object = {};
    if (this.bias !== 0) object.bias = this.bias;
    if (this.radius !== 1) object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function SpotLightShadow() {
  LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
}

SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: SpotLightShadow,
  isSpotLightShadow: true,
  updateMatrices: function (light, viewCamera, viewportIndex) {
    var camera = this.camera;
    var fov = _Math.RAD2DEG * 2 * light.angle;
    var aspect = this.mapSize.width / this.mapSize.height;
    var far = light.distance || camera.far;

    if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
      camera.fov = fov;
      camera.aspect = aspect;
      camera.far = far;
      camera.updateProjectionMatrix();
    }

    LightShadow.prototype.updateMatrices.call(this, light, viewCamera, viewportIndex);
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */

function SpotLight(color, intensity, distance, angle, penumbra, decay) {
  Light.call(this, color, intensity);
  this.type = 'SpotLight';
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  Object.defineProperty(this, 'power', {
    get: function () {
      // intensity = power per solid angle.
      // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      return this.intensity * Math.PI;
    },
    set: function (power) {
      // intensity = power per solid angle.
      // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      this.intensity = power / Math.PI;
    }
  });
  this.distance = distance !== undefined ? distance : 0;
  this.angle = angle !== undefined ? angle : Math.PI / 3;
  this.penumbra = penumbra !== undefined ? penumbra : 0;
  this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.

  this.shadow = new SpotLightShadow();
}

SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: SpotLight,
  isSpotLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
});

function PointLightShadow() {
  LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
  this._frameExtents = new Vector2(4, 2);
  this._viewportCount = 6;
  this._viewports = [// These viewports map a cube-map onto a 2D texture with the
  // following orientation:
  //
  //  xzXZ
  //   y Y
  //
  // X - Positive x direction
  // x - Negative x direction
  // Y - Positive y direction
  // y - Negative y direction
  // Z - Positive z direction
  // z - Negative z direction
  // positive X
  new Vector4(2, 1, 1, 1), // negative X
  new Vector4(0, 1, 1, 1), // positive Z
  new Vector4(3, 1, 1, 1), // negative Z
  new Vector4(1, 1, 1, 1), // positive Y
  new Vector4(3, 0, 1, 1), // negative Y
  new Vector4(1, 0, 1, 1)];
  this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
  this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
}

PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: PointLightShadow,
  isPointLightShadow: true,
  updateMatrices: function (light, viewCamera, viewportIndex) {
    var camera = this.camera,
        shadowMatrix = this.matrix,
        lightPositionWorld = this._lightPositionWorld,
        lookTarget = this._lookTarget,
        projScreenMatrix = this._projScreenMatrix;
    lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(lightPositionWorld);
    lookTarget.copy(camera.position);
    lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);
    projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

    this._frustum.setFromMatrix(projScreenMatrix);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function PointLight(color, intensity, distance, decay) {
  Light.call(this, color, intensity);
  this.type = 'PointLight';
  Object.defineProperty(this, 'power', {
    get: function () {
      // intensity = power per solid angle.
      // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      return this.intensity * 4 * Math.PI;
    },
    set: function (power) {
      // intensity = power per solid angle.
      // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      this.intensity = power / (4 * Math.PI);
    }
  });
  this.distance = distance !== undefined ? distance : 0;
  this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.

  this.shadow = new PointLightShadow();
}

PointLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: PointLight,
  isPointLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 * @author arose / http://github.com/arose
 */

function OrthographicCamera(left, right, top, bottom, near, far) {
  Camera.call(this);
  this.type = 'OrthographicCamera';
  this.zoom = 1;
  this.view = null;
  this.left = left !== undefined ? left : -1;
  this.right = right !== undefined ? right : 1;
  this.top = top !== undefined ? top : 1;
  this.bottom = bottom !== undefined ? bottom : -1;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;
  this.updateProjectionMatrix();
}

OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: OrthographicCamera,
  isOrthographicCamera: true,
  copy: function (source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  },
  setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }

    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function () {
    if (this.view !== null) {
      this.view.enabled = false;
    }

    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function () {
    var dx = (this.right - this.left) / (2 * this.zoom);
    var dy = (this.top - this.bottom) / (2 * this.zoom);
    var cx = (this.right + this.left) / 2;
    var cy = (this.top + this.bottom) / 2;
    var left = cx - dx;
    var right = cx + dx;
    var top = cy + dy;
    var bottom = cy - dy;

    if (this.view !== null && this.view.enabled) {
      var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
      var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
      var scaleW = (this.right - this.left) / this.view.width;
      var scaleH = (this.top - this.bottom) / this.view.height;
      left += scaleW * (this.view.offsetX / zoomW);
      right = left + scaleW * (this.view.width / zoomW);
      top -= scaleH * (this.view.offsetY / zoomH);
      bottom = top - scaleH * (this.view.height / zoomH);
    }

    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function (meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectionalLightShadow() {
  LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
}

DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: DirectionalLightShadow,
  isDirectionalLightShadow: true,
  updateMatrices: function (light, viewCamera, viewportIndex) {
    LightShadow.prototype.updateMatrices.call(this, light, viewCamera, viewportIndex);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function DirectionalLight(color, intensity) {
  Light.call(this, color, intensity);
  this.type = 'DirectionalLight';
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  this.shadow = new DirectionalLightShadow();
}

DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: DirectionalLight,
  isDirectionalLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function AmbientLight(color, intensity) {
  Light.call(this, color, intensity);
  this.type = 'AmbientLight';
  this.castShadow = undefined;
}

AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: AmbientLight,
  isAmbientLight: true
});
/**
 * @author abelnation / http://github.com/abelnation
 */

function RectAreaLight(color, intensity, width, height) {
  Light.call(this, color, intensity);
  this.type = 'RectAreaLight';
  this.width = width !== undefined ? width : 10;
  this.height = height !== undefined ? height : 10;
}

RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: RectAreaLight,
  isRectAreaLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.width = source.width;
    this.height = source.height;
    return this;
  },
  toJSON: function (meta) {
    var data = Light.prototype.toJSON.call(this, meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function MaterialLoader(manager) {
  Loader.call(this, manager);
  this.textures = {};
}

MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: MaterialLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.load(url, function (text) {
      onLoad(scope.parse(JSON.parse(text)));
    }, onProgress, onError);
  },
  parse: function (json) {
    var textures = this.textures;

    function getTexture(name) {
      if (textures[name] === undefined) {
        console.warn('THREE.MaterialLoader: Undefined texture', name);
      }

      return textures[name];
    }

    var material = new Materials[json.type]();
    if (json.uuid !== undefined) material.uuid = json.uuid;
    if (json.name !== undefined) material.name = json.name;
    if (json.color !== undefined) material.color.setHex(json.color);
    if (json.roughness !== undefined) material.roughness = json.roughness;
    if (json.metalness !== undefined) material.metalness = json.metalness;
    if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
    if (json.specular !== undefined) material.specular.setHex(json.specular);
    if (json.shininess !== undefined) material.shininess = json.shininess;
    if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
    if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
    if (json.vertexColors !== undefined) material.vertexColors = json.vertexColors;
    if (json.fog !== undefined) material.fog = json.fog;
    if (json.flatShading !== undefined) material.flatShading = json.flatShading;
    if (json.blending !== undefined) material.blending = json.blending;
    if (json.combine !== undefined) material.combine = json.combine;
    if (json.side !== undefined) material.side = json.side;
    if (json.opacity !== undefined) material.opacity = json.opacity;
    if (json.transparent !== undefined) material.transparent = json.transparent;
    if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
    if (json.depthTest !== undefined) material.depthTest = json.depthTest;
    if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
    if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
    if (json.wireframe !== undefined) material.wireframe = json.wireframe;
    if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
    if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
    if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
    if (json.rotation !== undefined) material.rotation = json.rotation;
    if (json.linewidth !== 1) material.linewidth = json.linewidth;
    if (json.dashSize !== undefined) material.dashSize = json.dashSize;
    if (json.gapSize !== undefined) material.gapSize = json.gapSize;
    if (json.scale !== undefined) material.scale = json.scale;
    if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
    if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
    if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
    if (json.skinning !== undefined) material.skinning = json.skinning;
    if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
    if (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;
    if (json.dithering !== undefined) material.dithering = json.dithering;
    if (json.visible !== undefined) material.visible = json.visible;
    if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
    if (json.userData !== undefined) material.userData = json.userData; // Shader Material

    if (json.uniforms !== undefined) {
      for (var name in json.uniforms) {
        var uniform = json.uniforms[name];
        material.uniforms[name] = {};

        switch (uniform.type) {
          case 't':
            material.uniforms[name].value = getTexture(uniform.value);
            break;

          case 'c':
            material.uniforms[name].value = new Color().setHex(uniform.value);
            break;

          case 'v2':
            material.uniforms[name].value = new Vector2().fromArray(uniform.value);
            break;

          case 'v3':
            material.uniforms[name].value = new Vector3().fromArray(uniform.value);
            break;

          case 'v4':
            material.uniforms[name].value = new Vector4().fromArray(uniform.value);
            break;

          case 'm3':
            material.uniforms[name].value = new Matrix3().fromArray(uniform.value);

          case 'm4':
            material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
            break;

          default:
            material.uniforms[name].value = uniform.value;
        }
      }
    }

    if (json.defines !== undefined) material.defines = json.defines;
    if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
    if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;

    if (json.extensions !== undefined) {
      for (var key in json.extensions) {
        material.extensions[key] = json.extensions[key];
      }
    } // Deprecated


    if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
    // for PointsMaterial

    if (json.size !== undefined) material.size = json.size;
    if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps

    if (json.map !== undefined) material.map = getTexture(json.map);
    if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);

    if (json.alphaMap !== undefined) {
      material.alphaMap = getTexture(json.alphaMap);
      material.transparent = true;
    }

    if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
    if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
    if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
    if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;

    if (json.normalScale !== undefined) {
      var normalScale = json.normalScale;

      if (Array.isArray(normalScale) === false) {
        // Blender exporter used to export a scalar. See #7459
        normalScale = [normalScale, normalScale];
      }

      material.normalScale = new Vector2().fromArray(normalScale);
    }

    if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
    if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
    if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
    if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
    if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
    if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
    if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
    if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
    if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
    if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
    if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
    if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
    if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
    if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
    if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
    if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
    if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
    if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
    if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
    return material;
  },
  setTextures: function (value) {
    this.textures = value;
    return this;
  }
});
/**
 * @author Don McCurdy / https://www.donmccurdy.com
 */

var LoaderUtils = {
  decodeText: function (array) {
    if (typeof TextDecoder !== 'undefined') {
      return new TextDecoder().decode(array);
    } // Avoid the String.fromCharCode.apply(null, array) shortcut, which
    // throws a "maximum call stack size exceeded" error for large arrays.


    var s = '';

    for (var i = 0, il = array.length; i < il; i++) {
      // Implicitly assumes little-endian.
      s += String.fromCharCode(array[i]);
    }

    try {
      // merges multi-byte utf-8 characters.
      return decodeURIComponent(escape(s));
    } catch (e) {
      // see #16358
      return s;
    }
  },
  extractUrlBase: function (url) {
    var index = url.lastIndexOf('/');
    if (index === -1) return './';
    return url.substr(0, index + 1);
  }
};
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

exports.LoaderUtils = LoaderUtils;

function InstancedBufferGeometry() {
  BufferGeometry.call(this);
  this.type = 'InstancedBufferGeometry';
  this.maxInstancedCount = undefined;
}

InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
  constructor: InstancedBufferGeometry,
  isInstancedBufferGeometry: true,
  copy: function (source) {
    BufferGeometry.prototype.copy.call(this, source);
    this.maxInstancedCount = source.maxInstancedCount;
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  toJSON: function () {
    var data = BufferGeometry.prototype.toJSON.call(this);
    data.maxInstancedCount = this.maxInstancedCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
});
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
  if (typeof normalized === 'number') {
    meshPerAttribute = normalized;
    normalized = false;
    console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
  }

  BufferAttribute.call(this, array, itemSize, normalized);
  this.meshPerAttribute = meshPerAttribute || 1;
}

InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
  constructor: InstancedBufferAttribute,
  isInstancedBufferAttribute: true,
  copy: function (source) {
    BufferAttribute.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  toJSON: function () {
    var data = BufferAttribute.prototype.toJSON.call(this);
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function BufferGeometryLoader(manager) {
  Loader.call(this, manager);
}

BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: BufferGeometryLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.load(url, function (text) {
      onLoad(scope.parse(JSON.parse(text)));
    }, onProgress, onError);
  },
  parse: function (json) {
    var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
    var index = json.data.index;

    if (index !== undefined) {
      var typedArray = new TYPED_ARRAYS[index.type](index.array);
      geometry.setIndex(new BufferAttribute(typedArray, 1));
    }

    var attributes = json.data.attributes;

    for (var key in attributes) {
      var attribute = attributes[key];
      var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
      var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
      var bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
      if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
      geometry.addAttribute(key, bufferAttribute);
    }

    var morphAttributes = json.data.morphAttributes;

    if (morphAttributes) {
      for (var key in morphAttributes) {
        var attributeArray = morphAttributes[key];
        var array = [];

        for (var i = 0, il = attributeArray.length; i < il; i++) {
          var attribute = attributeArray[i];
          var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
          var bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
          if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
          array.push(bufferAttribute);
        }

        geometry.morphAttributes[key] = array;
      }
    }

    var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

    if (groups !== undefined) {
      for (var i = 0, n = groups.length; i !== n; ++i) {
        var group = groups[i];
        geometry.addGroup(group.start, group.count, group.materialIndex);
      }
    }

    var boundingSphere = json.data.boundingSphere;

    if (boundingSphere !== undefined) {
      var center = new Vector3();

      if (boundingSphere.center !== undefined) {
        center.fromArray(boundingSphere.center);
      }

      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
    }

    if (json.name) geometry.name = json.name;
    if (json.userData) geometry.userData = json.userData;
    return geometry;
  }
});
var TYPED_ARRAYS = {
  Int8Array: Int8Array,
  Uint8Array: Uint8Array,
  // Workaround for IE11 pre KB2929437. See #11440
  Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
  Int16Array: Int16Array,
  Uint16Array: Uint16Array,
  Int32Array: Int32Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array
};
/**
 * @author mrdoob / http://mrdoob.com/
 */

function ObjectLoader(manager) {
  Loader.call(this, manager);
}

ObjectLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ObjectLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    var loader = new FileLoader(scope.manager);
    loader.setPath(this.path);
    loader.load(url, function (text) {
      var json = null;

      try {
        json = JSON.parse(text);
      } catch (error) {
        if (onError !== undefined) onError(error);
        console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
        return;
      }

      var metadata = json.metadata;

      if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
        console.error('THREE.ObjectLoader: Can\'t load ' + url);
        return;
      }

      scope.parse(json, onLoad);
    }, onProgress, onError);
  },
  parse: function (json, onLoad) {
    var shapes = this.parseShape(json.shapes);
    var geometries = this.parseGeometries(json.geometries, shapes);
    var images = this.parseImages(json.images, function () {
      if (onLoad !== undefined) onLoad(object);
    });
    var textures = this.parseTextures(json.textures, images);
    var materials = this.parseMaterials(json.materials, textures);
    var object = this.parseObject(json.object, geometries, materials);

    if (json.animations) {
      object.animations = this.parseAnimations(json.animations);
    }

    if (json.images === undefined || json.images.length === 0) {
      if (onLoad !== undefined) onLoad(object);
    }

    return object;
  },
  parseShape: function (json) {
    var shapes = {};

    if (json !== undefined) {
      for (var i = 0, l = json.length; i < l; i++) {
        var shape = new Shape().fromJSON(json[i]);
        shapes[shape.uuid] = shape;
      }
    }

    return shapes;
  },
  parseGeometries: function (json, shapes) {
    var geometries = {};

    if (json !== undefined) {
      var bufferGeometryLoader = new BufferGeometryLoader();

      for (var i = 0, l = json.length; i < l; i++) {
        var geometry;
        var data = json[i];

        switch (data.type) {
          case 'PlaneGeometry':
          case 'PlaneBufferGeometry':
            geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
            break;

          case 'BoxGeometry':
          case 'BoxBufferGeometry':
          case 'CubeGeometry':
            // backwards compatible
            geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
            break;

          case 'CircleGeometry':
          case 'CircleBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
            break;

          case 'CylinderGeometry':
          case 'CylinderBufferGeometry':
            geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;

          case 'ConeGeometry':
          case 'ConeBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;

          case 'SphereGeometry':
          case 'SphereBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
            break;

          case 'DodecahedronGeometry':
          case 'DodecahedronBufferGeometry':
          case 'IcosahedronGeometry':
          case 'IcosahedronBufferGeometry':
          case 'OctahedronGeometry':
          case 'OctahedronBufferGeometry':
          case 'TetrahedronGeometry':
          case 'TetrahedronBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.detail);
            break;

          case 'RingGeometry':
          case 'RingBufferGeometry':
            geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
            break;

          case 'TorusGeometry':
          case 'TorusBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
            break;

          case 'TorusKnotGeometry':
          case 'TorusKnotBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
            break;

          case 'TubeGeometry':
          case 'TubeBufferGeometry':
            // This only works for built-in curves (e.g. CatmullRomCurve3).
            // User defined curves or instances of CurvePath will not be deserialized.
            geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
            break;

          case 'LatheGeometry':
          case 'LatheBufferGeometry':
            geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
            break;

          case 'PolyhedronGeometry':
          case 'PolyhedronBufferGeometry':
            geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
            break;

          case 'ShapeGeometry':
          case 'ShapeBufferGeometry':
            var geometryShapes = [];

            for (var j = 0, jl = data.shapes.length; j < jl; j++) {
              var shape = shapes[data.shapes[j]];
              geometryShapes.push(shape);
            }

            geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
            break;

          case 'ExtrudeGeometry':
          case 'ExtrudeBufferGeometry':
            var geometryShapes = [];

            for (var j = 0, jl = data.shapes.length; j < jl; j++) {
              var shape = shapes[data.shapes[j]];
              geometryShapes.push(shape);
            }

            var extrudePath = data.options.extrudePath;

            if (extrudePath !== undefined) {
              data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
            }

            geometry = new Geometries[data.type](geometryShapes, data.options);
            break;

          case 'BufferGeometry':
          case 'InstancedBufferGeometry':
            geometry = bufferGeometryLoader.parse(data);
            break;

          case 'Geometry':
            if ('THREE' in window && 'LegacyJSONLoader' in THREE) {
              var geometryLoader = new THREE.LegacyJSONLoader();
              geometry = geometryLoader.parse(data, this.resourcePath).geometry;
            } else {
              console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
            }

            break;

          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
            continue;
        }

        geometry.uuid = data.uuid;
        if (data.name !== undefined) geometry.name = data.name;
        if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
        geometries[data.uuid] = geometry;
      }
    }

    return geometries;
  },
  parseMaterials: function (json, textures) {
    var cache = {}; // MultiMaterial

    var materials = {};

    if (json !== undefined) {
      var loader = new MaterialLoader();
      loader.setTextures(textures);

      for (var i = 0, l = json.length; i < l; i++) {
        var data = json[i];

        if (data.type === 'MultiMaterial') {
          // Deprecated
          var array = [];

          for (var j = 0; j < data.materials.length; j++) {
            var material = data.materials[j];

            if (cache[material.uuid] === undefined) {
              cache[material.uuid] = loader.parse(material);
            }

            array.push(cache[material.uuid]);
          }

          materials[data.uuid] = array;
        } else {
          if (cache[data.uuid] === undefined) {
            cache[data.uuid] = loader.parse(data);
          }

          materials[data.uuid] = cache[data.uuid];
        }
      }
    }

    return materials;
  },
  parseAnimations: function (json) {
    var animations = [];

    for (var i = 0; i < json.length; i++) {
      var data = json[i];
      var clip = AnimationClip.parse(data);
      if (data.uuid !== undefined) clip.uuid = data.uuid;
      animations.push(clip);
    }

    return animations;
  },
  parseImages: function (json, onLoad) {
    var scope = this;
    var images = {};

    function loadImage(url) {
      scope.manager.itemStart(url);
      return loader.load(url, function () {
        scope.manager.itemEnd(url);
      }, undefined, function () {
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
    }

    if (json !== undefined && json.length > 0) {
      var manager = new LoadingManager(onLoad);
      var loader = new ImageLoader(manager);
      loader.setCrossOrigin(this.crossOrigin);

      for (var i = 0, il = json.length; i < il; i++) {
        var image = json[i];
        var url = image.url;

        if (Array.isArray(url)) {
          // load array of images e.g CubeTexture
          images[image.uuid] = [];

          for (var j = 0, jl = url.length; j < jl; j++) {
            var currentUrl = url[j];
            var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;
            images[image.uuid].push(loadImage(path));
          }
        } else {
          // load single image
          var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.resourcePath + image.url;
          images[image.uuid] = loadImage(path);
        }
      }
    }

    return images;
  },
  parseTextures: function (json, images) {
    function parseConstant(value, type) {
      if (typeof value === 'number') return value;
      console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
      return type[value];
    }

    var textures = {};

    if (json !== undefined) {
      for (var i = 0, l = json.length; i < l; i++) {
        var data = json[i];

        if (data.image === undefined) {
          console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
        }

        if (images[data.image] === undefined) {
          console.warn('THREE.ObjectLoader: Undefined image', data.image);
        }

        var texture;

        if (Array.isArray(images[data.image])) {
          texture = new CubeTexture(images[data.image]);
        } else {
          texture = new Texture(images[data.image]);
        }

        texture.needsUpdate = true;
        texture.uuid = data.uuid;
        if (data.name !== undefined) texture.name = data.name;
        if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
        if (data.offset !== undefined) texture.offset.fromArray(data.offset);
        if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
        if (data.center !== undefined) texture.center.fromArray(data.center);
        if (data.rotation !== undefined) texture.rotation = data.rotation;

        if (data.wrap !== undefined) {
          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
        }

        if (data.format !== undefined) texture.format = data.format;
        if (data.type !== undefined) texture.type = data.type;
        if (data.encoding !== undefined) texture.encoding = data.encoding;
        if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
        if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
        if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
        if (data.flipY !== undefined) texture.flipY = data.flipY;
        if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
        if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
        textures[data.uuid] = texture;
      }
    }

    return textures;
  },
  parseObject: function (data, geometries, materials) {
    var object;

    function getGeometry(name) {
      if (geometries[name] === undefined) {
        console.warn('THREE.ObjectLoader: Undefined geometry', name);
      }

      return geometries[name];
    }

    function getMaterial(name) {
      if (name === undefined) return undefined;

      if (Array.isArray(name)) {
        var array = [];

        for (var i = 0, l = name.length; i < l; i++) {
          var uuid = name[i];

          if (materials[uuid] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined material', uuid);
          }

          array.push(materials[uuid]);
        }

        return array;
      }

      if (materials[name] === undefined) {
        console.warn('THREE.ObjectLoader: Undefined material', name);
      }

      return materials[name];
    }

    switch (data.type) {
      case 'Scene':
        object = new Scene();

        if (data.background !== undefined) {
          if (Number.isInteger(data.background)) {
            object.background = new Color(data.background);
          }
        }

        if (data.fog !== undefined) {
          if (data.fog.type === 'Fog') {
            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
          } else if (data.fog.type === 'FogExp2') {
            object.fog = new FogExp2(data.fog.color, data.fog.density);
          }
        }

        break;

      case 'PerspectiveCamera':
        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
        if (data.focus !== undefined) object.focus = data.focus;
        if (data.zoom !== undefined) object.zoom = data.zoom;
        if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
        if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
        if (data.view !== undefined) object.view = Object.assign({}, data.view);
        break;

      case 'OrthographicCamera':
        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
        if (data.zoom !== undefined) object.zoom = data.zoom;
        if (data.view !== undefined) object.view = Object.assign({}, data.view);
        break;

      case 'AmbientLight':
        object = new AmbientLight(data.color, data.intensity);
        break;

      case 'DirectionalLight':
        object = new DirectionalLight(data.color, data.intensity);
        break;

      case 'PointLight':
        object = new PointLight(data.color, data.intensity, data.distance, data.decay);
        break;

      case 'RectAreaLight':
        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
        break;

      case 'SpotLight':
        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
        break;

      case 'HemisphereLight':
        object = new HemisphereLight(data.color, data.groundColor, data.intensity);
        break;

      case 'SkinnedMesh':
        console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');

      case 'Mesh':
        var geometry = getGeometry(data.geometry);
        var material = getMaterial(data.material);

        if (geometry.bones && geometry.bones.length > 0) {
          object = new SkinnedMesh(geometry, material);
        } else {
          object = new Mesh(geometry, material);
        }

        if (data.drawMode !== undefined) object.setDrawMode(data.drawMode);
        break;

      case 'LOD':
        object = new LOD();
        break;

      case 'Line':
        object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
        break;

      case 'LineLoop':
        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
        break;

      case 'LineSegments':
        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
        break;

      case 'PointCloud':
      case 'Points':
        object = new Points(getGeometry(data.geometry), getMaterial(data.material));
        break;

      case 'Sprite':
        object = new Sprite(getMaterial(data.material));
        break;

      case 'Group':
        object = new Group();
        break;

      default:
        object = new Object3D();
    }

    object.uuid = data.uuid;
    if (data.name !== undefined) object.name = data.name;

    if (data.matrix !== undefined) {
      object.matrix.fromArray(data.matrix);
      if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
      if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
    } else {
      if (data.position !== undefined) object.position.fromArray(data.position);
      if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
      if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
      if (data.scale !== undefined) object.scale.fromArray(data.scale);
    }

    if (data.castShadow !== undefined) object.castShadow = data.castShadow;
    if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

    if (data.shadow) {
      if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
      if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
      if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
      if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
    }

    if (data.visible !== undefined) object.visible = data.visible;
    if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
    if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
    if (data.userData !== undefined) object.userData = data.userData;
    if (data.layers !== undefined) object.layers.mask = data.layers;

    if (data.children !== undefined) {
      var children = data.children;

      for (var i = 0; i < children.length; i++) {
        object.add(this.parseObject(children[i], geometries, materials));
      }
    }

    if (data.type === 'LOD') {
      var levels = data.levels;

      for (var l = 0; l < levels.length; l++) {
        var level = levels[l];
        var child = object.getObjectByProperty('uuid', level.object);

        if (child !== undefined) {
          object.addLevel(child, level.distance);
        }
      }
    }

    return object;
  }
});
var TEXTURE_MAPPING = {
  UVMapping: UVMapping,
  CubeReflectionMapping: CubeReflectionMapping,
  CubeRefractionMapping: CubeRefractionMapping,
  EquirectangularReflectionMapping: EquirectangularReflectionMapping,
  EquirectangularRefractionMapping: EquirectangularRefractionMapping,
  SphericalReflectionMapping: SphericalReflectionMapping,
  CubeUVReflectionMapping: CubeUVReflectionMapping,
  CubeUVRefractionMapping: CubeUVRefractionMapping
};
var TEXTURE_WRAPPING = {
  RepeatWrapping: RepeatWrapping,
  ClampToEdgeWrapping: ClampToEdgeWrapping,
  MirroredRepeatWrapping: MirroredRepeatWrapping
};
var TEXTURE_FILTER = {
  NearestFilter: NearestFilter,
  NearestMipmapNearestFilter: NearestMipmapNearestFilter,
  NearestMipmapLinearFilter: NearestMipmapLinearFilter,
  LinearFilter: LinearFilter,
  LinearMipmapNearestFilter: LinearMipmapNearestFilter,
  LinearMipmapLinearFilter: LinearMipmapLinearFilter
};
/**
 * @author thespite / http://clicktorelease.com/
 */

function ImageBitmapLoader(manager) {
  if (typeof createImageBitmap === 'undefined') {
    console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
  }

  if (typeof fetch === 'undefined') {
    console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
  }

  Loader.call(this, manager);
  this.options = undefined;
}

ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ImageBitmapLoader,
  setOptions: function setOptions(options) {
    this.options = options;
    return this;
  },
  load: function (url, onLoad, onProgress, onError) {
    if (url === undefined) url = '';
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    var scope = this;
    var cached = Cache.get(url);

    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }

    fetch(url).then(function (res) {
      return res.blob();
    }).then(function (blob) {
      if (scope.options === undefined) {
        // Workaround for FireFox. It causes an error if you pass options.
        return createImageBitmap(blob);
      } else {
        return createImageBitmap(blob, scope.options);
      }
    }).then(function (imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad) onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function (e) {
      if (onError) onError(e);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
 **/

function ShapePath() {
  this.type = 'ShapePath';
  this.color = new Color();
  this.subPaths = [];
  this.currentPath = null;
}

Object.assign(ShapePath.prototype, {
  moveTo: function (x, y) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x, y);
  },
  lineTo: function (x, y) {
    this.currentPath.lineTo(x, y);
  },
  quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
  },
  bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
  },
  splineThru: function (pts) {
    this.currentPath.splineThru(pts);
  },
  toShapes: function (isCCW, noHoles) {
    function toShapesNoHoles(inSubpaths) {
      var shapes = [];

      for (var i = 0, l = inSubpaths.length; i < l; i++) {
        var tmpPath = inSubpaths[i];
        var tmpShape = new Shape();
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
      }

      return shapes;
    }

    function isPointInsidePolygon(inPt, inPolygon) {
      var polyLen = inPolygon.length; // inPt on polygon contour => immediate success    or
      // toggling of inside/outside at every single! intersection point of an edge
      //  with the horizontal line through inPt, left of inPt
      //  not counting lowerY endpoints of edges and whole edges on that line

      var inside = false;

      for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
        var edgeLowPt = inPolygon[p];
        var edgeHighPt = inPolygon[q];
        var edgeDx = edgeHighPt.x - edgeLowPt.x;
        var edgeDy = edgeHighPt.y - edgeLowPt.y;

        if (Math.abs(edgeDy) > Number.EPSILON) {
          // not parallel
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p];
            edgeDy = -edgeDy;
          }

          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;

          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
            // continue;				// no intersection or edgeLowPt => doesn't count !!!
          } else {
            var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0) return true; // inPt is on contour ?

            if (perpEdge < 0) continue;
            inside = !inside; // true intersection left of inPt
          }
        } else {
          // parallel or collinear
          if (inPt.y !== edgeLowPt.y) continue; // parallel
          // edge lies on the same horizontal line as inPt

          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
          // continue;
        }
      }

      return inside;
    }

    var isClockWise = ShapeUtils.isClockWise;
    var subPaths = this.subPaths;
    if (subPaths.length === 0) return [];
    if (noHoles === true) return toShapesNoHoles(subPaths);
    var solid,
        tmpPath,
        tmpShape,
        shapes = [];

    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }

    var holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst; // console.log("Holes first", holesFirst);

    var betterShapeHoles = [];
    var newShapes = [];
    var newShapeHoles = [];
    var mainIdx = 0;
    var tmpPoints;
    newShapes[mainIdx] = undefined;
    newShapeHoles[mainIdx] = [];

    for (var i = 0, l = subPaths.length; i < l; i++) {
      tmpPath = subPaths[i];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;

      if (solid) {
        if (!holesFirst && newShapes[mainIdx]) mainIdx++;
        newShapes[mainIdx] = {
          s: new Shape(),
          p: tmpPoints
        };
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst) mainIdx++;
        newShapeHoles[mainIdx] = []; //console.log('cw', i);
      } else {
        newShapeHoles[mainIdx].push({
          h: tmpPath,
          p: tmpPoints[0]
        }); //console.log('ccw', i);
      }
    } // only Holes? -> probably all Shapes with wrong orientation


    if (!newShapes[0]) return toShapesNoHoles(subPaths);

    if (newShapes.length > 1) {
      var ambiguous = false;
      var toChange = [];

      for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }

      for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        var sho = newShapeHoles[sIdx];

        for (var hIdx = 0; hIdx < sho.length; hIdx++) {
          var ho = sho[hIdx];
          var hole_unassigned = true;

          for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx) toChange.push({
                froms: sIdx,
                tos: s2Idx,
                hole: hIdx
              });

              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }

          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      } // console.log("ambiguous: ", ambiguous);


      if (toChange.length > 0) {
        // console.log("to change: ", toChange);
        if (!ambiguous) newShapeHoles = betterShapeHoles;
      }
    }

    var tmpHoles;

    for (var i = 0, il = newShapes.length; i < il; i++) {
      tmpShape = newShapes[i].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i];

      for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h);
      }
    } //console.log("shape", shapes);


    return shapes;
  }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author mrdoob / http://mrdoob.com/
 */

function Font(data) {
  this.type = 'Font';
  this.data = data;
}

Object.assign(Font.prototype, {
  isFont: true,
  generateShapes: function (text, size) {
    if (size === undefined) size = 100;
    var shapes = [];
    var paths = createPaths(text, size, this.data);

    for (var p = 0, pl = paths.length; p < pl; p++) {
      Array.prototype.push.apply(shapes, paths[p].toShapes());
    }

    return shapes;
  }
});

function createPaths(text, size, data) {
  var chars = Array.from ? Array.from(text) : String(text).split(''); // see #13988

  var scale = size / data.resolution;
  var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  var paths = [];
  var offsetX = 0,
      offsetY = 0;

  for (var i = 0; i < chars.length; i++) {
    var char = chars[i];

    if (char === '\n') {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      var ret = createPath(char, scale, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }

  return paths;
}

function createPath(char, scale, offsetX, offsetY, data) {
  var glyph = data.glyphs[char] || data.glyphs['?'];

  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
    return;
  }

  var path = new ShapePath();
  var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

  if (glyph.o) {
    var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

    for (var i = 0, l = outline.length; i < l;) {
      var action = outline[i++];

      switch (action) {
        case 'm':
          // moveTo
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.moveTo(x, y);
          break;

        case 'l':
          // lineTo
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.lineTo(x, y);
          break;

        case 'q':
          // quadraticCurveTo
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;

        case 'b':
          // bezierCurveTo
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          cpx2 = outline[i++] * scale + offsetX;
          cpy2 = outline[i++] * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }

  return {
    offsetX: glyph.ha * scale,
    path: path
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function FontLoader(manager) {
  Loader.call(this, manager);
}

FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: FontLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.load(url, function (text) {
      var json;

      try {
        json = JSON.parse(text);
      } catch (e) {
        console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
        json = JSON.parse(text.substring(65, text.length - 2));
      }

      var font = scope.parse(json);
      if (onLoad) onLoad(font);
    }, onProgress, onError);
  },
  parse: function (json) {
    return new Font(json);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

var _context;

var AudioContext = {
  getContext: function () {
    if (_context === undefined) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }

    return _context;
  },
  setContext: function (value) {
    _context = value;
  }
};
/**
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

exports.AudioContext = AudioContext;

function AudioLoader(manager) {
  Loader.call(this, manager);
}

AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: AudioLoader,
  load: function (url, onLoad, onProgress, onError) {
    var loader = new FileLoader(this.manager);
    loader.setResponseType('arraybuffer');
    loader.setPath(this.path);
    loader.load(url, function (buffer) {
      // Create a copy of the buffer. The `decodeAudioData` method
      // detaches the buffer when complete, preventing reuse.
      var bufferCopy = buffer.slice(0);
      var context = AudioContext.getContext();
      context.decodeAudioData(bufferCopy, function (audioBuffer) {
        onLoad(audioBuffer);
      });
    }, onProgress, onError);
  }
});
/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */
// 3-band SH defined by 9 coefficients

function SphericalHarmonics3() {
  this.coefficients = [];

  for (var i = 0; i < 9; i++) {
    this.coefficients.push(new Vector3());
  }
}

Object.assign(SphericalHarmonics3.prototype, {
  isSphericalHarmonics3: true,
  set: function (coefficients) {
    for (var i = 0; i < 9; i++) {
      this.coefficients[i].copy(coefficients[i]);
    }

    return this;
  },
  zero: function () {
    for (var i = 0; i < 9; i++) {
      this.coefficients[i].set(0, 0, 0);
    }

    return this;
  },
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt: function (normal, target) {
    // normal is assumed to be unit length
    var x = normal.x,
        y = normal.y,
        z = normal.z;
    var coeff = this.coefficients; // band 0

    target.copy(coeff[0]).multiplyScalar(0.282095); // band 1

    target.addScale(coeff[1], 0.488603 * y);
    target.addScale(coeff[2], 0.488603 * z);
    target.addScale(coeff[3], 0.488603 * x); // band 2

    target.addScale(coeff[4], 1.092548 * (x * y));
    target.addScale(coeff[5], 1.092548 * (y * z));
    target.addScale(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
    target.addScale(coeff[7], 1.092548 * (x * z));
    target.addScale(coeff[8], 0.546274 * (x * x - y * y));
    return target;
  },
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt: function (normal, target) {
    // normal is assumed to be unit length
    var x = normal.x,
        y = normal.y,
        z = normal.z;
    var coeff = this.coefficients; // band 0

    target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095
    // band 1

    target.addScale(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603

    target.addScale(coeff[2], 2.0 * 0.511664 * z);
    target.addScale(coeff[3], 2.0 * 0.511664 * x); // band 2

    target.addScale(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548

    target.addScale(coeff[5], 2.0 * 0.429043 * y * z);
    target.addScale(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3

    target.addScale(coeff[7], 2.0 * 0.429043 * x * z);
    target.addScale(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274

    return target;
  },
  add: function (sh) {
    for (var i = 0; i < 9; i++) {
      this.coefficients[i].add(sh.coefficients[i]);
    }

    return this;
  },
  scale: function (s) {
    for (var i = 0; i < 9; i++) {
      this.coefficients[i].multiplyScalar(s);
    }

    return this;
  },
  lerp: function (sh, alpha) {
    for (var i = 0; i < 9; i++) {
      this.coefficients[i].lerp(sh.coefficients[i], alpha);
    }

    return this;
  },
  equals: function (sh) {
    for (var i = 0; i < 9; i++) {
      if (!this.coefficients[i].equals(sh.coefficients[i])) {
        return false;
      }
    }

    return true;
  },
  copy: function (sh) {
    return this.set(sh.coefficients);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    var coefficients = this.coefficients;

    for (var i = 0; i < 9; i++) {
      coefficients[i].fromArray(array, offset + i * 3);
    }

    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    var coefficients = this.coefficients;

    for (var i = 0; i < 9; i++) {
      coefficients[i].toArray(array, offset + i * 3);
    }

    return array;
  }
});
Object.assign(SphericalHarmonics3, {
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  getBasisAt: function (normal, shBasis) {
    // normal is assumed to be unit length
    var x = normal.x,
        y = normal.y,
        z = normal.z; // band 0

    shBasis[0] = 0.282095; // band 1

    shBasis[1] = 0.488603 * y;
    shBasis[2] = 0.488603 * z;
    shBasis[3] = 0.488603 * x; // band 2

    shBasis[4] = 1.092548 * x * y;
    shBasis[5] = 1.092548 * y * z;
    shBasis[6] = 0.315392 * (3 * z * z - 1);
    shBasis[7] = 1.092548 * x * z;
    shBasis[8] = 0.546274 * (x * x - y * y);
  }
});
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * A LightProbe is a source of indirect-diffuse light
 */

function LightProbe(sh, intensity) {
  Light.call(this, undefined, intensity);
  this.sh = sh !== undefined ? sh : new SphericalHarmonics3();
}

LightProbe.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: LightProbe,
  isLightProbe: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.sh.copy(source.sh);
    this.intensity = source.intensity;
    return this;
  },
  toJSON: function (meta) {
    var data = Light.prototype.toJSON.call(this, meta); // data.sh = this.sh.toArray(); // todo

    return data;
  }
});
/**
 * @author WestLangley / http://github.com/WestLangley
 */

function HemisphereLightProbe(skyColor, groundColor, intensity) {
  LightProbe.call(this, undefined, intensity);
  var color1 = new Color().set(skyColor);
  var color2 = new Color().set(groundColor);
  var sky = new Vector3(color1.r, color1.g, color1.b);
  var ground = new Vector3(color2.r, color2.g, color2.b); // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );

  var c0 = Math.sqrt(Math.PI);
  var c1 = c0 * Math.sqrt(0.75);
  this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
  this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
}

HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
  constructor: HemisphereLightProbe,
  isHemisphereLightProbe: true,
  copy: function (source) {
    // modifying colors not currently supported
    LightProbe.prototype.copy.call(this, source);
    return this;
  },
  toJSON: function (meta) {
    var data = LightProbe.prototype.toJSON.call(this, meta); // data.sh = this.sh.toArray(); // todo

    return data;
  }
});
/**
 * @author WestLangley / http://github.com/WestLangley
 */

function AmbientLightProbe(color, intensity) {
  LightProbe.call(this, undefined, intensity);
  var color1 = new Color().set(color); // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );

  this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
}

AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
  constructor: AmbientLightProbe,
  isAmbientLightProbe: true,
  copy: function (source) {
    // modifying color not currently supported
    LightProbe.prototype.copy.call(this, source);
    return this;
  },
  toJSON: function (meta) {
    var data = LightProbe.prototype.toJSON.call(this, meta); // data.sh = this.sh.toArray(); // todo

    return data;
  }
});

var _eyeRight = new Matrix4();

var _eyeLeft = new Matrix4();
/**
 * @author mrdoob / http://mrdoob.com/
 */


function StereoCamera() {
  this.type = 'StereoCamera';
  this.aspect = 1;
  this.eyeSep = 0.064;
  this.cameraL = new PerspectiveCamera();
  this.cameraL.layers.enable(1);
  this.cameraL.matrixAutoUpdate = false;
  this.cameraR = new PerspectiveCamera();
  this.cameraR.layers.enable(2);
  this.cameraR.matrixAutoUpdate = false;
  this._cache = {
    focus: null,
    fov: null,
    aspect: null,
    near: null,
    far: null,
    zoom: null,
    eyeSep: null
  };
}

Object.assign(StereoCamera.prototype, {
  update: function (camera) {
    var cache = this._cache;
    var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

    if (needsUpdate) {
      cache.focus = camera.focus;
      cache.fov = camera.fov;
      cache.aspect = camera.aspect * this.aspect;
      cache.near = camera.near;
      cache.far = camera.far;
      cache.zoom = camera.zoom;
      cache.eyeSep = this.eyeSep; // Off-axis stereoscopic effect based on
      // http://paulbourke.net/stereographics/stereorender/

      var projectionMatrix = camera.projectionMatrix.clone();
      var eyeSepHalf = cache.eyeSep / 2;
      var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
      var ymax = cache.near * Math.tan(_Math.DEG2RAD * cache.fov * 0.5) / cache.zoom;
      var xmin, xmax; // translate xOffset

      _eyeLeft.elements[12] = -eyeSepHalf;
      _eyeRight.elements[12] = eyeSepHalf; // for left eye

      xmin = -ymax * cache.aspect + eyeSepOnProjection;
      xmax = ymax * cache.aspect + eyeSepOnProjection;
      projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraL.projectionMatrix.copy(projectionMatrix); // for right eye

      xmin = -ymax * cache.aspect - eyeSepOnProjection;
      xmax = ymax * cache.aspect - eyeSepOnProjection;
      projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraR.projectionMatrix.copy(projectionMatrix);
    }

    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */

function Clock(autoStart) {
  this.autoStart = autoStart !== undefined ? autoStart : true;
  this.startTime = 0;
  this.oldTime = 0;
  this.elapsedTime = 0;
  this.running = false;
}

Object.assign(Clock.prototype, {
  start: function () {
    this.startTime = (typeof performance === 'undefined' ? Date : performance).now(); // see #10732

    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  },
  stop: function () {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  },
  getElapsedTime: function () {
    this.getDelta();
    return this.elapsedTime;
  },
  getDelta: function () {
    var diff = 0;

    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }

    if (this.running) {
      var newTime = (typeof performance === 'undefined' ? Date : performance).now();
      diff = (newTime - this.oldTime) / 1000;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }

    return diff;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

var _position$2 = new Vector3();

var _quaternion$3 = new Quaternion();

var _scale$1 = new Vector3();

var _orientation = new Vector3();

function AudioListener() {
  Object3D.call(this);
  this.type = 'AudioListener';
  this.context = AudioContext.getContext();
  this.gain = this.context.createGain();
  this.gain.connect(this.context.destination);
  this.filter = null;
  this.timeDelta = 0; // private

  this._clock = new Clock();
}

AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: AudioListener,
  getInput: function () {
    return this.gain;
  },
  removeFilter: function () {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
      this.gain.connect(this.context.destination);
      this.filter = null;
    }

    return this;
  },
  getFilter: function () {
    return this.filter;
  },
  setFilter: function (value) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
    } else {
      this.gain.disconnect(this.context.destination);
    }

    this.filter = value;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  },
  getMasterVolume: function () {
    return this.gain.gain.value;
  },
  setMasterVolume: function (value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  },
  updateMatrixWorld: function (force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    var listener = this.context.listener;
    var up = this.up;
    this.timeDelta = this._clock.getDelta();
    this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1);

    _orientation.set(0, 0, -1).applyQuaternion(_quaternion$3);

    if (listener.positionX) {
      // code path for Chrome (see #14393)
      var endTime = this.context.currentTime + this.timeDelta;
      listener.positionX.linearRampToValueAtTime(_position$2.x, endTime);
      listener.positionY.linearRampToValueAtTime(_position$2.y, endTime);
      listener.positionZ.linearRampToValueAtTime(_position$2.z, endTime);
      listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
      listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
      listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
      listener.upX.linearRampToValueAtTime(up.x, endTime);
      listener.upY.linearRampToValueAtTime(up.y, endTime);
      listener.upZ.linearRampToValueAtTime(up.z, endTime);
    } else {
      listener.setPosition(_position$2.x, _position$2.y, _position$2.z);
      listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
    }
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

function Audio(listener) {
  Object3D.call(this);
  this.type = 'Audio';
  this.listener = listener;
  this.context = listener.context;
  this.gain = this.context.createGain();
  this.gain.connect(listener.getInput());
  this.autoplay = false;
  this.buffer = null;
  this.detune = 0;
  this.loop = false;
  this.startTime = 0;
  this.offset = 0;
  this.duration = undefined;
  this.playbackRate = 1;
  this.isPlaying = false;
  this.hasPlaybackControl = true;
  this.sourceType = 'empty';
  this.filters = [];
}

Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Audio,
  getOutput: function () {
    return this.gain;
  },
  setNodeSource: function (audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = 'audioNode';
    this.source = audioNode;
    this.connect();
    return this;
  },
  setMediaElementSource: function (mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = 'mediaNode';
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  },
  setBuffer: function (audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = 'buffer';
    if (this.autoplay) this.play();
    return this;
  },
  play: function () {
    if (this.isPlaying === true) {
      console.warn('THREE.Audio: Audio is already playing.');
      return;
    }

    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    var source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.onended = this.onEnded.bind(this);
    this.startTime = this.context.currentTime;
    source.start(this.startTime, this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  },
  pause: function () {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    if (this.isPlaying === true) {
      this.source.stop();
      this.source.onended = null;
      this.offset += (this.context.currentTime - this.startTime) * this.playbackRate;
      this.isPlaying = false;
    }

    return this;
  },
  stop: function () {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this.source.stop();
    this.source.onended = null;
    this.offset = 0;
    this.isPlaying = false;
    return this;
  },
  connect: function () {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);

      for (var i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].connect(this.filters[i]);
      }

      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }

    return this;
  },
  disconnect: function () {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);

      for (var i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].disconnect(this.filters[i]);
      }

      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }

    return this;
  },
  getFilters: function () {
    return this.filters;
  },
  setFilters: function (value) {
    if (!value) value = [];

    if (this.isPlaying === true) {
      this.disconnect();
      this.filters = value;
      this.connect();
    } else {
      this.filters = value;
    }

    return this;
  },
  setDetune: function (value) {
    this.detune = value;
    if (this.source.detune === undefined) return; // only set detune when available

    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }

    return this;
  },
  getDetune: function () {
    return this.detune;
  },
  getFilter: function () {
    return this.getFilters()[0];
  },
  setFilter: function (filter) {
    return this.setFilters(filter ? [filter] : []);
  },
  setPlaybackRate: function (value) {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this.playbackRate = value;

    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }

    return this;
  },
  getPlaybackRate: function () {
    return this.playbackRate;
  },
  onEnded: function () {
    this.isPlaying = false;
  },
  getLoop: function () {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return false;
    }

    return this.loop;
  },
  setLoop: function (value) {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this.loop = value;

    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }

    return this;
  },
  getVolume: function () {
    return this.gain.gain.value;
  },
  setVolume: function (value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

var _position$3 = new Vector3();

var _quaternion$4 = new Quaternion();

var _scale$2 = new Vector3();

var _orientation$1 = new Vector3();

function PositionalAudio(listener) {
  Audio.call(this, listener);
  this.panner = this.context.createPanner();
  this.panner.panningModel = 'HRTF';
  this.panner.connect(this.gain);
}

PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
  constructor: PositionalAudio,
  getOutput: function () {
    return this.panner;
  },
  getRefDistance: function () {
    return this.panner.refDistance;
  },
  setRefDistance: function (value) {
    this.panner.refDistance = value;
    return this;
  },
  getRolloffFactor: function () {
    return this.panner.rolloffFactor;
  },
  setRolloffFactor: function (value) {
    this.panner.rolloffFactor = value;
    return this;
  },
  getDistanceModel: function () {
    return this.panner.distanceModel;
  },
  setDistanceModel: function (value) {
    this.panner.distanceModel = value;
    return this;
  },
  getMaxDistance: function () {
    return this.panner.maxDistance;
  },
  setMaxDistance: function (value) {
    this.panner.maxDistance = value;
    return this;
  },
  setDirectionalCone: function (coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.panner.coneInnerAngle = coneInnerAngle;
    this.panner.coneOuterAngle = coneOuterAngle;
    this.panner.coneOuterGain = coneOuterGain;
    return this;
  },
  updateMatrixWorld: function (force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    if (this.hasPlaybackControl === true && this.isPlaying === false) return;
    this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2);

    _orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);

    var panner = this.panner;

    if (panner.positionX) {
      // code path for Chrome and Firefox (see #14393)
      var endTime = this.context.currentTime + this.listener.timeDelta;
      panner.positionX.linearRampToValueAtTime(_position$3.x, endTime);
      panner.positionY.linearRampToValueAtTime(_position$3.y, endTime);
      panner.positionZ.linearRampToValueAtTime(_position$3.z, endTime);
      panner.orientationX.linearRampToValueAtTime(_orientation$1.x, endTime);
      panner.orientationY.linearRampToValueAtTime(_orientation$1.y, endTime);
      panner.orientationZ.linearRampToValueAtTime(_orientation$1.z, endTime);
    } else {
      panner.setPosition(_position$3.x, _position$3.y, _position$3.z);
      panner.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);
    }
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function AudioAnalyser(audio, fftSize) {
  this.analyser = audio.context.createAnalyser();
  this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
  this.data = new Uint8Array(this.analyser.frequencyBinCount);
  audio.getOutput().connect(this.analyser);
}

Object.assign(AudioAnalyser.prototype, {
  getFrequencyData: function () {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  },
  getAverageFrequency: function () {
    var value = 0,
        data = this.getFrequencyData();

    for (var i = 0; i < data.length; i++) {
      value += data[i];
    }

    return value / data.length;
  }
});
/**
 *
 * Buffered scene graph property that allows weighted accumulation.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function PropertyMixer(binding, typeName, valueSize) {
  this.binding = binding;
  this.valueSize = valueSize;
  var bufferType = Float64Array,
      mixFunction;

  switch (typeName) {
    case 'quaternion':
      mixFunction = this._slerp;
      break;

    case 'string':
    case 'bool':
      bufferType = Array;
      mixFunction = this._select;
      break;

    default:
      mixFunction = this._lerp;
  }

  this.buffer = new bufferType(valueSize * 4); // layout: [ incoming | accu0 | accu1 | orig ]
  //
  // interpolators can use .buffer as their .result
  // the data then goes to 'incoming'
  //
  // 'accu0' and 'accu1' are used frame-interleaved for
  // the cumulative result and are compared to detect
  // changes
  //
  // 'orig' stores the original state of the property

  this._mixBufferRegion = mixFunction;
  this.cumulativeWeight = 0;
  this.useCount = 0;
  this.referenceCount = 0;
}

Object.assign(PropertyMixer.prototype, {
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate: function (accuIndex, weight) {
    // note: happily accumulating nothing when weight = 0, the caller knows
    // the weight and shouldn't have made the call in the first place
    var buffer = this.buffer,
        stride = this.valueSize,
        offset = accuIndex * stride + stride,
        currentWeight = this.cumulativeWeight;

    if (currentWeight === 0) {
      // accuN := incoming * weight
      for (var i = 0; i !== stride; ++i) {
        buffer[offset + i] = buffer[i];
      }

      currentWeight = weight;
    } else {
      // accuN := accuN + incoming * weight
      currentWeight += weight;
      var mix = weight / currentWeight;

      this._mixBufferRegion(buffer, offset, 0, mix, stride);
    }

    this.cumulativeWeight = currentWeight;
  },
  // apply the state of 'accu<i>' to the binding when accus differ
  apply: function (accuIndex) {
    var stride = this.valueSize,
        buffer = this.buffer,
        offset = accuIndex * stride + stride,
        weight = this.cumulativeWeight,
        binding = this.binding;
    this.cumulativeWeight = 0;

    if (weight < 1) {
      // accuN := accuN + original * ( 1 - cumulativeWeight )
      var originalValueOffset = stride * 3;

      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
    }

    for (var i = stride, e = stride + stride; i !== e; ++i) {
      if (buffer[i] !== buffer[i + stride]) {
        // value has changed -> update scene graph
        binding.setValue(buffer, offset);
        break;
      }
    }
  },
  // remember the state of the bound property and copy it to both accus
  saveOriginalState: function () {
    var binding = this.binding;
    var buffer = this.buffer,
        stride = this.valueSize,
        originalValueOffset = stride * 3;
    binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original

    for (var i = stride, e = originalValueOffset; i !== e; ++i) {
      buffer[i] = buffer[originalValueOffset + i % stride];
    }

    this.cumulativeWeight = 0;
  },
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState: function () {
    var originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  },
  // mix functions
  _select: function (buffer, dstOffset, srcOffset, t, stride) {
    if (t >= 0.5) {
      for (var i = 0; i !== stride; ++i) {
        buffer[dstOffset + i] = buffer[srcOffset + i];
      }
    }
  },
  _slerp: function (buffer, dstOffset, srcOffset, t) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
  },
  _lerp: function (buffer, dstOffset, srcOffset, t, stride) {
    var s = 1 - t;

    for (var i = 0; i !== stride; ++i) {
      var j = dstOffset + i;
      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
    }
  }
});
/**
 *
 * A reference to a real property in the scene graph.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */
// Characters [].:/ are reserved for track binding syntax.

var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

var _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.


var _wordChar = '[^' + _RESERVED_CHARS_RE + ']';

var _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.


var _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.


var _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.


var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.


var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);

var _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');

var _supportedObjectNames = ['material', 'materials', 'bones'];

function Composite(targetGroup, path, optionalParsedPath) {
  var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
  this._targetGroup = targetGroup;
  this._bindings = targetGroup.subscribe_(path, parsedPath);
}

Object.assign(Composite.prototype, {
  getValue: function (array, offset) {
    this.bind(); // bind all binding

    var firstValidIndex = this._targetGroup.nCachedObjects_,
        binding = this._bindings[firstValidIndex]; // and only call .getValue on the first

    if (binding !== undefined) binding.getValue(array, offset);
  },
  setValue: function (array, offset) {
    var bindings = this._bindings;

    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].setValue(array, offset);
    }
  },
  bind: function () {
    var bindings = this._bindings;

    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].bind();
    }
  },
  unbind: function () {
    var bindings = this._bindings;

    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].unbind();
    }
  }
});

function PropertyBinding(rootNode, path, parsedPath) {
  this.path = path;
  this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
  this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
  this.rootNode = rootNode;
}

Object.assign(PropertyBinding, {
  Composite: Composite,
  create: function (root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  },

  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  sanitizeNodeName: function (name) {
    return name.replace(/\s/g, '_').replace(_reservedRe, '');
  },
  parseTrackName: function (trackName) {
    var matches = _trackRe.exec(trackName);

    if (!matches) {
      throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
    }

    var results = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      // required
      propertyIndex: matches[6]
    };
    var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

    if (lastDot !== undefined && lastDot !== -1) {
      var objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against a whitelist. Otherwise, there
      // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
      // 'bar' could be the objectName, or part of a nodeName (which can
      // include '.' characters).

      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }

    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
    }

    return results;
  },
  findNode: function (root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    } // search into skeleton bones.


    if (root.skeleton) {
      var bone = root.skeleton.getBoneByName(nodeName);

      if (bone !== undefined) {
        return bone;
      }
    } // search into node subtree.


    if (root.children) {
      var searchNodeSubtree = function (children) {
        for (var i = 0; i < children.length; i++) {
          var childNode = children[i];

          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }

          var result = searchNodeSubtree(childNode.children);
          if (result) return result;
        }

        return null;
      };

      var subTreeNode = searchNodeSubtree(root.children);

      if (subTreeNode) {
        return subTreeNode;
      }
    }

    return null;
  }
});
Object.assign(PropertyBinding.prototype, {
  // prototype, continued
  // these are used to "bind" a nonexistent property
  _getValue_unavailable: function () {},
  _setValue_unavailable: function () {},
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [function getValue_direct(buffer, offset) {
    buffer[offset] = this.node[this.propertyName];
  }, function getValue_array(buffer, offset) {
    var source = this.resolvedProperty;

    for (var i = 0, n = source.length; i !== n; ++i) {
      buffer[offset++] = source[i];
    }
  }, function getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex];
  }, function getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset);
  }],
  SetterByBindingTypeAndVersioning: [[// Direct
  function setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
  }, function setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }, function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [// EntireArray
  function setValue_array(buffer, offset) {
    var dest = this.resolvedProperty;

    for (var i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
  }, function setValue_array_setNeedsUpdate(buffer, offset) {
    var dest = this.resolvedProperty;

    for (var i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }

    this.targetObject.needsUpdate = true;
  }, function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    var dest = this.resolvedProperty;

    for (var i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }

    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [// ArrayElement
  function setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
  }, function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }, function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [// HasToFromArray
  function setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
  }, function setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.needsUpdate = true;
  }, function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }]],
  getValue: function getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset); // Note: This class uses a State pattern on a per-method basis:
    // 'bind' sets 'this.getValue' / 'setValue' and shadows the
    // prototype version of these methods with one that represents
    // the bound state. When the property is not found, the methods
    // become no-ops.
  },
  setValue: function getValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  },
  // create getter / setter pair for a property in the scene graph
  bind: function () {
    var targetObject = this.node,
        parsedPath = this.parsedPath,
        objectName = parsedPath.objectName,
        propertyName = parsedPath.propertyName,
        propertyIndex = parsedPath.propertyIndex;

    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    } // set fail state so we can just 'return' on error


    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable; // ensure there is a value node

    if (!targetObject) {
      console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
      return;
    }

    if (objectName) {
      var objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....

      switch (objectName) {
        case 'materials':
          if (!targetObject.material) {
            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
            return;
          }

          if (!targetObject.material.materials) {
            console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
            return;
          }

          targetObject = targetObject.material.materials;
          break;

        case 'bones':
          if (!targetObject.skeleton) {
            console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
            return;
          } // potential future optimization: skip this if propertyIndex is already an integer
          // and convert the integer string to a true integer.


          targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.

          for (var i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i;
              break;
            }
          }

          break;

        default:
          if (targetObject[objectName] === undefined) {
            console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
            return;
          }

          targetObject = targetObject[objectName];
      }

      if (objectIndex !== undefined) {
        if (targetObject[objectIndex] === undefined) {
          console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
          return;
        }

        targetObject = targetObject[objectIndex];
      }
    } // resolve property


    var nodeProperty = targetObject[propertyName];

    if (nodeProperty === undefined) {
      var nodeName = parsedPath.nodeName;
      console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
      return;
    } // determine versioning scheme


    var versioning = this.Versioning.None;
    this.targetObject = targetObject;

    if (targetObject.needsUpdate !== undefined) {
      // material
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
      // node transform
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    } // determine how the property gets bound


    var bindingType = this.BindingType.Direct;

    if (propertyIndex !== undefined) {
      // access a sub element of the property array (only primitives are supported right now)
      if (propertyName === "morphTargetInfluences") {
        // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
        // support resolving morphTarget names into indices.
        if (!targetObject.geometry) {
          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
          return;
        }

        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
            return;
          }

          for (var i = 0; i < this.node.geometry.morphAttributes.position.length; i++) {
            if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {
              propertyIndex = i;
              break;
            }
          }
        } else {
          if (!targetObject.geometry.morphTargets) {
            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this);
            return;
          }

          for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
            if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
              propertyIndex = i;
              break;
            }
          }
        }
      }

      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
      // must use copy for Object3D.Euler/Quaternion
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    } // select getter / setter


    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  },
  unbind: function () {
    this.node = null; // back to the prototype version of getValue / setValue
    // note: avoiding to mutate the shape of 'this' via 'delete'

    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
}); //!\ DECLARE ALIAS AFTER assign prototype !

Object.assign(PropertyBinding.prototype, {
  // initial state of these methods that calls 'bind'
  _getValue_unbound: PropertyBinding.prototype.getValue,
  _setValue_unbound: PropertyBinding.prototype.setValue
});
/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 *
 * @author tschw
 */

function AnimationObjectGroup() {
  this.uuid = _Math.generateUUID(); // cached objects followed by the active ones

  this._objects = Array.prototype.slice.call(arguments);
  this.nCachedObjects_ = 0; // threshold
  // note: read by PropertyBinding.Composite

  var indices = {};
  this._indicesByUUID = indices; // for bookkeeping

  for (var i = 0, n = arguments.length; i !== n; ++i) {
    indices[arguments[i].uuid] = i;
  }

  this._paths = []; // inside: string

  this._parsedPaths = []; // inside: { we don't care, here }

  this._bindings = []; // inside: Array< PropertyBinding >

  this._bindingsIndicesByPath = {}; // inside: indices in these arrays

  var scope = this;
  this.stats = {
    objects: {
      get total() {
        return scope._objects.length;
      },

      get inUse() {
        return this.total - scope.nCachedObjects_;
      }

    },

    get bindingsPerObject() {
      return scope._bindings.length;
    }

  };
}

Object.assign(AnimationObjectGroup.prototype, {
  isAnimationObjectGroup: true,
  add: function () {
    var objects = this._objects,
        nObjects = objects.length,
        nCachedObjects = this.nCachedObjects_,
        indicesByUUID = this._indicesByUUID,
        paths = this._paths,
        parsedPaths = this._parsedPaths,
        bindings = this._bindings,
        nBindings = bindings.length,
        knownObject = undefined;

    for (var i = 0, n = arguments.length; i !== n; ++i) {
      var object = arguments[i],
          uuid = object.uuid,
          index = indicesByUUID[uuid];

      if (index === undefined) {
        // unknown object -> add it to the ACTIVE region
        index = nObjects++;
        indicesByUUID[uuid] = index;
        objects.push(object); // accounting is done, now do the same for all bindings

        for (var j = 0, m = nBindings; j !== m; ++j) {
          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
        }
      } else if (index < nCachedObjects) {
        knownObject = objects[index]; // move existing object to the ACTIVE region

        var firstActiveIndex = --nCachedObjects,
            lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index;
        objects[index] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings

        for (var j = 0, m = nBindings; j !== m; ++j) {
          var bindingsForPath = bindings[j],
              lastCached = bindingsForPath[firstActiveIndex],
              binding = bindingsForPath[index];
          bindingsForPath[index] = lastCached;

          if (binding === undefined) {
            // since we do not bother to create new bindings
            // for objects that are cached, the binding may
            // or may not exist
            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
          }

          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index] !== knownObject) {
        console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
      } // else the object is already where we want it to be

    } // for arguments


    this.nCachedObjects_ = nCachedObjects;
  },
  remove: function () {
    var objects = this._objects,
        nCachedObjects = this.nCachedObjects_,
        indicesByUUID = this._indicesByUUID,
        bindings = this._bindings,
        nBindings = bindings.length;

    for (var i = 0, n = arguments.length; i !== n; ++i) {
      var object = arguments[i],
          uuid = object.uuid,
          index = indicesByUUID[uuid];

      if (index !== undefined && index >= nCachedObjects) {
        // move existing object into the CACHED region
        var lastCachedIndex = nCachedObjects++,
            firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index;
        objects[index] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings

        for (var j = 0, m = nBindings; j !== m; ++j) {
          var bindingsForPath = bindings[j],
              firstActive = bindingsForPath[lastCachedIndex],
              binding = bindingsForPath[index];
          bindingsForPath[index] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    } // for arguments


    this.nCachedObjects_ = nCachedObjects;
  },
  // remove & forget
  uncache: function () {
    var objects = this._objects,
        nObjects = objects.length,
        nCachedObjects = this.nCachedObjects_,
        indicesByUUID = this._indicesByUUID,
        bindings = this._bindings,
        nBindings = bindings.length;

    for (var i = 0, n = arguments.length; i !== n; ++i) {
      var object = arguments[i],
          uuid = object.uuid,
          index = indicesByUUID[uuid];

      if (index !== undefined) {
        delete indicesByUUID[uuid];

        if (index < nCachedObjects) {
          // object is cached, shrink the CACHED region
          var firstActiveIndex = --nCachedObjects,
              lastCachedObject = objects[firstActiveIndex],
              lastIndex = --nObjects,
              lastObject = objects[lastIndex]; // last cached object takes this object's place

          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject; // last object goes to the activated slot and pop

          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop(); // accounting is done, now do the same for all bindings

          for (var j = 0, m = nBindings; j !== m; ++j) {
            var bindingsForPath = bindings[j],
                lastCached = bindingsForPath[firstActiveIndex],
                last = bindingsForPath[lastIndex];
            bindingsForPath[index] = lastCached;
            bindingsForPath[firstActiveIndex] = last;
            bindingsForPath.pop();
          }
        } else {
          // object is active, just swap with the last and pop
          var lastIndex = --nObjects,
              lastObject = objects[lastIndex];
          indicesByUUID[lastObject.uuid] = index;
          objects[index] = lastObject;
          objects.pop(); // accounting is done, now do the same for all bindings

          for (var j = 0, m = nBindings; j !== m; ++j) {
            var bindingsForPath = bindings[j];
            bindingsForPath[index] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        } // cached or active

      } // if object is known

    } // for arguments


    this.nCachedObjects_ = nCachedObjects;
  },
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_: function (path, parsedPath) {
    // returns an array of bindings for the given path that is changed
    // according to the contained objects in the group
    var indicesByPath = this._bindingsIndicesByPath,
        index = indicesByPath[path],
        bindings = this._bindings;
    if (index !== undefined) return bindings[index];
    var paths = this._paths,
        parsedPaths = this._parsedPaths,
        objects = this._objects,
        nObjects = objects.length,
        nCachedObjects = this.nCachedObjects_,
        bindingsForPath = new Array(nObjects);
    index = bindings.length;
    indicesByPath[path] = index;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);

    for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
      var object = objects[i];
      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
    }

    return bindingsForPath;
  },
  unsubscribe_: function (path) {
    // tells the group to forget about a property path and no longer
    // update the array previously obtained with 'subscribe_'
    var indicesByPath = this._bindingsIndicesByPath,
        index = indicesByPath[path];

    if (index !== undefined) {
      var paths = this._paths,
          parsedPaths = this._parsedPaths,
          bindings = this._bindings,
          lastBindingsIndex = bindings.length - 1,
          lastBindings = bindings[lastBindingsIndex],
          lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index;
      bindings[index] = lastBindings;
      bindings.pop();
      parsedPaths[index] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
});
/**
 *
 * Action provided by AnimationMixer for scheduling clip playback on specific
 * objects.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 *
 */

function AnimationAction(mixer, clip, localRoot) {
  this._mixer = mixer;
  this._clip = clip;
  this._localRoot = localRoot || null;
  var tracks = clip.tracks,
      nTracks = tracks.length,
      interpolants = new Array(nTracks);
  var interpolantSettings = {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  };

  for (var i = 0; i !== nTracks; ++i) {
    var interpolant = tracks[i].createInterpolant(null);
    interpolants[i] = interpolant;
    interpolant.settings = interpolantSettings;
  }

  this._interpolantSettings = interpolantSettings;
  this._interpolants = interpolants; // bound by the mixer
  // inside: PropertyMixer (managed by the mixer)

  this._propertyBindings = new Array(nTracks);
  this._cacheIndex = null; // for the memory manager

  this._byClipCacheIndex = null; // for the memory manager

  this._timeScaleInterpolant = null;
  this._weightInterpolant = null;
  this.loop = LoopRepeat;
  this._loopCount = -1; // global mixer time when the action is to be started
  // it's set back to 'null' upon start of the action

  this._startTime = null; // scaled local time of the action
  // gets clamped or wrapped to 0..clip.duration according to loop

  this.time = 0;
  this.timeScale = 1;
  this._effectiveTimeScale = 1;
  this.weight = 1;
  this._effectiveWeight = 1;
  this.repetitions = Infinity; // no. of repetitions when looping

  this.paused = false; // true -> zero effective time scale

  this.enabled = true; // false -> zero effective weight

  this.clampWhenFinished = false; // keep feeding the last frame?

  this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate

  this.zeroSlopeAtEnd = true; // clips for start, loop and end
}

Object.assign(AnimationAction.prototype, {
  // State & Scheduling
  play: function () {
    this._mixer._activateAction(this);

    return this;
  },
  stop: function () {
    this._mixer._deactivateAction(this);

    return this.reset();
  },
  reset: function () {
    this.paused = false;
    this.enabled = true;
    this.time = 0; // restart clip

    this._loopCount = -1; // forget previous loops

    this._startTime = null; // forget scheduling

    return this.stopFading().stopWarping();
  },
  isRunning: function () {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  },
  // return true when play has been called
  isScheduled: function () {
    return this._mixer._isActiveAction(this);
  },
  startAt: function (time) {
    this._startTime = time;
    return this;
  },
  setLoop: function (mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  },
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight: function (weight) {
    this.weight = weight; // note: same logic as when updated at runtime

    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  },
  // return the weight considering fading and .enabled
  getEffectiveWeight: function () {
    return this._effectiveWeight;
  },
  fadeIn: function (duration) {
    return this._scheduleFading(duration, 0, 1);
  },
  fadeOut: function (duration) {
    return this._scheduleFading(duration, 1, 0);
  },
  crossFadeFrom: function (fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);

    if (warp) {
      var fadeInDuration = this._clip.duration,
          fadeOutDuration = fadeOutAction._clip.duration,
          startEndRatio = fadeOutDuration / fadeInDuration,
          endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1.0, startEndRatio, duration);
      this.warp(endStartRatio, 1.0, duration);
    }

    return this;
  },
  crossFadeTo: function (fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  },
  stopFading: function () {
    var weightInterpolant = this._weightInterpolant;

    if (weightInterpolant !== null) {
      this._weightInterpolant = null;

      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }

    return this;
  },
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale: function (timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  },
  // return the time scale considering warping and .paused
  getEffectiveTimeScale: function () {
    return this._effectiveTimeScale;
  },
  setDuration: function (duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  },
  syncWith: function (action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  },
  halt: function (duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  },
  warp: function (startTimeScale, endTimeScale, duration) {
    var mixer = this._mixer,
        now = mixer.time,
        interpolant = this._timeScaleInterpolant,
        timeScale = this.timeScale;

    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }

    var times = interpolant.parameterPositions,
        values = interpolant.sampleValues;
    times[0] = now;
    times[1] = now + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  },
  stopWarping: function () {
    var timeScaleInterpolant = this._timeScaleInterpolant;

    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;

      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }

    return this;
  },
  // Object Accessors
  getMixer: function () {
    return this._mixer;
  },
  getClip: function () {
    return this._clip;
  },
  getRoot: function () {
    return this._localRoot || this._mixer._root;
  },
  // Interna
  _update: function (time, deltaTime, timeDirection, accuIndex) {
    // called by the mixer
    if (!this.enabled) {
      // call ._updateWeight() to update ._effectiveWeight
      this._updateWeight(time);

      return;
    }

    var startTime = this._startTime;

    if (startTime !== null) {
      // check for scheduled start of action
      var timeRunning = (time - startTime) * timeDirection;

      if (timeRunning < 0 || timeDirection === 0) {
        return; // yet to come / don't decide when delta = 0
      } // start


      this._startTime = null; // unschedule

      deltaTime = timeDirection * timeRunning;
    } // apply time scale and advance time


    deltaTime *= this._updateTimeScale(time);

    var clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in
    // an effective weight of 0


    var weight = this._updateWeight(time);

    if (weight > 0) {
      var interpolants = this._interpolants;
      var propertyMixers = this._propertyBindings;

      for (var j = 0, m = interpolants.length; j !== m; ++j) {
        interpolants[j].evaluate(clipTime);
        propertyMixers[j].accumulate(accuIndex, weight);
      }
    }
  },
  _updateWeight: function (time) {
    var weight = 0;

    if (this.enabled) {
      weight = this.weight;
      var interpolant = this._weightInterpolant;

      if (interpolant !== null) {
        var interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;

        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();

          if (interpolantValue === 0) {
            // faded out, disable
            this.enabled = false;
          }
        }
      }
    }

    this._effectiveWeight = weight;
    return weight;
  },
  _updateTimeScale: function (time) {
    var timeScale = 0;

    if (!this.paused) {
      timeScale = this.timeScale;
      var interpolant = this._timeScaleInterpolant;

      if (interpolant !== null) {
        var interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;

        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();

          if (timeScale === 0) {
            // motion has halted, pause
            this.paused = true;
          } else {
            // warp done - apply final time scale
            this.timeScale = timeScale;
          }
        }
      }
    }

    this._effectiveTimeScale = timeScale;
    return timeScale;
  },
  _updateTime: function (deltaTime) {
    var time = this.time + deltaTime;
    var duration = this._clip.duration;
    var loop = this.loop;
    var loopCount = this._loopCount;
    var pingPong = loop === LoopPingPong;

    if (deltaTime === 0) {
      if (loopCount === -1) return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }

    if (loop === LoopOnce) {
      if (loopCount === -1) {
        // just started
        this._loopCount = 0;

        this._setEndings(true, true, false);
      }

      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }

        if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
        this.time = time;

        this._mixer.dispatchEvent({
          type: 'finished',
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      // repetitive Repeat or PingPong
      if (loopCount === -1) {
        // just started
        if (deltaTime >= 0) {
          loopCount = 0;

          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          // when looping in reverse direction, the initial
          // transition through zero counts as a repetition,
          // so leave loopCount at -1
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }

      if (time >= duration || time < 0) {
        // wrap around
        var loopDelta = Math.floor(time / duration); // signed

        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        var pending = this.repetitions - loopCount;

        if (pending <= 0) {
          // have to stop (switch state, clamp time, fire event)
          if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;

          this._mixer.dispatchEvent({
            type: 'finished',
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          // keep running
          if (pending === 1) {
            // entering the last round
            var atStart = deltaTime < 0;

            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }

          this._loopCount = loopCount;
          this.time = time;

          this._mixer.dispatchEvent({
            type: 'loop',
            action: this,
            loopDelta: loopDelta
          });
        }
      } else {
        this.time = time;
      }

      if (pingPong && (loopCount & 1) === 1) {
        // invert time for the "pong round"
        return duration - time;
      }
    }

    return time;
  },
  _setEndings: function (atStart, atEnd, pingPong) {
    var settings = this._interpolantSettings;

    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      // assuming for LoopOnce atStart == atEnd == true
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }

      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  },
  _scheduleFading: function (duration, weightNow, weightThen) {
    var mixer = this._mixer,
        now = mixer.time,
        interpolant = this._weightInterpolant;

    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }

    var times = interpolant.parameterPositions,
        values = interpolant.sampleValues;
    times[0] = now;
    values[0] = weightNow;
    times[1] = now + duration;
    values[1] = weightThen;
    return this;
  }
});
/**
 *
 * Player for AnimationClips.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function AnimationMixer(root) {
  this._root = root;

  this._initMemoryManager();

  this._accuIndex = 0;
  this.time = 0;
  this.timeScale = 1.0;
}

AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: AnimationMixer,
  _bindAction: function (action, prototypeAction) {
    var root = action._localRoot || this._root,
        tracks = action._clip.tracks,
        nTracks = tracks.length,
        bindings = action._propertyBindings,
        interpolants = action._interpolants,
        rootUuid = root.uuid,
        bindingsByRoot = this._bindingsByRootAndName,
        bindingsByName = bindingsByRoot[rootUuid];

    if (bindingsByName === undefined) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }

    for (var i = 0; i !== nTracks; ++i) {
      var track = tracks[i],
          trackName = track.name,
          binding = bindingsByName[trackName];

      if (binding !== undefined) {
        bindings[i] = binding;
      } else {
        binding = bindings[i];

        if (binding !== undefined) {
          // existing binding, make sure the cache knows
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;

            this._addInactiveBinding(binding, rootUuid, trackName);
          }

          continue;
        }

        var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;

        this._addInactiveBinding(binding, rootUuid, trackName);

        bindings[i] = binding;
      }

      interpolants[i].resultBuffer = binding.buffer;
    }
  },
  _activateAction: function (action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        // this action has been forgotten by the cache, but the user
        // appears to be still using it -> rebind
        var rootUuid = (action._localRoot || this._root).uuid,
            clipUuid = action._clip.uuid,
            actionsForClip = this._actionsByClip[clipUuid];

        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);

        this._addInactiveAction(action, clipUuid, rootUuid);
      }

      var bindings = action._propertyBindings; // increment reference counts / sort out state

      for (var i = 0, n = bindings.length; i !== n; ++i) {
        var binding = bindings[i];

        if (binding.useCount++ === 0) {
          this._lendBinding(binding);

          binding.saveOriginalState();
        }
      }

      this._lendAction(action);
    }
  },
  _deactivateAction: function (action) {
    if (this._isActiveAction(action)) {
      var bindings = action._propertyBindings; // decrement reference counts / sort out state

      for (var i = 0, n = bindings.length; i !== n; ++i) {
        var binding = bindings[i];

        if (--binding.useCount === 0) {
          binding.restoreOriginalState();

          this._takeBackBinding(binding);
        }
      }

      this._takeBackAction(action);
    }
  },
  // Memory manager
  _initMemoryManager: function () {
    this._actions = []; // 'nActiveActions' followed by inactive ones

    this._nActiveActions = 0;
    this._actionsByClip = {}; // inside:
    // {
    // 	knownActions: Array< AnimationAction > - used as prototypes
    // 	actionByRoot: AnimationAction - lookup
    // }

    this._bindings = []; // 'nActiveBindings' followed by inactive ones

    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

    this._controlInterpolants = []; // same game as above

    this._nActiveControlInterpolants = 0;
    var scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },

        get inUse() {
          return scope._nActiveActions;
        }

      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },

        get inUse() {
          return scope._nActiveBindings;
        }

      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },

        get inUse() {
          return scope._nActiveControlInterpolants;
        }

      }
    };
  },
  // Memory management for AnimationAction objects
  _isActiveAction: function (action) {
    var index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  },
  _addInactiveAction: function (action, clipUuid, rootUuid) {
    var actions = this._actions,
        actionsByClip = this._actionsByClip,
        actionsForClip = actionsByClip[clipUuid];

    if (actionsForClip === undefined) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      var knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }

    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  },
  _removeInactiveAction: function (action) {
    var actions = this._actions,
        lastInactiveAction = actions[actions.length - 1],
        cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    var clipUuid = action._clip.uuid,
        actionsByClip = this._actionsByClip,
        actionsForClip = actionsByClip[clipUuid],
        knownActionsForClip = actionsForClip.knownActions,
        lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
        byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    var actionByRoot = actionsForClip.actionByRoot,
        rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];

    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }

    this._removeInactiveBindingsForAction(action);
  },
  _removeInactiveBindingsForAction: function (action) {
    var bindings = action._propertyBindings;

    for (var i = 0, n = bindings.length; i !== n; ++i) {
      var binding = bindings[i];

      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  },
  _lendAction: function (action) {
    // [ active actions |  inactive actions  ]
    // [  active actions >| inactive actions ]
    //                 s        a
    //                  <-swap->
    //                 a        s
    var actions = this._actions,
        prevIndex = action._cacheIndex,
        lastActiveIndex = this._nActiveActions++,
        firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  },
  _takeBackAction: function (action) {
    // [  active actions  | inactive actions ]
    // [ active actions |< inactive actions  ]
    //        a        s
    //         <-swap->
    //        s        a
    var actions = this._actions,
        prevIndex = action._cacheIndex,
        firstInactiveIndex = --this._nActiveActions,
        lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  },
  // Memory management for PropertyMixer objects
  _addInactiveBinding: function (binding, rootUuid, trackName) {
    var bindingsByRoot = this._bindingsByRootAndName,
        bindingByName = bindingsByRoot[rootUuid],
        bindings = this._bindings;

    if (bindingByName === undefined) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }

    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  },
  _removeInactiveBinding: function (binding) {
    var bindings = this._bindings,
        propBinding = binding.binding,
        rootUuid = propBinding.rootNode.uuid,
        trackName = propBinding.path,
        bindingsByRoot = this._bindingsByRootAndName,
        bindingByName = bindingsByRoot[rootUuid],
        lastInactiveBinding = bindings[bindings.length - 1],
        cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];

    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  },
  _lendBinding: function (binding) {
    var bindings = this._bindings,
        prevIndex = binding._cacheIndex,
        lastActiveIndex = this._nActiveBindings++,
        firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  },
  _takeBackBinding: function (binding) {
    var bindings = this._bindings,
        prevIndex = binding._cacheIndex,
        firstInactiveIndex = --this._nActiveBindings,
        lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  },
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant: function () {
    var interpolants = this._controlInterpolants,
        lastActiveIndex = this._nActiveControlInterpolants++,
        interpolant = interpolants[lastActiveIndex];

    if (interpolant === undefined) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }

    return interpolant;
  },
  _takeBackControlInterpolant: function (interpolant) {
    var interpolants = this._controlInterpolants,
        prevIndex = interpolant.__cacheIndex,
        firstInactiveIndex = --this._nActiveControlInterpolants,
        lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  },
  _controlInterpolantsResultBuffer: new Float32Array(1),
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction: function (clip, optionalRoot) {
    var root = optionalRoot || this._root,
        rootUuid = root.uuid,
        clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
        clipUuid = clipObject !== null ? clipObject.uuid : clip,
        actionsForClip = this._actionsByClip[clipUuid],
        prototypeAction = null;

    if (actionsForClip !== undefined) {
      var existingAction = actionsForClip.actionByRoot[rootUuid];

      if (existingAction !== undefined) {
        return existingAction;
      } // we know the clip, so we don't have to parse all
      // the bindings again but can just copy


      prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action

      if (clipObject === null) clipObject = prototypeAction._clip;
    } // clip must be known when specified via string


    if (clipObject === null) return null; // allocate all resources required to run it

    var newAction = new AnimationAction(this, clipObject, optionalRoot);

    this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager


    this._addInactiveAction(newAction, clipUuid, rootUuid);

    return newAction;
  },
  // get an existing action
  existingAction: function (clip, optionalRoot) {
    var root = optionalRoot || this._root,
        rootUuid = root.uuid,
        clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
        clipUuid = clipObject ? clipObject.uuid : clip,
        actionsForClip = this._actionsByClip[clipUuid];

    if (actionsForClip !== undefined) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }

    return null;
  },
  // deactivates all previously scheduled actions
  stopAllAction: function () {
    var actions = this._actions,
        nActions = this._nActiveActions,
        bindings = this._bindings,
        nBindings = this._nActiveBindings;
    this._nActiveActions = 0;
    this._nActiveBindings = 0;

    for (var i = 0; i !== nActions; ++i) {
      actions[i].reset();
    }

    for (var i = 0; i !== nBindings; ++i) {
      bindings[i].useCount = 0;
    }

    return this;
  },
  // advance the time and update apply the animation
  update: function (deltaTime) {
    deltaTime *= this.timeScale;
    var actions = this._actions,
        nActions = this._nActiveActions,
        time = this.time += deltaTime,
        timeDirection = Math.sign(deltaTime),
        accuIndex = this._accuIndex ^= 1; // run active actions

    for (var i = 0; i !== nActions; ++i) {
      var action = actions[i];

      action._update(time, deltaTime, timeDirection, accuIndex);
    } // update scene graph


    var bindings = this._bindings,
        nBindings = this._nActiveBindings;

    for (var i = 0; i !== nBindings; ++i) {
      bindings[i].apply(accuIndex);
    }

    return this;
  },
  // return this mixer's root target object
  getRoot: function () {
    return this._root;
  },
  // free all resources specific to a particular clip
  uncacheClip: function (clip) {
    var actions = this._actions,
        clipUuid = clip.uuid,
        actionsByClip = this._actionsByClip,
        actionsForClip = actionsByClip[clipUuid];

    if (actionsForClip !== undefined) {
      // note: just calling _removeInactiveAction would mess up the
      // iteration state and also require updating the state we can
      // just throw away
      var actionsToRemove = actionsForClip.knownActions;

      for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
        var action = actionsToRemove[i];

        this._deactivateAction(action);

        var cacheIndex = action._cacheIndex,
            lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();

        this._removeInactiveBindingsForAction(action);
      }

      delete actionsByClip[clipUuid];
    }
  },
  // free all resources specific to a particular root target object
  uncacheRoot: function (root) {
    var rootUuid = root.uuid,
        actionsByClip = this._actionsByClip;

    for (var clipUuid in actionsByClip) {
      var actionByRoot = actionsByClip[clipUuid].actionByRoot,
          action = actionByRoot[rootUuid];

      if (action !== undefined) {
        this._deactivateAction(action);

        this._removeInactiveAction(action);
      }
    }

    var bindingsByRoot = this._bindingsByRootAndName,
        bindingByName = bindingsByRoot[rootUuid];

    if (bindingByName !== undefined) {
      for (var trackName in bindingByName) {
        var binding = bindingByName[trackName];
        binding.restoreOriginalState();

        this._removeInactiveBinding(binding);
      }
    }
  },
  // remove a targeted clip from the cache
  uncacheAction: function (clip, optionalRoot) {
    var action = this.existingAction(clip, optionalRoot);

    if (action !== null) {
      this._deactivateAction(action);

      this._removeInactiveAction(action);
    }
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function Uniform(value) {
  if (typeof value === 'string') {
    console.warn('THREE.Uniform: Type parameter is no longer needed.');
    value = arguments[1];
  }

  this.value = value;
}

Uniform.prototype.clone = function () {
  return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
};
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */


function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
  InterleavedBuffer.call(this, array, stride);
  this.meshPerAttribute = meshPerAttribute || 1;
}

InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
  constructor: InstancedInterleavedBuffer,
  isInstancedInterleavedBuffer: true,
  copy: function (source) {
    InterleavedBuffer.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

function Raycaster(origin, direction, near, far) {
  this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)

  this.near = near || 0;
  this.far = far || Infinity;
  this.camera = null;
  this.params = {
    Mesh: {},
    Line: {},
    LOD: {},
    Points: {
      threshold: 1
    },
    Sprite: {}
  };
  Object.defineProperties(this.params, {
    PointCloud: {
      get: function () {
        console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
        return this.Points;
      }
    }
  });
}

function ascSort(a, b) {
  return a.distance - b.distance;
}

function intersectObject(object, raycaster, intersects, recursive) {
  if (object.visible === false) return;
  object.raycast(raycaster, intersects);

  if (recursive === true) {
    var children = object.children;

    for (var i = 0, l = children.length; i < l; i++) {
      intersectObject(children[i], raycaster, intersects, true);
    }
  }
}

Object.assign(Raycaster.prototype, {
  linePrecision: 1,
  set: function (origin, direction) {
    // direction is assumed to be normalized (for accurate distance calculations)
    this.ray.set(origin, direction);
  },
  setFromCamera: function (coords, camera) {
    if (camera && camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera && camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera

      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error('THREE.Raycaster: Unsupported camera type.');
    }
  },
  intersectObject: function (object, recursive, optionalTarget) {
    var intersects = optionalTarget || [];
    intersectObject(object, this, intersects, recursive);
    intersects.sort(ascSort);
    return intersects;
  },
  intersectObjects: function (objects, recursive, optionalTarget) {
    var intersects = optionalTarget || [];

    if (Array.isArray(objects) === false) {
      console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
      return intersects;
    }

    for (var i = 0, l = objects.length; i < l; i++) {
      intersectObject(objects[i], this, intersects, recursive);
    }

    intersects.sort(ascSort);
    return intersects;
  }
});
/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axiz.
 */

function Spherical(radius, phi, theta) {
  this.radius = radius !== undefined ? radius : 1.0;
  this.phi = phi !== undefined ? phi : 0; // polar angle

  this.theta = theta !== undefined ? theta : 0; // azimuthal angle

  return this;
}

Object.assign(Spherical.prototype, {
  set: function (radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  },
  // restrict phi to be betwee EPS and PI-EPS
  makeSafe: function () {
    var EPS = 0.000001;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  },
  setFromVector3: function (v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  },
  setFromCartesianCoords: function (x, y, z) {
    this.radius = Math.sqrt(x * x + y * y + z * z);

    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x, z);
      this.phi = Math.acos(_Math.clamp(y / this.radius, -1, 1));
    }

    return this;
  }
});
/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 *
 */

function Cylindrical(radius, theta, y) {
  this.radius = radius !== undefined ? radius : 1.0; // distance from the origin to a point in the x-z plane

  this.theta = theta !== undefined ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis

  this.y = y !== undefined ? y : 0; // height above the x-z plane

  return this;
}

Object.assign(Cylindrical.prototype, {
  set: function (radius, theta, y) {
    this.radius = radius;
    this.theta = theta;
    this.y = y;
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (other) {
    this.radius = other.radius;
    this.theta = other.theta;
    this.y = other.y;
    return this;
  },
  setFromVector3: function (v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  },
  setFromCartesianCoords: function (x, y, z) {
    this.radius = Math.sqrt(x * x + z * z);
    this.theta = Math.atan2(x, z);
    this.y = y;
    return this;
  }
});
/**
 * @author bhouston / http://clara.io
 */

var _vector$6 = new Vector2();

function Box2(min, max) {
  this.min = min !== undefined ? min : new Vector2(+Infinity, +Infinity);
  this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);
}

Object.assign(Box2.prototype, {
  set: function (min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  },
  setFromPoints: function (points) {
    this.makeEmpty();

    for (var i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }

    return this;
  },
  setFromCenterAndSize: function (center, size) {
    var halfSize = _vector$6.copy(size).multiplyScalar(0.5);

    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = +Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  },
  isEmpty: function () {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  getCenter: function (target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .getCenter() target is now required');
      target = new Vector2();
    }

    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function (target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .getSize() target is now required');
      target = new Vector2();
    }

    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
  },
  expandByPoint: function (point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function (vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function (scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  },
  containsPoint: function (point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
  },
  containsBox: function (box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  },
  getParameter: function (point, target) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.
    if (target === undefined) {
      console.warn('THREE.Box2: .getParameter() target is now required');
      target = new Vector2();
    }

    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
  },
  intersectsBox: function (box) {
    // using 4 splitting planes to rule out intersections
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
  },
  clampPoint: function (point, target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .clampPoint() target is now required');
      target = new Vector2();
    }

    return target.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function (point) {
    var clampedPoint = _vector$6.copy(point).clamp(this.min, this.max);

    return clampedPoint.sub(point).length();
  },
  intersect: function (box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  },
  union: function (box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  translate: function (offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  },
  equals: function (box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
});
/**
 * @author bhouston / http://clara.io
 */

var _startP = new Vector3();

var _startEnd = new Vector3();

function Line3(start, end) {
  this.start = start !== undefined ? start : new Vector3();
  this.end = end !== undefined ? end : new Vector3();
}

Object.assign(Line3.prototype, {
  set: function (start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  },
  getCenter: function (target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .getCenter() target is now required');
      target = new Vector3();
    }

    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  },
  delta: function (target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .delta() target is now required');
      target = new Vector3();
    }

    return target.subVectors(this.end, this.start);
  },
  distanceSq: function () {
    return this.start.distanceToSquared(this.end);
  },
  distance: function () {
    return this.start.distanceTo(this.end);
  },
  at: function (t, target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .at() target is now required');
      target = new Vector3();
    }

    return this.delta(target).multiplyScalar(t).add(this.start);
  },
  closestPointToPointParameter: function (point, clampToLine) {
    _startP.subVectors(point, this.start);

    _startEnd.subVectors(this.end, this.start);

    var startEnd2 = _startEnd.dot(_startEnd);

    var startEnd_startP = _startEnd.dot(_startP);

    var t = startEnd_startP / startEnd2;

    if (clampToLine) {
      t = _Math.clamp(t, 0, 1);
    }

    return t;
  },
  closestPointToPoint: function (point, clampToLine, target) {
    var t = this.closestPointToPointParameter(point, clampToLine);

    if (target === undefined) {
      console.warn('THREE.Line3: .closestPointToPoint() target is now required');
      target = new Vector3();
    }

    return this.delta(target).multiplyScalar(t).add(this.start);
  },
  applyMatrix4: function (matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  },
  equals: function (line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */

function ImmediateRenderObject(material) {
  Object3D.call(this);
  this.material = material;

  this.render = function ()
  /* renderCallback */
  {};
}

ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

var _v1$5 = new Vector3();

var _v2$3 = new Vector3();

var _normalMatrix$1 = new Matrix3();

var _keys = ['a', 'b', 'c'];

function VertexNormalsHelper(object, size, hex, linewidth) {
  this.object = object;
  this.size = size !== undefined ? size : 1;
  var color = hex !== undefined ? hex : 0xff0000;
  var width = linewidth !== undefined ? linewidth : 1; //

  var nNormals = 0;
  var objGeometry = this.object.geometry;

  if (objGeometry && objGeometry.isGeometry) {
    nNormals = objGeometry.faces.length * 3;
  } else if (objGeometry && objGeometry.isBufferGeometry) {
    nNormals = objGeometry.attributes.normal.count;
  } //


  var geometry = new BufferGeometry();
  var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
  geometry.addAttribute('position', positions);
  LineSegments.call(this, geometry, new LineBasicMaterial({
    color: color,
    linewidth: width
  })); //

  this.matrixAutoUpdate = false;
  this.update();
}

VertexNormalsHelper.prototype = Object.create(LineSegments.prototype);
VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

VertexNormalsHelper.prototype.update = function () {
  this.object.updateMatrixWorld(true);

  _normalMatrix$1.getNormalMatrix(this.object.matrixWorld);

  var matrixWorld = this.object.matrixWorld;
  var position = this.geometry.attributes.position; //

  var objGeometry = this.object.geometry;

  if (objGeometry && objGeometry.isGeometry) {
    var vertices = objGeometry.vertices;
    var faces = objGeometry.faces;
    var idx = 0;

    for (var i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];

      for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
        var vertex = vertices[face[_keys[j]]];
        var normal = face.vertexNormals[j];

        _v1$5.copy(vertex).applyMatrix4(matrixWorld);

        _v2$3.copy(normal).applyMatrix3(_normalMatrix$1).normalize().multiplyScalar(this.size).add(_v1$5);

        position.setXYZ(idx, _v1$5.x, _v1$5.y, _v1$5.z);
        idx = idx + 1;
        position.setXYZ(idx, _v2$3.x, _v2$3.y, _v2$3.z);
        idx = idx + 1;
      }
    }
  } else if (objGeometry && objGeometry.isBufferGeometry) {
    var objPos = objGeometry.attributes.position;
    var objNorm = objGeometry.attributes.normal;
    var idx = 0; // for simplicity, ignore index and drawcalls, and render every normal

    for (var j = 0, jl = objPos.count; j < jl; j++) {
      _v1$5.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);

      _v2$3.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));

      _v2$3.applyMatrix3(_normalMatrix$1).normalize().multiplyScalar(this.size).add(_v1$5);

      position.setXYZ(idx, _v1$5.x, _v1$5.y, _v1$5.z);
      idx = idx + 1;
      position.setXYZ(idx, _v2$3.x, _v2$3.y, _v2$3.z);
      idx = idx + 1;
    }
  }

  position.needsUpdate = true;
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */


var _vector$7 = new Vector3();

function SpotLightHelper(light, color) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color;
  var geometry = new BufferGeometry();
  var positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];

  for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
    var p1 = i / l * Math.PI * 2;
    var p2 = j / l * Math.PI * 2;
    positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
  }

  geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));
  var material = new LineBasicMaterial({
    fog: false
  });
  this.cone = new LineSegments(geometry, material);
  this.add(this.cone);
  this.update();
}

SpotLightHelper.prototype = Object.create(Object3D.prototype);
SpotLightHelper.prototype.constructor = SpotLightHelper;

SpotLightHelper.prototype.dispose = function () {
  this.cone.geometry.dispose();
  this.cone.material.dispose();
};

SpotLightHelper.prototype.update = function () {
  this.light.updateMatrixWorld();
  var coneLength = this.light.distance ? this.light.distance : 1000;
  var coneWidth = coneLength * Math.tan(this.light.angle);
  this.cone.scale.set(coneWidth, coneWidth, coneLength);

  _vector$7.setFromMatrixPosition(this.light.target.matrixWorld);

  this.cone.lookAt(_vector$7);

  if (this.color !== undefined) {
    this.cone.material.color.set(this.color);
  } else {
    this.cone.material.color.copy(this.light.color);
  }
};
/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 * @author Mugen87 / https://github.com/Mugen87
 */


var _vector$8 = new Vector3();

var _boneMatrix = new Matrix4();

var _matrixWorldInv = new Matrix4();

function getBoneList(object) {
  var boneList = [];

  if (object && object.isBone) {
    boneList.push(object);
  }

  for (var i = 0; i < object.children.length; i++) {
    boneList.push.apply(boneList, getBoneList(object.children[i]));
  }

  return boneList;
}

function SkeletonHelper(object) {
  var bones = getBoneList(object);
  var geometry = new BufferGeometry();
  var vertices = [];
  var colors = [];
  var color1 = new Color(0, 0, 1);
  var color2 = new Color(0, 1, 0);

  for (var i = 0; i < bones.length; i++) {
    var bone = bones[i];

    if (bone.parent && bone.parent.isBone) {
      vertices.push(0, 0, 0);
      vertices.push(0, 0, 0);
      colors.push(color1.r, color1.g, color1.b);
      colors.push(color2.r, color2.g, color2.b);
    }
  }

  geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
  var material = new LineBasicMaterial({
    vertexColors: VertexColors,
    depthTest: false,
    depthWrite: false,
    transparent: true
  });
  LineSegments.call(this, geometry, material);
  this.root = object;
  this.bones = bones;
  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;
}

SkeletonHelper.prototype = Object.create(LineSegments.prototype);
SkeletonHelper.prototype.constructor = SkeletonHelper;

SkeletonHelper.prototype.updateMatrixWorld = function (force) {
  var bones = this.bones;
  var geometry = this.geometry;
  var position = geometry.getAttribute('position');

  _matrixWorldInv.getInverse(this.root.matrixWorld);

  for (var i = 0, j = 0; i < bones.length; i++) {
    var bone = bones[i];

    if (bone.parent && bone.parent.isBone) {
      _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);

      _vector$8.setFromMatrixPosition(_boneMatrix);

      position.setXYZ(j, _vector$8.x, _vector$8.y, _vector$8.z);

      _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);

      _vector$8.setFromMatrixPosition(_boneMatrix);

      position.setXYZ(j + 1, _vector$8.x, _vector$8.y, _vector$8.z);
      j += 2;
    }
  }

  geometry.getAttribute('position').needsUpdate = true;
  Object3D.prototype.updateMatrixWorld.call(this, force);
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */


function PointLightHelper(light, sphereSize, color) {
  this.light = light;
  this.light.updateMatrixWorld();
  this.color = color;
  var geometry = new SphereBufferGeometry(sphereSize, 4, 2);
  var material = new MeshBasicMaterial({
    wireframe: true,
    fog: false
  });
  Mesh.call(this, geometry, material);
  this.matrix = this.light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.update();
  /*
  var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
  var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
  	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
  this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
  	var d = light.distance;
  	if ( d === 0.0 ) {
  		this.lightDistance.visible = false;
  	} else {
  		this.lightDistance.scale.set( d, d, d );
  	}
  	this.add( this.lightDistance );
  */
}

PointLightHelper.prototype = Object.create(Mesh.prototype);
PointLightHelper.prototype.constructor = PointLightHelper;

PointLightHelper.prototype.dispose = function () {
  this.geometry.dispose();
  this.material.dispose();
};

PointLightHelper.prototype.update = function () {
  if (this.color !== undefined) {
    this.material.color.set(this.color);
  } else {
    this.material.color.copy(this.light.color);
  }
  /*
  var d = this.light.distance;
  	if ( d === 0.0 ) {
  		this.lightDistance.visible = false;
  	} else {
  		this.lightDistance.visible = true;
  	this.lightDistance.scale.set( d, d, d );
  	}
  */

};
/**
 * @author abelnation / http://github.com/abelnation
 * @author Mugen87 / http://github.com/Mugen87
 * @author WestLangley / http://github.com/WestLangley
 *
 *  This helper must be added as a child of the light
 */


function RectAreaLightHelper(light, color) {
  this.type = 'RectAreaLightHelper';
  this.light = light;
  this.color = color; // optional hardwired color for the helper

  var positions = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
  var geometry = new BufferGeometry();
  geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));
  geometry.computeBoundingSphere();
  var material = new LineBasicMaterial({
    fog: false
  });
  Line.call(this, geometry, material); //

  var positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
  var geometry2 = new BufferGeometry();
  geometry2.addAttribute('position', new Float32BufferAttribute(positions2, 3));
  geometry2.computeBoundingSphere();
  this.add(new Mesh(geometry2, new MeshBasicMaterial({
    side: BackSide,
    fog: false
  })));
  this.update();
}

RectAreaLightHelper.prototype = Object.create(Line.prototype);
RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

RectAreaLightHelper.prototype.update = function () {
  this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1);

  if (this.color !== undefined) {
    this.material.color.set(this.color);
    this.children[0].material.color.set(this.color);
  } else {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity); // prevent hue shift

    var c = this.material.color;
    var max = Math.max(c.r, c.g, c.b);
    if (max > 1) c.multiplyScalar(1 / max);
    this.children[0].material.color.copy(this.material.color);
  }
};

RectAreaLightHelper.prototype.dispose = function () {
  this.geometry.dispose();
  this.material.dispose();
  this.children[0].geometry.dispose();
  this.children[0].material.dispose();
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */


var _vector$9 = new Vector3();

var _color1 = new Color();

var _color2 = new Color();

function HemisphereLightHelper(light, size, color) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color;
  var geometry = new OctahedronBufferGeometry(size);
  geometry.rotateY(Math.PI * 0.5);
  this.material = new MeshBasicMaterial({
    wireframe: true,
    fog: false
  });
  if (this.color === undefined) this.material.vertexColors = VertexColors;
  var position = geometry.getAttribute('position');
  var colors = new Float32Array(position.count * 3);
  geometry.addAttribute('color', new BufferAttribute(colors, 3));
  this.add(new Mesh(geometry, this.material));
  this.update();
}

HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

HemisphereLightHelper.prototype.dispose = function () {
  this.children[0].geometry.dispose();
  this.children[0].material.dispose();
};

HemisphereLightHelper.prototype.update = function () {
  var mesh = this.children[0];

  if (this.color !== undefined) {
    this.material.color.set(this.color);
  } else {
    var colors = mesh.geometry.getAttribute('color');

    _color1.copy(this.light.color);

    _color2.copy(this.light.groundColor);

    for (var i = 0, l = colors.count; i < l; i++) {
      var color = i < l / 2 ? _color1 : _color2;
      colors.setXYZ(i, color.r, color.g, color.b);
    }

    colors.needsUpdate = true;
  }

  mesh.lookAt(_vector$9.setFromMatrixPosition(this.light.matrixWorld).negate());
};
/**
 * @author WestLangley / http://github.com/WestLangley
 */


function LightProbeHelper(lightProbe, size) {
  this.lightProbe = lightProbe;
  this.size = size;
  var defines = {};
  defines['GAMMA_OUTPUT'] = ""; // material

  var material = new ShaderMaterial({
    defines: defines,
    uniforms: {
      sh: {
        value: this.lightProbe.sh.coefficients
      },
      // by reference
      intensity: {
        value: this.lightProbe.intensity
      }
    },
    vertexShader: ['varying vec3 vNormal;', 'void main() {', '	vNormal = normalize( normalMatrix * normal );', '	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\n'),
    fragmentShader: ['#define RECIPROCAL_PI 0.318309886', 'vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {', '	// matrix is assumed to be orthogonal', '	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );', '}', 'vec3 linearToOutput( in vec3 a ) {', '	#ifdef GAMMA_OUTPUT', '		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );', '	#else', '		return a;', '	#endif', '}', '// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf', 'vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {', '	// normal is assumed to have unit length', '	float x = normal.x, y = normal.y, z = normal.z;', '	// band 0', '	vec3 result = shCoefficients[ 0 ] * 0.886227;', '	// band 1', '	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;', '	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;', '	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;', '	// band 2', '	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;', '	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;', '	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );', '	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;', '	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );', '	return result;', '}', 'uniform vec3 sh[ 9 ]; // sh coefficients', 'uniform float intensity; // light probe intensity', 'varying vec3 vNormal;', 'void main() {', '	vec3 normal = normalize( vNormal );', '	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );', '	vec3 irradiance = shGetIrradianceAt( worldNormal, sh );', '	vec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;', '	outgoingLight = linearToOutput( outgoingLight );', '	gl_FragColor = vec4( outgoingLight, 1.0 );', '}'].join('\n')
  });
  var geometry = new SphereBufferGeometry(1, 32, 16);
  Mesh.call(this, geometry, material);
  this.onBeforeRender();
}

LightProbeHelper.prototype = Object.create(Mesh.prototype);
LightProbeHelper.prototype.constructor = LightProbeHelper;

LightProbeHelper.prototype.dispose = function () {
  this.geometry.dispose();
  this.material.dispose();
};

LightProbeHelper.prototype.onBeforeRender = function () {
  this.position.copy(this.lightProbe.position);
  this.scale.set(1, 1, 1).multiplyScalar(this.size);
  this.material.uniforms.intensity.value = this.lightProbe.intensity;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */


function GridHelper(size, divisions, color1, color2) {
  size = size || 10;
  divisions = divisions || 10;
  color1 = new Color(color1 !== undefined ? color1 : 0x444444);
  color2 = new Color(color2 !== undefined ? color2 : 0x888888);
  var center = divisions / 2;
  var step = size / divisions;
  var halfSize = size / 2;
  var vertices = [],
      colors = [];

  for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
    vertices.push(-halfSize, 0, k, halfSize, 0, k);
    vertices.push(k, 0, -halfSize, k, 0, halfSize);
    var color = i === center ? color1 : color2;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
  }

  var geometry = new BufferGeometry();
  geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
  var material = new LineBasicMaterial({
    vertexColors: VertexColors
  });
  LineSegments.call(this, geometry, material);
}

GridHelper.prototype = Object.assign(Object.create(LineSegments.prototype), {
  constructor: GridHelper,
  copy: function (source) {
    LineSegments.prototype.copy.call(this, source);
    this.geometry.copy(source.geometry);
    this.material.copy(source.material);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 * @author Hectate / http://www.github.com/Hectate
 */

function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
  radius = radius || 10;
  radials = radials || 16;
  circles = circles || 8;
  divisions = divisions || 64;
  color1 = new Color(color1 !== undefined ? color1 : 0x444444);
  color2 = new Color(color2 !== undefined ? color2 : 0x888888);
  var vertices = [];
  var colors = [];
  var x, z;
  var v, i, j, r, color; // create the radials

  for (i = 0; i <= radials; i++) {
    v = i / radials * (Math.PI * 2);
    x = Math.sin(v) * radius;
    z = Math.cos(v) * radius;
    vertices.push(0, 0, 0);
    vertices.push(x, 0, z);
    color = i & 1 ? color1 : color2;
    colors.push(color.r, color.g, color.b);
    colors.push(color.r, color.g, color.b);
  } // create the circles


  for (i = 0; i <= circles; i++) {
    color = i & 1 ? color1 : color2;
    r = radius - radius / circles * i;

    for (j = 0; j < divisions; j++) {
      // first vertex
      v = j / divisions * (Math.PI * 2);
      x = Math.sin(v) * r;
      z = Math.cos(v) * r;
      vertices.push(x, 0, z);
      colors.push(color.r, color.g, color.b); // second vertex

      v = (j + 1) / divisions * (Math.PI * 2);
      x = Math.sin(v) * r;
      z = Math.cos(v) * r;
      vertices.push(x, 0, z);
      colors.push(color.r, color.g, color.b);
    }
  }

  var geometry = new BufferGeometry();
  geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
  var material = new LineBasicMaterial({
    vertexColors: VertexColors
  });
  LineSegments.call(this, geometry, material);
}

PolarGridHelper.prototype = Object.create(LineSegments.prototype);
PolarGridHelper.prototype.constructor = PolarGridHelper;
/**
 * @author Mugen87 / http://github.com/Mugen87
 */

function PositionalAudioHelper(audio, range, divisionsInnerAngle, divisionsOuterAngle) {
  this.audio = audio;
  this.range = range || 1;
  this.divisionsInnerAngle = divisionsInnerAngle || 16;
  this.divisionsOuterAngle = divisionsOuterAngle || 2;
  var geometry = new BufferGeometry();
  var divisions = this.divisionsInnerAngle + this.divisionsOuterAngle * 2;
  var positions = new Float32Array((divisions * 3 + 3) * 3);
  geometry.addAttribute('position', new BufferAttribute(positions, 3));
  var materialInnerAngle = new LineBasicMaterial({
    color: 0x00ff00
  });
  var materialOuterAngle = new LineBasicMaterial({
    color: 0xffff00
  });
  Line.call(this, geometry, [materialOuterAngle, materialInnerAngle]);
  this.update();
}

PositionalAudioHelper.prototype = Object.create(Line.prototype);
PositionalAudioHelper.prototype.constructor = PositionalAudioHelper;

PositionalAudioHelper.prototype.update = function () {
  var audio = this.audio;
  var range = this.range;
  var divisionsInnerAngle = this.divisionsInnerAngle;
  var divisionsOuterAngle = this.divisionsOuterAngle;

  var coneInnerAngle = _Math.degToRad(audio.panner.coneInnerAngle);

  var coneOuterAngle = _Math.degToRad(audio.panner.coneOuterAngle);

  var halfConeInnerAngle = coneInnerAngle / 2;
  var halfConeOuterAngle = coneOuterAngle / 2;
  var start = 0;
  var count = 0;
  var i, stride;
  var geometry = this.geometry;
  var positionAttribute = geometry.attributes.position;
  geometry.clearGroups(); //

  function generateSegment(from, to, divisions, materialIndex) {
    var step = (to - from) / divisions;
    positionAttribute.setXYZ(start, 0, 0, 0);
    count++;

    for (i = from; i < to; i += step) {
      stride = start + count;
      positionAttribute.setXYZ(stride, Math.sin(i) * range, 0, Math.cos(i) * range);
      positionAttribute.setXYZ(stride + 1, Math.sin(Math.min(i + step, to)) * range, 0, Math.cos(Math.min(i + step, to)) * range);
      positionAttribute.setXYZ(stride + 2, 0, 0, 0);
      count += 3;
    }

    geometry.addGroup(start, count, materialIndex);
    start += count;
    count = 0;
  } //


  generateSegment(-halfConeOuterAngle, -halfConeInnerAngle, divisionsOuterAngle, 0);
  generateSegment(-halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1);
  generateSegment(halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0); //

  positionAttribute.needsUpdate = true;
  if (coneInnerAngle === coneOuterAngle) this.material[0].visible = false;
};

PositionalAudioHelper.prototype.dispose = function () {
  this.geometry.dispose();
  this.material[0].dispose();
  this.material[1].dispose();
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */


var _v1$6 = new Vector3();

var _v2$4 = new Vector3();

var _normalMatrix$2 = new Matrix3();

function FaceNormalsHelper(object, size, hex, linewidth) {
  // FaceNormalsHelper only supports THREE.Geometry
  this.object = object;
  this.size = size !== undefined ? size : 1;
  var color = hex !== undefined ? hex : 0xffff00;
  var width = linewidth !== undefined ? linewidth : 1; //

  var nNormals = 0;
  var objGeometry = this.object.geometry;

  if (objGeometry && objGeometry.isGeometry) {
    nNormals = objGeometry.faces.length;
  } else {
    console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');
  } //


  var geometry = new BufferGeometry();
  var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
  geometry.addAttribute('position', positions);
  LineSegments.call(this, geometry, new LineBasicMaterial({
    color: color,
    linewidth: width
  })); //

  this.matrixAutoUpdate = false;
  this.update();
}

FaceNormalsHelper.prototype = Object.create(LineSegments.prototype);
FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

FaceNormalsHelper.prototype.update = function () {
  this.object.updateMatrixWorld(true);

  _normalMatrix$2.getNormalMatrix(this.object.matrixWorld);

  var matrixWorld = this.object.matrixWorld;
  var position = this.geometry.attributes.position; //

  var objGeometry = this.object.geometry;
  var vertices = objGeometry.vertices;
  var faces = objGeometry.faces;
  var idx = 0;

  for (var i = 0, l = faces.length; i < l; i++) {
    var face = faces[i];
    var normal = face.normal;

    _v1$6.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);

    _v2$4.copy(normal).applyMatrix3(_normalMatrix$2).normalize().multiplyScalar(this.size).add(_v1$6);

    position.setXYZ(idx, _v1$6.x, _v1$6.y, _v1$6.z);
    idx = idx + 1;
    position.setXYZ(idx, _v2$4.x, _v2$4.y, _v2$4.z);
    idx = idx + 1;
  }

  position.needsUpdate = true;
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */


var _v1$7 = new Vector3();

var _v2$5 = new Vector3();

var _v3$1 = new Vector3();

function DirectionalLightHelper(light, size, color) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color;
  if (size === undefined) size = 1;
  var geometry = new BufferGeometry();
  geometry.addAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
  var material = new LineBasicMaterial({
    fog: false
  });
  this.lightPlane = new Line(geometry, material);
  this.add(this.lightPlane);
  geometry = new BufferGeometry();
  geometry.addAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
  this.targetLine = new Line(geometry, material);
  this.add(this.targetLine);
  this.update();
}

DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

DirectionalLightHelper.prototype.dispose = function () {
  this.lightPlane.geometry.dispose();
  this.lightPlane.material.dispose();
  this.targetLine.geometry.dispose();
  this.targetLine.material.dispose();
};

DirectionalLightHelper.prototype.update = function () {
  _v1$7.setFromMatrixPosition(this.light.matrixWorld);

  _v2$5.setFromMatrixPosition(this.light.target.matrixWorld);

  _v3$1.subVectors(_v2$5, _v1$7);

  this.lightPlane.lookAt(_v2$5);

  if (this.color !== undefined) {
    this.lightPlane.material.color.set(this.color);
    this.targetLine.material.color.set(this.color);
  } else {
    this.lightPlane.material.color.copy(this.light.color);
    this.targetLine.material.color.copy(this.light.color);
  }

  this.targetLine.lookAt(_v2$5);
  this.targetLine.scale.z = _v3$1.length();
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author Mugen87 / https://github.com/Mugen87
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */


var _vector$a = new Vector3();

var _camera = new Camera();

function CameraHelper(camera) {
  var geometry = new BufferGeometry();
  var material = new LineBasicMaterial({
    color: 0xffffff,
    vertexColors: FaceColors
  });
  var vertices = [];
  var colors = [];
  var pointMap = {}; // colors

  var colorFrustum = new Color(0xffaa00);
  var colorCone = new Color(0xff0000);
  var colorUp = new Color(0x00aaff);
  var colorTarget = new Color(0xffffff);
  var colorCross = new Color(0x333333); // near

  addLine('n1', 'n2', colorFrustum);
  addLine('n2', 'n4', colorFrustum);
  addLine('n4', 'n3', colorFrustum);
  addLine('n3', 'n1', colorFrustum); // far

  addLine('f1', 'f2', colorFrustum);
  addLine('f2', 'f4', colorFrustum);
  addLine('f4', 'f3', colorFrustum);
  addLine('f3', 'f1', colorFrustum); // sides

  addLine('n1', 'f1', colorFrustum);
  addLine('n2', 'f2', colorFrustum);
  addLine('n3', 'f3', colorFrustum);
  addLine('n4', 'f4', colorFrustum); // cone

  addLine('p', 'n1', colorCone);
  addLine('p', 'n2', colorCone);
  addLine('p', 'n3', colorCone);
  addLine('p', 'n4', colorCone); // up

  addLine('u1', 'u2', colorUp);
  addLine('u2', 'u3', colorUp);
  addLine('u3', 'u1', colorUp); // target

  addLine('c', 't', colorTarget);
  addLine('p', 'c', colorCross); // cross

  addLine('cn1', 'cn2', colorCross);
  addLine('cn3', 'cn4', colorCross);
  addLine('cf1', 'cf2', colorCross);
  addLine('cf3', 'cf4', colorCross);

  function addLine(a, b, color) {
    addPoint(a, color);
    addPoint(b, color);
  }

  function addPoint(id, color) {
    vertices.push(0, 0, 0);
    colors.push(color.r, color.g, color.b);

    if (pointMap[id] === undefined) {
      pointMap[id] = [];
    }

    pointMap[id].push(vertices.length / 3 - 1);
  }

  geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
  LineSegments.call(this, geometry, material);
  this.camera = camera;
  if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
  this.matrix = camera.matrixWorld;
  this.matrixAutoUpdate = false;
  this.pointMap = pointMap;
  this.update();
}

CameraHelper.prototype = Object.create(LineSegments.prototype);
CameraHelper.prototype.constructor = CameraHelper;

CameraHelper.prototype.update = function () {
  var geometry = this.geometry;
  var pointMap = this.pointMap;
  var w = 1,
      h = 1; // we need just camera projection matrix inverse
  // world matrix must be identity

  _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); // center / target


  setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
  setPoint('t', pointMap, geometry, _camera, 0, 0, 1); // near

  setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
  setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
  setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
  setPoint('n4', pointMap, geometry, _camera, w, h, -1); // far

  setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
  setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
  setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
  setPoint('f4', pointMap, geometry, _camera, w, h, 1); // up

  setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
  setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
  setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1); // cross

  setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
  setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
  setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
  setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
  setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
  setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
  setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
  setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
  geometry.getAttribute('position').needsUpdate = true;
};

function setPoint(point, pointMap, geometry, camera, x, y, z) {
  _vector$a.set(x, y, z).unproject(camera);

  var points = pointMap[point];

  if (points !== undefined) {
    var position = geometry.getAttribute('position');

    for (var i = 0, l = points.length; i < l; i++) {
      position.setXYZ(points[i], _vector$a.x, _vector$a.y, _vector$a.z);
    }
  }
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 */


var _box$2 = new Box3();

function BoxHelper(object, color) {
  this.object = object;
  if (color === undefined) color = 0xffff00;
  var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
  var positions = new Float32Array(8 * 3);
  var geometry = new BufferGeometry();
  geometry.setIndex(new BufferAttribute(indices, 1));
  geometry.addAttribute('position', new BufferAttribute(positions, 3));
  LineSegments.call(this, geometry, new LineBasicMaterial({
    color: color
  }));
  this.matrixAutoUpdate = false;
  this.update();
}

BoxHelper.prototype = Object.create(LineSegments.prototype);
BoxHelper.prototype.constructor = BoxHelper;

BoxHelper.prototype.update = function (object) {
  if (object !== undefined) {
    console.warn('THREE.BoxHelper: .update() has no longer arguments.');
  }

  if (this.object !== undefined) {
    _box$2.setFromObject(this.object);
  }

  if (_box$2.isEmpty()) return;
  var min = _box$2.min;
  var max = _box$2.max;
  /*
    5____4
  1/___0/|
  | 6__|_7
  2/___3/
  	0: max.x, max.y, max.z
  1: min.x, max.y, max.z
  2: min.x, min.y, max.z
  3: max.x, min.y, max.z
  4: max.x, max.y, min.z
  5: min.x, max.y, min.z
  6: min.x, min.y, min.z
  7: max.x, min.y, min.z
  */

  var position = this.geometry.attributes.position;
  var array = position.array;
  array[0] = max.x;
  array[1] = max.y;
  array[2] = max.z;
  array[3] = min.x;
  array[4] = max.y;
  array[5] = max.z;
  array[6] = min.x;
  array[7] = min.y;
  array[8] = max.z;
  array[9] = max.x;
  array[10] = min.y;
  array[11] = max.z;
  array[12] = max.x;
  array[13] = max.y;
  array[14] = min.z;
  array[15] = min.x;
  array[16] = max.y;
  array[17] = min.z;
  array[18] = min.x;
  array[19] = min.y;
  array[20] = min.z;
  array[21] = max.x;
  array[22] = min.y;
  array[23] = min.z;
  position.needsUpdate = true;
  this.geometry.computeBoundingSphere();
};

BoxHelper.prototype.setFromObject = function (object) {
  this.object = object;
  this.update();
  return this;
};

BoxHelper.prototype.copy = function (source) {
  LineSegments.prototype.copy.call(this, source);
  this.object = source.object;
  return this;
};

BoxHelper.prototype.clone = function () {
  return new this.constructor().copy(this);
};
/**
 * @author WestLangley / http://github.com/WestLangley
 */


function Box3Helper(box, color) {
  this.type = 'Box3Helper';
  this.box = box;
  color = color || 0xffff00;
  var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
  var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
  var geometry = new BufferGeometry();
  geometry.setIndex(new BufferAttribute(indices, 1));
  geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));
  LineSegments.call(this, geometry, new LineBasicMaterial({
    color: color
  }));
  this.geometry.computeBoundingSphere();
}

Box3Helper.prototype = Object.create(LineSegments.prototype);
Box3Helper.prototype.constructor = Box3Helper;

Box3Helper.prototype.updateMatrixWorld = function (force) {
  var box = this.box;
  if (box.isEmpty()) return;
  box.getCenter(this.position);
  box.getSize(this.scale);
  this.scale.multiplyScalar(0.5);
  Object3D.prototype.updateMatrixWorld.call(this, force);
};
/**
 * @author WestLangley / http://github.com/WestLangley
 */


function PlaneHelper(plane, size, hex) {
  this.type = 'PlaneHelper';
  this.plane = plane;
  this.size = size === undefined ? 1 : size;
  var color = hex !== undefined ? hex : 0xffff00;
  var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
  var geometry = new BufferGeometry();
  geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));
  geometry.computeBoundingSphere();
  Line.call(this, geometry, new LineBasicMaterial({
    color: color
  })); //

  var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
  var geometry2 = new BufferGeometry();
  geometry2.addAttribute('position', new Float32BufferAttribute(positions2, 3));
  geometry2.computeBoundingSphere();
  this.add(new Mesh(geometry2, new MeshBasicMaterial({
    color: color,
    opacity: 0.2,
    transparent: true,
    depthWrite: false
  })));
}

PlaneHelper.prototype = Object.create(Line.prototype);
PlaneHelper.prototype.constructor = PlaneHelper;

PlaneHelper.prototype.updateMatrixWorld = function (force) {
  var scale = -this.plane.constant;
  if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter

  this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
  this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

  this.lookAt(this.plane.normal);
  Object3D.prototype.updateMatrixWorld.call(this, force);
};
/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */


var _axis = new Vector3();

var _lineGeometry, _coneGeometry;

function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
  // dir is assumed to be normalized
  Object3D.call(this);
  if (dir === undefined) dir = new Vector3(0, 0, 1);
  if (origin === undefined) origin = new Vector3(0, 0, 0);
  if (length === undefined) length = 1;
  if (color === undefined) color = 0xffff00;
  if (headLength === undefined) headLength = 0.2 * length;
  if (headWidth === undefined) headWidth = 0.2 * headLength;

  if (_lineGeometry === undefined) {
    _lineGeometry = new BufferGeometry();

    _lineGeometry.addAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

    _coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);

    _coneGeometry.translate(0, -0.5, 0);
  }

  this.position.copy(origin);
  this.line = new Line(_lineGeometry, new LineBasicMaterial({
    color: color
  }));
  this.line.matrixAutoUpdate = false;
  this.add(this.line);
  this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
    color: color
  }));
  this.cone.matrixAutoUpdate = false;
  this.add(this.cone);
  this.setDirection(dir);
  this.setLength(length, headLength, headWidth);
}

ArrowHelper.prototype = Object.create(Object3D.prototype);
ArrowHelper.prototype.constructor = ArrowHelper;

ArrowHelper.prototype.setDirection = function (dir) {
  // dir is assumed to be normalized
  if (dir.y > 0.99999) {
    this.quaternion.set(0, 0, 0, 1);
  } else if (dir.y < -0.99999) {
    this.quaternion.set(1, 0, 0, 0);
  } else {
    _axis.set(dir.z, 0, -dir.x).normalize();

    var radians = Math.acos(dir.y);
    this.quaternion.setFromAxisAngle(_axis, radians);
  }
};

ArrowHelper.prototype.setLength = function (length, headLength, headWidth) {
  if (headLength === undefined) headLength = 0.2 * length;
  if (headWidth === undefined) headWidth = 0.2 * headLength;
  this.line.scale.set(1, Math.max(0, length - headLength), 1);
  this.line.updateMatrix();
  this.cone.scale.set(headWidth, headLength, headWidth);
  this.cone.position.y = length;
  this.cone.updateMatrix();
};

ArrowHelper.prototype.setColor = function (color) {
  this.line.material.color.set(color);
  this.cone.material.color.set(color);
};

ArrowHelper.prototype.copy = function (source) {
  Object3D.prototype.copy.call(this, source, false);
  this.line.copy(source.line);
  this.cone.copy(source.cone);
  return this;
};

ArrowHelper.prototype.clone = function () {
  return new this.constructor().copy(this);
};
/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */


function AxesHelper(size) {
  size = size || 1;
  var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
  var colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
  var geometry = new BufferGeometry();
  geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
  geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
  var material = new LineBasicMaterial({
    vertexColors: VertexColors
  });
  LineSegments.call(this, geometry, material);
}

AxesHelper.prototype = Object.create(LineSegments.prototype);
AxesHelper.prototype.constructor = AxesHelper;
/**
 * @author mrdoob / http://mrdoob.com/
 */

function Face4(a, b, c, d, normal, color, materialIndex) {
  console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
  return new Face3(a, b, c, normal, color, materialIndex);
}

var LineStrip = 0;
exports.LineStrip = LineStrip;
var LinePieces = 1;
exports.LinePieces = LinePieces;

function MeshFaceMaterial(materials) {
  console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
  return materials;
}

function MultiMaterial(materials) {
  if (materials === undefined) materials = [];
  console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
  materials.isMultiMaterial = true;
  materials.materials = materials;

  materials.clone = function () {
    return materials.slice();
  };

  return materials;
}

function PointCloud(geometry, material) {
  console.warn('THREE.PointCloud has been renamed to THREE.Points.');
  return new Points(geometry, material);
}

function Particle(material) {
  console.warn('THREE.Particle has been renamed to THREE.Sprite.');
  return new Sprite(material);
}

function ParticleSystem(geometry, material) {
  console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
  return new Points(geometry, material);
}

function PointCloudMaterial(parameters) {
  console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}

function ParticleBasicMaterial(parameters) {
  console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}

function ParticleSystemMaterial(parameters) {
  console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}

function Vertex(x, y, z) {
  console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
  return new Vector3(x, y, z);
} //


function DynamicBufferAttribute(array, itemSize) {
  console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');
  return new BufferAttribute(array, itemSize).setDynamic(true);
}

function Int8Attribute(array, itemSize) {
  console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
  return new Int8BufferAttribute(array, itemSize);
}

function Uint8Attribute(array, itemSize) {
  console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
  return new Uint8BufferAttribute(array, itemSize);
}

function Uint8ClampedAttribute(array, itemSize) {
  console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
  return new Uint8ClampedBufferAttribute(array, itemSize);
}

function Int16Attribute(array, itemSize) {
  console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
  return new Int16BufferAttribute(array, itemSize);
}

function Uint16Attribute(array, itemSize) {
  console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
  return new Uint16BufferAttribute(array, itemSize);
}

function Int32Attribute(array, itemSize) {
  console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
  return new Int32BufferAttribute(array, itemSize);
}

function Uint32Attribute(array, itemSize) {
  console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
  return new Uint32BufferAttribute(array, itemSize);
}

function Float32Attribute(array, itemSize) {
  console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
  return new Float32BufferAttribute(array, itemSize);
}

function Float64Attribute(array, itemSize) {
  console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
  return new Float64BufferAttribute(array, itemSize);
} //


Curve.create = function (construct, getPoint) {
  console.log('THREE.Curve.create() has been deprecated');
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
}; //


Object.assign(CurvePath.prototype, {
  createPointsGeometry: function (divisions) {
    console.warn('THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.'); // generate geometry from path points (for Line or Points objects)

    var pts = this.getPoints(divisions);
    return this.createGeometry(pts);
  },
  createSpacedPointsGeometry: function (divisions) {
    console.warn('THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.'); // generate geometry from equidistant sampling along the path

    var pts = this.getSpacedPoints(divisions);
    return this.createGeometry(pts);
  },
  createGeometry: function (points) {
    console.warn('THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
    var geometry = new Geometry();

    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
    }

    return geometry;
  }
}); //

Object.assign(Path.prototype, {
  fromPoints: function (points) {
    console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
    this.setFromPoints(points);
  }
}); //

function ClosedSplineCurve3(points) {
  console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
  CatmullRomCurve3.call(this, points);
  this.type = 'catmullrom';
  this.closed = true;
}

ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype); //

function SplineCurve3(points) {
  console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
  CatmullRomCurve3.call(this, points);
  this.type = 'catmullrom';
}

SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype); //

function Spline(points) {
  console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');
  CatmullRomCurve3.call(this, points);
  this.type = 'catmullrom';
}

Spline.prototype = Object.create(CatmullRomCurve3.prototype);
Object.assign(Spline.prototype, {
  initFromArray: function ()
  /* a */
  {
    console.error('THREE.Spline: .initFromArray() has been removed.');
  },
  getControlPointsArray: function ()
  /* optionalTarget */
  {
    console.error('THREE.Spline: .getControlPointsArray() has been removed.');
  },
  reparametrizeByArcLength: function ()
  /* samplingCoef */
  {
    console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
  }
}); //

function AxisHelper(size) {
  console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
  return new AxesHelper(size);
}

function BoundingBoxHelper(object, color) {
  console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
  return new BoxHelper(object, color);
}

function EdgesHelper(object, hex) {
  console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
  return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
    color: hex !== undefined ? hex : 0xffffff
  }));
}

GridHelper.prototype.setColors = function () {
  console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
};

SkeletonHelper.prototype.update = function () {
  console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
};

function WireframeHelper(object, hex) {
  console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
  return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
    color: hex !== undefined ? hex : 0xffffff
  }));
} //


Object.assign(Loader.prototype, {
  extractUrlBase: function (url) {
    console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
    return LoaderUtils.extractUrlBase(url);
  }
});

function XHRLoader(manager) {
  console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
  return new FileLoader(manager);
}

function BinaryTextureLoader(manager) {
  console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
  return new DataTextureLoader(manager);
}

Object.assign(ObjectLoader.prototype, {
  setTexturePath: function (value) {
    console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
    return this.setResourcePath(value);
  }
}); //

Object.assign(Box2.prototype, {
  center: function (optionalTarget) {
    console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
  },
  empty: function () {
    console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
  },
  isIntersectionBox: function (box) {
    console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
  },
  size: function (optionalTarget) {
    console.warn('THREE.Box2: .size() has been renamed to .getSize().');
    return this.getSize(optionalTarget);
  }
});
Object.assign(Box3.prototype, {
  center: function (optionalTarget) {
    console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
  },
  empty: function () {
    console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
  },
  isIntersectionBox: function (box) {
    console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
  },
  isIntersectionSphere: function (sphere) {
    console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
    return this.intersectsSphere(sphere);
  },
  size: function (optionalTarget) {
    console.warn('THREE.Box3: .size() has been renamed to .getSize().');
    return this.getSize(optionalTarget);
  }
});

Line3.prototype.center = function (optionalTarget) {
  console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
  return this.getCenter(optionalTarget);
};

Object.assign(_Math, {
  random16: function () {
    console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');
    return Math.random();
  },
  nearestPowerOfTwo: function (value) {
    console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');
    return _Math.floorPowerOfTwo(value);
  },
  nextPowerOfTwo: function (value) {
    console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');
    return _Math.ceilPowerOfTwo(value);
  }
});
Object.assign(Matrix3.prototype, {
  flattenToArrayOffset: function (array, offset) {
    console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  },
  multiplyVector3: function (vector) {
    console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
    return vector.applyMatrix3(this);
  },
  multiplyVector3Array: function ()
  /* a */
  {
    console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
  },
  applyToBuffer: function (buffer
  /*, offset, length */
  ) {
    console.warn('THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');
    return this.applyToBufferAttribute(buffer);
  },
  applyToVector3Array: function ()
  /* array, offset, length */
  {
    console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
  }
});
Object.assign(Matrix4.prototype, {
  extractPosition: function (m) {
    console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
    return this.copyPosition(m);
  },
  flattenToArrayOffset: function (array, offset) {
    console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  },
  getPosition: function () {
    console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
    return new Vector3().setFromMatrixColumn(this, 3);
  },
  setRotationFromQuaternion: function (q) {
    console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
    return this.makeRotationFromQuaternion(q);
  },
  multiplyToArray: function () {
    console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
  },
  multiplyVector3: function (vector) {
    console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  multiplyVector4: function (vector) {
    console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  multiplyVector3Array: function ()
  /* a */
  {
    console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
  },
  rotateAxis: function (v) {
    console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
    v.transformDirection(this);
  },
  crossVector: function (vector) {
    console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  translate: function () {
    console.error('THREE.Matrix4: .translate() has been removed.');
  },
  rotateX: function () {
    console.error('THREE.Matrix4: .rotateX() has been removed.');
  },
  rotateY: function () {
    console.error('THREE.Matrix4: .rotateY() has been removed.');
  },
  rotateZ: function () {
    console.error('THREE.Matrix4: .rotateZ() has been removed.');
  },
  rotateByAxis: function () {
    console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
  },
  applyToBuffer: function (buffer
  /*, offset, length */
  ) {
    console.warn('THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');
    return this.applyToBufferAttribute(buffer);
  },
  applyToVector3Array: function ()
  /* array, offset, length */
  {
    console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
  },
  makeFrustum: function (left, right, bottom, top, near, far) {
    console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
    return this.makePerspective(left, right, top, bottom, near, far);
  }
});

Plane.prototype.isIntersectionLine = function (line) {
  console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
  return this.intersectsLine(line);
};

Quaternion.prototype.multiplyVector3 = function (vector) {
  console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
  return vector.applyQuaternion(this);
};

Object.assign(Ray.prototype, {
  isIntersectionBox: function (box) {
    console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
  },
  isIntersectionPlane: function (plane) {
    console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
    return this.intersectsPlane(plane);
  },
  isIntersectionSphere: function (sphere) {
    console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
    return this.intersectsSphere(sphere);
  }
});
Object.assign(Triangle.prototype, {
  area: function () {
    console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
    return this.getArea();
  },
  barycoordFromPoint: function (point, target) {
    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
    return this.getBarycoord(point, target);
  },
  midpoint: function (target) {
    console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
    return this.getMidpoint(target);
  },
  normal: function (target) {
    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
    return this.getNormal(target);
  },
  plane: function (target) {
    console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
    return this.getPlane(target);
  }
});
Object.assign(Triangle, {
  barycoordFromPoint: function (point, a, b, c, target) {
    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
    return Triangle.getBarycoord(point, a, b, c, target);
  },
  normal: function (a, b, c, target) {
    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
    return Triangle.getNormal(a, b, c, target);
  }
});
Object.assign(Shape.prototype, {
  extractAllPoints: function (divisions) {
    console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
    return this.extractPoints(divisions);
  },
  extrude: function (options) {
    console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
    return new ExtrudeGeometry(this, options);
  },
  makeGeometry: function (options) {
    console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
    return new ShapeGeometry(this, options);
  }
});
Object.assign(Vector2.prototype, {
  fromAttribute: function (attribute, index, offset) {
    console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
  },
  distanceToManhattan: function (v) {
    console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
    return this.manhattanDistanceTo(v);
  },
  lengthManhattan: function () {
    console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
  }
});
Object.assign(Vector3.prototype, {
  setEulerFromRotationMatrix: function () {
    console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
  },
  setEulerFromQuaternion: function () {
    console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
  },
  getPositionFromMatrix: function (m) {
    console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
    return this.setFromMatrixPosition(m);
  },
  getScaleFromMatrix: function (m) {
    console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
    return this.setFromMatrixScale(m);
  },
  getColumnFromMatrix: function (index, matrix) {
    console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
    return this.setFromMatrixColumn(matrix, index);
  },
  applyProjection: function (m) {
    console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
    return this.applyMatrix4(m);
  },
  fromAttribute: function (attribute, index, offset) {
    console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
  },
  distanceToManhattan: function (v) {
    console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
    return this.manhattanDistanceTo(v);
  },
  lengthManhattan: function () {
    console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
  }
});
Object.assign(Vector4.prototype, {
  fromAttribute: function (attribute, index, offset) {
    console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
  },
  lengthManhattan: function () {
    console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
  }
}); //

Object.assign(Geometry.prototype, {
  computeTangents: function () {
    console.error('THREE.Geometry: .computeTangents() has been removed.');
  },
  computeLineDistances: function () {
    console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');
  }
});
Object.assign(Object3D.prototype, {
  getChildByName: function (name) {
    console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
    return this.getObjectByName(name);
  },
  renderDepth: function () {
    console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
  },
  translate: function (distance, axis) {
    console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
    return this.translateOnAxis(axis, distance);
  },
  getWorldRotation: function () {
    console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
  }
});
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function () {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      return this.rotation.order;
    },
    set: function (value) {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function () {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    },
    set: function () {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    }
  }
});
Object.defineProperties(LOD.prototype, {
  objects: {
    get: function () {
      console.warn('THREE.LOD: .objects has been renamed to .levels.');
      return this.levels;
    }
  }
});
Object.defineProperty(Skeleton.prototype, 'useVertexTexture', {
  get: function () {
    console.warn('THREE.Skeleton: useVertexTexture has been removed.');
  },
  set: function () {
    console.warn('THREE.Skeleton: useVertexTexture has been removed.');
  }
});

SkinnedMesh.prototype.initBones = function () {
  console.error('THREE.SkinnedMesh: initBones() has been removed.');
};

Object.defineProperty(Curve.prototype, '__arcLengthDivisions', {
  get: function () {
    console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
    return this.arcLengthDivisions;
  },
  set: function (value) {
    console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
    this.arcLengthDivisions = value;
  }
}); //

PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. " + "Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== undefined) this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
}; //


Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function () {
      console.warn('THREE.Light: .onlyShadow has been removed.');
    }
  },
  shadowCameraFov: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function () {
      console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
    }
  },
  shadowBias: {
    set: function (value) {
      console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function () {
      console.warn('THREE.Light: .shadowDarkness has been removed.');
    }
  },
  shadowMapWidth: {
    set: function (value) {
      console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function (value) {
      console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
      this.shadow.mapSize.height = value;
    }
  }
}); //

Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function () {
      console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
      return this.array.length;
    }
  },
  copyIndicesArray: function ()
  /* indices */
  {
    console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
  }
});
Object.assign(BufferGeometry.prototype, {
  addIndex: function (index) {
    console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
    this.setIndex(index);
  },
  addDrawCall: function (start, count, indexOffset) {
    if (indexOffset !== undefined) {
      console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
    }

    console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
    this.addGroup(start, count);
  },
  clearDrawCalls: function () {
    console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
    this.clearGroups();
  },
  computeTangents: function () {
    console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
  },
  computeOffsets: function () {
    console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
  }
});
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function () {
      console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
      return this.groups;
    }
  },
  offsets: {
    get: function () {
      console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
      return this.groups;
    }
  }
}); //

Object.assign(ExtrudeBufferGeometry.prototype, {
  getArrays: function () {
    console.error('THREE.ExtrudeBufferGeometry: .getArrays() has been removed.');
  },
  addShapeList: function () {
    console.error('THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.');
  },
  addShape: function () {
    console.error('THREE.ExtrudeBufferGeometry: .addShape() has been removed.');
  }
}); //

Object.defineProperties(Uniform.prototype, {
  dynamic: {
    set: function () {
      console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
    }
  },
  onUpdate: {
    value: function () {
      console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
      return this;
    }
  }
}); //

Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function () {
      console.warn('THREE.Material: .wrapAround has been removed.');
    },
    set: function () {
      console.warn('THREE.Material: .wrapAround has been removed.');
    }
  },
  overdraw: {
    get: function () {
      console.warn('THREE.Material: .overdraw has been removed.');
    },
    set: function () {
      console.warn('THREE.Material: .overdraw has been removed.');
    }
  },
  wrapRGB: {
    get: function () {
      console.warn('THREE.Material: .wrapRGB has been removed.');
      return new Color();
    }
  },
  shading: {
    get: function () {
      console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
    },
    set: function (value) {
      console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
      this.flatShading = value === FlatShading;
    }
  }
});
Object.defineProperties(MeshPhongMaterial.prototype, {
  metal: {
    get: function () {
      console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
      return false;
    },
    set: function () {
      console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function () {
      console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
      return this.extensions.derivatives;
    },
    set: function (value) {
      console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
      this.extensions.derivatives = value;
    }
  }
}); //

Object.assign(WebGLRenderer.prototype, {
  clearTarget: function (renderTarget, color, depth, stencil) {
    console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
    this.setRenderTarget(renderTarget);
    this.clear(color, depth, stencil);
  },
  animate: function (callback) {
    console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
    this.setAnimationLoop(callback);
  },
  getCurrentRenderTarget: function () {
    console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
    return this.getRenderTarget();
  },
  getMaxAnisotropy: function () {
    console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
    return this.capabilities.getMaxAnisotropy();
  },
  getPrecision: function () {
    console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
    return this.capabilities.precision;
  },
  resetGLState: function () {
    console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
    return this.state.reset();
  },
  supportsFloatTextures: function () {
    console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
    return this.extensions.get('OES_texture_float');
  },
  supportsHalfFloatTextures: function () {
    console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
    return this.extensions.get('OES_texture_half_float');
  },
  supportsStandardDerivatives: function () {
    console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
    return this.extensions.get('OES_standard_derivatives');
  },
  supportsCompressedTextureS3TC: function () {
    console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
    return this.extensions.get('WEBGL_compressed_texture_s3tc');
  },
  supportsCompressedTexturePVRTC: function () {
    console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
    return this.extensions.get('WEBGL_compressed_texture_pvrtc');
  },
  supportsBlendMinMax: function () {
    console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
    return this.extensions.get('EXT_blend_minmax');
  },
  supportsVertexTextures: function () {
    console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
    return this.capabilities.vertexTextures;
  },
  supportsInstancedArrays: function () {
    console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
    return this.extensions.get('ANGLE_instanced_arrays');
  },
  enableScissorTest: function (boolean) {
    console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
    this.setScissorTest(boolean);
  },
  initMaterial: function () {
    console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
  },
  addPrePlugin: function () {
    console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
  },
  addPostPlugin: function () {
    console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
  },
  updateShadowMap: function () {
    console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
  },
  setFaceCulling: function () {
    console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
  },
  allocTextureUnit: function () {
    console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
  },
  setTexture: function () {
    console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
  },
  setTexture2D: function () {
    console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
  },
  setTextureCube: function () {
    console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
  },
  getActiveMipMapLevel: function () {
    console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
    return this.getActiveMipmapLevel();
  }
});
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function () {
      return this.shadowMap.enabled;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function () {
      return this.shadowMap.type;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function ()
    /* value */
    {
      console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
    }
  },
  context: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
      return this.getContext();
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function ()
    /* cullFace */
    {
      console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
    }
  },
  renderReverseSided: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
    }
  },
  renderSingleSided: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
    }
  }
}); //

Object.defineProperties(WebGLRenderTargetCube.prototype, {
  activeCubeFace: {
    set: function ()
    /* value */
    {
      console.warn('THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().');
    }
  },
  activeMipMapLevel: {
    set: function ()
    /* value */
    {
      console.warn('THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().');
    }
  }
}); //

Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      return this.texture.wrapS;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      return this.texture.wrapT;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      return this.texture.magFilter;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      return this.texture.minFilter;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      return this.texture.anisotropy;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      return this.texture.offset;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      return this.texture.repeat;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      this.texture.repeat = value;
    }
  },
  format: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      return this.texture.format;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      this.texture.format = value;
    }
  },
  type: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      return this.texture.type;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      return this.texture.generateMipmaps;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      this.texture.generateMipmaps = value;
    }
  }
}); //

Object.defineProperties(WebVRManager.prototype, {
  standing: {
    set: function ()
    /* value */
    {
      console.warn('THREE.WebVRManager: .standing has been removed.');
    }
  },
  userHeight: {
    set: function ()
    /* value */
    {
      console.warn('THREE.WebVRManager: .userHeight has been removed.');
    }
  }
}); //

Audio.prototype.load = function (file) {
  console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
  var scope = this;
  var audioLoader = new AudioLoader();
  audioLoader.load(file, function (buffer) {
    scope.setBuffer(buffer);
  });
  return this;
};

AudioAnalyser.prototype.getData = function () {
  console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
  return this.getFrequencyData();
}; //


CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
  console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
  return this.update(renderer, scene);
}; //


var GeometryUtils = {
  merge: function (geometry1, geometry2, materialIndexOffset) {
    console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
    var matrix;

    if (geometry2.isMesh) {
      geometry2.matrixAutoUpdate && geometry2.updateMatrix();
      matrix = geometry2.matrix;
      geometry2 = geometry2.geometry;
    }

    geometry1.merge(geometry2, matrix, materialIndexOffset);
  },
  center: function (geometry) {
    console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
    return geometry.center();
  }
};
exports.GeometryUtils = GeometryUtils;
ImageUtils.crossOrigin = undefined;

ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
  console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
  var loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  var texture = loader.load(url, onLoad, undefined, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};

ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {
  console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
  var loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  var texture = loader.load(urls, onLoad, undefined, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};

ImageUtils.loadCompressedTexture = function () {
  console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
};

ImageUtils.loadCompressedTextureCube = function () {
  console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
}; //


function CanvasRenderer() {
  console.error('THREE.CanvasRenderer has been removed');
} //


function JSONLoader() {
  console.error('THREE.JSONLoader has been removed.');
} //


var SceneUtils = {
  createMultiMaterialObject: function ()
  /* geometry, materials */
  {
    console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
  },
  detach: function ()
  /* child, parent, scene */
  {
    console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
  },
  attach: function ()
  /* child, scene, parent */
  {
    console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
  }
}; //

exports.SceneUtils = SceneUtils;

function LensFlare() {
  console.error('THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js');
}
},{}],"../node_modules/animejs/lib/anime.es.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * anime.js v3.1.0
 * (c) 2019 Julian Garnier
 * Released under the MIT license
 * animejs.com
 */
// Defaults
var defaultInstanceSettings = {
  update: null,
  begin: null,
  loopBegin: null,
  changeBegin: null,
  change: null,
  changeComplete: null,
  loopComplete: null,
  complete: null,
  loop: 1,
  direction: 'normal',
  autoplay: true,
  timelineOffset: 0
};
var defaultTweenSettings = {
  duration: 1000,
  delay: 0,
  endDelay: 0,
  easing: 'easeOutElastic(1, .5)',
  round: 0
};
var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective']; // Caching

var cache = {
  CSS: {},
  springs: {}
}; // Utils

function minMax(val, min, max) {
  return Math.min(Math.max(val, min), max);
}

function stringContains(str, text) {
  return str.indexOf(text) > -1;
}

function applyArguments(func, args) {
  return func.apply(null, args);
}

var is = {
  arr: function (a) {
    return Array.isArray(a);
  },
  obj: function (a) {
    return stringContains(Object.prototype.toString.call(a), 'Object');
  },
  pth: function (a) {
    return is.obj(a) && a.hasOwnProperty('totalLength');
  },
  svg: function (a) {
    return a instanceof SVGElement;
  },
  inp: function (a) {
    return a instanceof HTMLInputElement;
  },
  dom: function (a) {
    return a.nodeType || is.svg(a);
  },
  str: function (a) {
    return typeof a === 'string';
  },
  fnc: function (a) {
    return typeof a === 'function';
  },
  und: function (a) {
    return typeof a === 'undefined';
  },
  hex: function (a) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a);
  },
  rgb: function (a) {
    return /^rgb/.test(a);
  },
  hsl: function (a) {
    return /^hsl/.test(a);
  },
  col: function (a) {
    return is.hex(a) || is.rgb(a) || is.hsl(a);
  },
  key: function (a) {
    return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes';
  }
}; // Easings

function parseEasingParameters(string) {
  var match = /\(([^)]+)\)/.exec(string);
  return match ? match[1].split(',').map(function (p) {
    return parseFloat(p);
  }) : [];
} // Spring solver inspired by Webkit Copyright © 2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js


function spring(string, duration) {
  var params = parseEasingParameters(string);
  var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
  var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
  var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
  var velocity = minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

  function solver(t) {
    var progress = duration ? duration * t / 1000 : t;

    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a + b * progress) * Math.exp(-progress * w0);
    }

    if (t === 0 || t === 1) {
      return t;
    }

    return 1 - progress;
  }

  function getDuration() {
    var cached = cache.springs[string];

    if (cached) {
      return cached;
    }

    var frame = 1 / 6;
    var elapsed = 0;
    var rest = 0;

    while (true) {
      elapsed += frame;

      if (solver(elapsed) === 1) {
        rest++;

        if (rest >= 16) {
          break;
        }
      } else {
        rest = 0;
      }
    }

    var duration = elapsed * frame * 1000;
    cache.springs[string] = duration;
    return duration;
  }

  return duration ? solver : getDuration;
} // Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function


function steps(steps) {
  if (steps === void 0) steps = 10;
  return function (t) {
    return Math.round(t * steps) * (1 / steps);
  };
} // BezierEasing https://github.com/gre/bezier-easing


var bezier = function () {
  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  }

  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX,
        currentT,
        i = 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;

      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);

    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < 4; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  function bezier(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
      return;
    }

    var sampleValues = new Float32Array(kSplineTableSize);

    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function getTForX(aX) {
      var intervalStart = 0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample;
      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= 0.001) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    }

    return function (x) {
      if (mX1 === mY1 && mX2 === mY2) {
        return x;
      }

      if (x === 0 || x === 1) {
        return x;
      }

      return calcBezier(getTForX(x), mY1, mY2);
    };
  }

  return bezier;
}();

var penner = function () {
  // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)
  var eases = {
    linear: function () {
      return function (t) {
        return t;
      };
    }
  };
  var functionEasings = {
    Sine: function () {
      return function (t) {
        return 1 - Math.cos(t * Math.PI / 2);
      };
    },
    Circ: function () {
      return function (t) {
        return 1 - Math.sqrt(1 - t * t);
      };
    },
    Back: function () {
      return function (t) {
        return t * t * (3 * t - 2);
      };
    },
    Bounce: function () {
      return function (t) {
        var pow2,
            b = 4;

        while (t < ((pow2 = Math.pow(2, --b)) - 1) / 11) {}

        return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
      };
    },
    Elastic: function (amplitude, period) {
      if (amplitude === void 0) amplitude = 1;
      if (period === void 0) period = .5;
      var a = minMax(amplitude, 1, 10);
      var p = minMax(period, .1, 2);
      return function (t) {
        return t === 0 || t === 1 ? t : -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);
      };
    }
  };
  var baseEasings = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];
  baseEasings.forEach(function (name, i) {
    functionEasings[name] = function () {
      return function (t) {
        return Math.pow(t, i + 2);
      };
    };
  });
  Object.keys(functionEasings).forEach(function (name) {
    var easeIn = functionEasings[name];
    eases['easeIn' + name] = easeIn;

    eases['easeOut' + name] = function (a, b) {
      return function (t) {
        return 1 - easeIn(a, b)(1 - t);
      };
    };

    eases['easeInOut' + name] = function (a, b) {
      return function (t) {
        return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 1 - easeIn(a, b)(t * -2 + 2) / 2;
      };
    };
  });
  return eases;
}();

function parseEasings(easing, duration) {
  if (is.fnc(easing)) {
    return easing;
  }

  var name = easing.split('(')[0];
  var ease = penner[name];
  var args = parseEasingParameters(easing);

  switch (name) {
    case 'spring':
      return spring(easing, duration);

    case 'cubicBezier':
      return applyArguments(bezier, args);

    case 'steps':
      return applyArguments(steps, args);

    default:
      return applyArguments(ease, args);
  }
} // Strings


function selectString(str) {
  try {
    var nodes = document.querySelectorAll(str);
    return nodes;
  } catch (e) {
    return;
  }
} // Arrays


function filterArray(arr, callback) {
  var len = arr.length;
  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
  var result = [];

  for (var i = 0; i < len; i++) {
    if (i in arr) {
      var val = arr[i];

      if (callback.call(thisArg, val, i, arr)) {
        result.push(val);
      }
    }
  }

  return result;
}

function flattenArray(arr) {
  return arr.reduce(function (a, b) {
    return a.concat(is.arr(b) ? flattenArray(b) : b);
  }, []);
}

function toArray(o) {
  if (is.arr(o)) {
    return o;
  }

  if (is.str(o)) {
    o = selectString(o) || o;
  }

  if (o instanceof NodeList || o instanceof HTMLCollection) {
    return [].slice.call(o);
  }

  return [o];
}

function arrayContains(arr, val) {
  return arr.some(function (a) {
    return a === val;
  });
} // Objects


function cloneObject(o) {
  var clone = {};

  for (var p in o) {
    clone[p] = o[p];
  }

  return clone;
}

function replaceObjectProps(o1, o2) {
  var o = cloneObject(o1);

  for (var p in o1) {
    o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p];
  }

  return o;
}

function mergeObjects(o1, o2) {
  var o = cloneObject(o1);

  for (var p in o2) {
    o[p] = is.und(o1[p]) ? o2[p] : o1[p];
  }

  return o;
} // Colors


function rgbToRgba(rgbValue) {
  var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
  return rgb ? "rgba(" + rgb[1] + ",1)" : rgbValue;
}

function hexToRgba(hexValue) {
  var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  var hex = hexValue.replace(rgx, function (m, r, g, b) {
    return r + r + g + g + b + b;
  });
  var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  var r = parseInt(rgb[1], 16);
  var g = parseInt(rgb[2], 16);
  var b = parseInt(rgb[3], 16);
  return "rgba(" + r + "," + g + "," + b + ",1)";
}

function hslToRgba(hslValue) {
  var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
  var h = parseInt(hsl[1], 10) / 360;
  var s = parseInt(hsl[2], 10) / 100;
  var l = parseInt(hsl[3], 10) / 100;
  var a = hsl[4] || 1;

  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }

    if (t > 1) {
      t -= 1;
    }

    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }

    if (t < 1 / 2) {
      return q;
    }

    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }

    return p;
  }

  var r, g, b;

  if (s == 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }

  return "rgba(" + r * 255 + "," + g * 255 + "," + b * 255 + "," + a + ")";
}

function colorToRgb(val) {
  if (is.rgb(val)) {
    return rgbToRgba(val);
  }

  if (is.hex(val)) {
    return hexToRgba(val);
  }

  if (is.hsl(val)) {
    return hslToRgba(val);
  }
} // Units


function getUnit(val) {
  var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);

  if (split) {
    return split[1];
  }
}

function getTransformUnit(propName) {
  if (stringContains(propName, 'translate') || propName === 'perspective') {
    return 'px';
  }

  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) {
    return 'deg';
  }
} // Values


function getFunctionValue(val, animatable) {
  if (!is.fnc(val)) {
    return val;
  }

  return val(animatable.target, animatable.id, animatable.total);
}

function getAttribute(el, prop) {
  return el.getAttribute(prop);
}

function convertPxToUnit(el, value, unit) {
  var valueUnit = getUnit(value);

  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) {
    return value;
  }

  var cached = cache.CSS[value + unit];

  if (!is.und(cached)) {
    return cached;
  }

  var baseline = 100;
  var tempEl = document.createElement(el.tagName);
  var parentEl = el.parentNode && el.parentNode !== document ? el.parentNode : document.body;
  parentEl.appendChild(tempEl);
  tempEl.style.position = 'absolute';
  tempEl.style.width = baseline + unit;
  var factor = baseline / tempEl.offsetWidth;
  parentEl.removeChild(tempEl);
  var convertedUnit = factor * parseFloat(value);
  cache.CSS[value + unit] = convertedUnit;
  return convertedUnit;
}

function getCSSValue(el, prop, unit) {
  if (prop in el.style) {
    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
    return unit ? convertPxToUnit(el, value, unit) : value;
  }
}

function getAnimationType(el, prop) {
  if (is.dom(el) && !is.inp(el) && (getAttribute(el, prop) || is.svg(el) && el[prop])) {
    return 'attribute';
  }

  if (is.dom(el) && arrayContains(validTransforms, prop)) {
    return 'transform';
  }

  if (is.dom(el) && prop !== 'transform' && getCSSValue(el, prop)) {
    return 'css';
  }

  if (el[prop] != null) {
    return 'object';
  }
}

function getElementTransforms(el) {
  if (!is.dom(el)) {
    return;
  }

  var str = el.style.transform || '';
  var reg = /(\w+)\(([^)]*)\)/g;
  var transforms = new Map();
  var m;

  while (m = reg.exec(str)) {
    transforms.set(m[1], m[2]);
  }

  return transforms;
}

function getTransformValue(el, propName, animatable, unit) {
  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
  var value = getElementTransforms(el).get(propName) || defaultVal;

  if (animatable) {
    animatable.transforms.list.set(propName, value);
    animatable.transforms['last'] = propName;
  }

  return unit ? convertPxToUnit(el, value, unit) : value;
}

function getOriginalTargetValue(target, propName, unit, animatable) {
  switch (getAnimationType(target, propName)) {
    case 'transform':
      return getTransformValue(target, propName, animatable, unit);

    case 'css':
      return getCSSValue(target, propName, unit);

    case 'attribute':
      return getAttribute(target, propName);

    default:
      return target[propName] || 0;
  }
}

function getRelativeValue(to, from) {
  var operator = /^(\*=|\+=|-=)/.exec(to);

  if (!operator) {
    return to;
  }

  var u = getUnit(to) || 0;
  var x = parseFloat(from);
  var y = parseFloat(to.replace(operator[0], ''));

  switch (operator[0][0]) {
    case '+':
      return x + y + u;

    case '-':
      return x - y + u;

    case '*':
      return x * y + u;
  }
}

function validateValue(val, unit) {
  if (is.col(val)) {
    return colorToRgb(val);
  }

  if (/\s/g.test(val)) {
    return val;
  }

  var originalUnit = getUnit(val);
  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;

  if (unit) {
    return unitLess + unit;
  }

  return unitLess;
} // getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744


function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function getCircleLength(el) {
  return Math.PI * 2 * getAttribute(el, 'r');
}

function getRectLength(el) {
  return getAttribute(el, 'width') * 2 + getAttribute(el, 'height') * 2;
}

function getLineLength(el) {
  return getDistance({
    x: getAttribute(el, 'x1'),
    y: getAttribute(el, 'y1')
  }, {
    x: getAttribute(el, 'x2'),
    y: getAttribute(el, 'y2')
  });
}

function getPolylineLength(el) {
  var points = el.points;
  var totalLength = 0;
  var previousPos;

  for (var i = 0; i < points.numberOfItems; i++) {
    var currentPos = points.getItem(i);

    if (i > 0) {
      totalLength += getDistance(previousPos, currentPos);
    }

    previousPos = currentPos;
  }

  return totalLength;
}

function getPolygonLength(el) {
  var points = el.points;
  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
} // Path animation


function getTotalLength(el) {
  if (el.getTotalLength) {
    return el.getTotalLength();
  }

  switch (el.tagName.toLowerCase()) {
    case 'circle':
      return getCircleLength(el);

    case 'rect':
      return getRectLength(el);

    case 'line':
      return getLineLength(el);

    case 'polyline':
      return getPolylineLength(el);

    case 'polygon':
      return getPolygonLength(el);
  }
}

function setDashoffset(el) {
  var pathLength = getTotalLength(el);
  el.setAttribute('stroke-dasharray', pathLength);
  return pathLength;
} // Motion path


function getParentSvgEl(el) {
  var parentEl = el.parentNode;

  while (is.svg(parentEl)) {
    if (!is.svg(parentEl.parentNode)) {
      break;
    }

    parentEl = parentEl.parentNode;
  }

  return parentEl;
}

function getParentSvg(pathEl, svgData) {
  var svg = svgData || {};
  var parentSvgEl = svg.el || getParentSvgEl(pathEl);
  var rect = parentSvgEl.getBoundingClientRect();
  var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
  var width = rect.width;
  var height = rect.height;
  var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
  return {
    el: parentSvgEl,
    viewBox: viewBox,
    x: viewBox[0] / 1,
    y: viewBox[1] / 1,
    w: width / viewBox[2],
    h: height / viewBox[3]
  };
}

function getPath(path, percent) {
  var pathEl = is.str(path) ? selectString(path)[0] : path;
  var p = percent || 100;
  return function (property) {
    return {
      property: property,
      el: pathEl,
      svg: getParentSvg(pathEl),
      totalLength: getTotalLength(pathEl) * (p / 100)
    };
  };
}

function getPathProgress(path, progress) {
  function point(offset) {
    if (offset === void 0) offset = 0;
    var l = progress + offset >= 1 ? progress + offset : 0;
    return path.el.getPointAtLength(l);
  }

  var svg = getParentSvg(path.el, path.svg);
  var p = point();
  var p0 = point(-1);
  var p1 = point(+1);

  switch (path.property) {
    case 'x':
      return (p.x - svg.x) * svg.w;

    case 'y':
      return (p.y - svg.y) * svg.h;

    case 'angle':
      return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
  }
} // Decompose value


function decomposeValue(val, unit) {
  // const rgx = /-?\d*\.?\d+/g; // handles basic numbers
  // const rgx = /[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation

  var value = validateValue(is.pth(val) ? val.totalLength : val, unit) + '';
  return {
    original: value,
    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
    strings: is.str(val) || unit ? value.split(rgx) : []
  };
} // Animatables


function parseTargets(targets) {
  var targetsArray = targets ? flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets)) : [];
  return filterArray(targetsArray, function (item, pos, self) {
    return self.indexOf(item) === pos;
  });
}

function getAnimatables(targets) {
  var parsed = parseTargets(targets);
  return parsed.map(function (t, i) {
    return {
      target: t,
      id: i,
      total: parsed.length,
      transforms: {
        list: getElementTransforms(t)
      }
    };
  });
} // Properties


function normalizePropertyTweens(prop, tweenSettings) {
  var settings = cloneObject(tweenSettings); // Override duration if easing is a spring

  if (/^spring/.test(settings.easing)) {
    settings.duration = spring(settings.easing);
  }

  if (is.arr(prop)) {
    var l = prop.length;
    var isFromTo = l === 2 && !is.obj(prop[0]);

    if (!isFromTo) {
      // Duration divided by the number of tweens
      if (!is.fnc(tweenSettings.duration)) {
        settings.duration = tweenSettings.duration / l;
      }
    } else {
      // Transform [from, to] values shorthand to a valid tween value
      prop = {
        value: prop
      };
    }
  }

  var propArray = is.arr(prop) ? prop : [prop];
  return propArray.map(function (v, i) {
    var obj = is.obj(v) && !is.pth(v) ? v : {
      value: v
    }; // Default delay value should only be applied to the first tween

    if (is.und(obj.delay)) {
      obj.delay = !i ? tweenSettings.delay : 0;
    } // Default endDelay value should only be applied to the last tween


    if (is.und(obj.endDelay)) {
      obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0;
    }

    return obj;
  }).map(function (k) {
    return mergeObjects(k, settings);
  });
}

function flattenKeyframes(keyframes) {
  var propertyNames = filterArray(flattenArray(keyframes.map(function (key) {
    return Object.keys(key);
  })), function (p) {
    return is.key(p);
  }).reduce(function (a, b) {
    if (a.indexOf(b) < 0) {
      a.push(b);
    }

    return a;
  }, []);
  var properties = {};

  var loop = function (i) {
    var propName = propertyNames[i];
    properties[propName] = keyframes.map(function (key) {
      var newKey = {};

      for (var p in key) {
        if (is.key(p)) {
          if (p == propName) {
            newKey.value = key[p];
          }
        } else {
          newKey[p] = key[p];
        }
      }

      return newKey;
    });
  };

  for (var i = 0; i < propertyNames.length; i++) loop(i);

  return properties;
}

function getProperties(tweenSettings, params) {
  var properties = [];
  var keyframes = params.keyframes;

  if (keyframes) {
    params = mergeObjects(flattenKeyframes(keyframes), params);
  }

  for (var p in params) {
    if (is.key(p)) {
      properties.push({
        name: p,
        tweens: normalizePropertyTweens(params[p], tweenSettings)
      });
    }
  }

  return properties;
} // Tweens


function normalizeTweenValues(tween, animatable) {
  var t = {};

  for (var p in tween) {
    var value = getFunctionValue(tween[p], animatable);

    if (is.arr(value)) {
      value = value.map(function (v) {
        return getFunctionValue(v, animatable);
      });

      if (value.length === 1) {
        value = value[0];
      }
    }

    t[p] = value;
  }

  t.duration = parseFloat(t.duration);
  t.delay = parseFloat(t.delay);
  return t;
}

function normalizeTweens(prop, animatable) {
  var previousTween;
  return prop.tweens.map(function (t) {
    var tween = normalizeTweenValues(t, animatable);
    var tweenValue = tween.value;
    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
    var toUnit = getUnit(to);
    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
    var previousValue = previousTween ? previousTween.to.original : originalValue;
    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
    var fromUnit = getUnit(from) || getUnit(originalValue);
    var unit = toUnit || fromUnit;

    if (is.und(to)) {
      to = previousValue;
    }

    tween.from = decomposeValue(from, unit);
    tween.to = decomposeValue(getRelativeValue(to, from), unit);
    tween.start = previousTween ? previousTween.end : 0;
    tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
    tween.easing = parseEasings(tween.easing, tween.duration);
    tween.isPath = is.pth(tweenValue);
    tween.isColor = is.col(tween.from.original);

    if (tween.isColor) {
      tween.round = 1;
    }

    previousTween = tween;
    return tween;
  });
} // Tween progress


var setProgressValue = {
  css: function (t, p, v) {
    return t.style[p] = v;
  },
  attribute: function (t, p, v) {
    return t.setAttribute(p, v);
  },
  object: function (t, p, v) {
    return t[p] = v;
  },
  transform: function (t, p, v, transforms, manual) {
    transforms.list.set(p, v);

    if (p === transforms.last || manual) {
      var str = '';
      transforms.list.forEach(function (value, prop) {
        str += prop + "(" + value + ") ";
      });
      t.style.transform = str;
    }
  }
}; // Set Value helper

function setTargetsValue(targets, properties) {
  var animatables = getAnimatables(targets);
  animatables.forEach(function (animatable) {
    for (var property in properties) {
      var value = getFunctionValue(properties[property], animatable);
      var target = animatable.target;
      var valueUnit = getUnit(value);
      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
      var unit = valueUnit || getUnit(originalValue);
      var to = getRelativeValue(validateValue(value, unit), originalValue);
      var animType = getAnimationType(target, property);
      setProgressValue[animType](target, property, to, animatable.transforms, true);
    }
  });
} // Animations


function createAnimation(animatable, prop) {
  var animType = getAnimationType(animatable.target, prop.name);

  if (animType) {
    var tweens = normalizeTweens(prop, animatable);
    var lastTween = tweens[tweens.length - 1];
    return {
      type: animType,
      property: prop.name,
      animatable: animatable,
      tweens: tweens,
      duration: lastTween.end,
      delay: tweens[0].delay,
      endDelay: lastTween.endDelay
    };
  }
}

function getAnimations(animatables, properties) {
  return filterArray(flattenArray(animatables.map(function (animatable) {
    return properties.map(function (prop) {
      return createAnimation(animatable, prop);
    });
  })), function (a) {
    return !is.und(a);
  });
} // Create Instance


function getInstanceTimings(animations, tweenSettings) {
  var animLength = animations.length;

  var getTlOffset = function (anim) {
    return anim.timelineOffset ? anim.timelineOffset : 0;
  };

  var timings = {};
  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.duration;
  })) : tweenSettings.duration;
  timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.delay;
  })) : tweenSettings.delay;
  timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.duration - anim.endDelay;
  })) : tweenSettings.endDelay;
  return timings;
}

var instanceID = 0;

function createNewInstance(params) {
  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
  var properties = getProperties(tweenSettings, params);
  var animatables = getAnimatables(params.targets);
  var animations = getAnimations(animatables, properties);
  var timings = getInstanceTimings(animations, tweenSettings);
  var id = instanceID;
  instanceID++;
  return mergeObjects(instanceSettings, {
    id: id,
    children: [],
    animatables: animatables,
    animations: animations,
    duration: timings.duration,
    delay: timings.delay,
    endDelay: timings.endDelay
  });
} // Core


var activeInstances = [];
var pausedInstances = [];
var raf;

var engine = function () {
  function play() {
    raf = requestAnimationFrame(step);
  }

  function step(t) {
    var activeInstancesLength = activeInstances.length;

    if (activeInstancesLength) {
      var i = 0;

      while (i < activeInstancesLength) {
        var activeInstance = activeInstances[i];

        if (!activeInstance.paused) {
          activeInstance.tick(t);
        } else {
          var instanceIndex = activeInstances.indexOf(activeInstance);

          if (instanceIndex > -1) {
            activeInstances.splice(instanceIndex, 1);
            activeInstancesLength = activeInstances.length;
          }
        }

        i++;
      }

      play();
    } else {
      raf = cancelAnimationFrame(raf);
    }
  }

  return play;
}();

function handleVisibilityChange() {
  if (document.hidden) {
    activeInstances.forEach(function (ins) {
      return ins.pause();
    });
    pausedInstances = activeInstances.slice(0);
    anime.running = activeInstances = [];
  } else {
    pausedInstances.forEach(function (ins) {
      return ins.play();
    });
  }
}

if (typeof document !== 'undefined') {
  document.addEventListener('visibilitychange', handleVisibilityChange);
} // Public Instance


function anime(params) {
  if (params === void 0) params = {};
  var startTime = 0,
      lastTime = 0,
      now = 0;
  var children,
      childrenLength = 0;
  var resolve = null;

  function makePromise(instance) {
    var promise = window.Promise && new Promise(function (_resolve) {
      return resolve = _resolve;
    });
    instance.finished = promise;
    return promise;
  }

  var instance = createNewInstance(params);
  var promise = makePromise(instance);

  function toggleInstanceDirection() {
    var direction = instance.direction;

    if (direction !== 'alternate') {
      instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
    }

    instance.reversed = !instance.reversed;
    children.forEach(function (child) {
      return child.reversed = instance.reversed;
    });
  }

  function adjustTime(time) {
    return instance.reversed ? instance.duration - time : time;
  }

  function resetTime() {
    startTime = 0;
    lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
  }

  function seekChild(time, child) {
    if (child) {
      child.seek(time - child.timelineOffset);
    }
  }

  function syncInstanceChildren(time) {
    if (!instance.reversePlayback) {
      for (var i = 0; i < childrenLength; i++) {
        seekChild(time, children[i]);
      }
    } else {
      for (var i$1 = childrenLength; i$1--;) {
        seekChild(time, children[i$1]);
      }
    }
  }

  function setAnimationsProgress(insTime) {
    var i = 0;
    var animations = instance.animations;
    var animationsLength = animations.length;

    while (i < animationsLength) {
      var anim = animations[i];
      var animatable = anim.animatable;
      var tweens = anim.tweens;
      var tweenLength = tweens.length - 1;
      var tween = tweens[tweenLength]; // Only check for keyframes if there is more than one tween

      if (tweenLength) {
        tween = filterArray(tweens, function (t) {
          return insTime < t.end;
        })[0] || tween;
      }

      var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
      var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
      var strings = tween.to.strings;
      var round = tween.round;
      var numbers = [];
      var toNumbersLength = tween.to.numbers.length;
      var progress = void 0;

      for (var n = 0; n < toNumbersLength; n++) {
        var value = void 0;
        var toNumber = tween.to.numbers[n];
        var fromNumber = tween.from.numbers[n] || 0;

        if (!tween.isPath) {
          value = fromNumber + eased * (toNumber - fromNumber);
        } else {
          value = getPathProgress(tween.value, eased * toNumber);
        }

        if (round) {
          if (!(tween.isColor && n > 2)) {
            value = Math.round(value * round) / round;
          }
        }

        numbers.push(value);
      } // Manual Array.reduce for better performances


      var stringsLength = strings.length;

      if (!stringsLength) {
        progress = numbers[0];
      } else {
        progress = strings[0];

        for (var s = 0; s < stringsLength; s++) {
          var a = strings[s];
          var b = strings[s + 1];
          var n$1 = numbers[s];

          if (!isNaN(n$1)) {
            if (!b) {
              progress += n$1 + ' ';
            } else {
              progress += n$1 + b;
            }
          }
        }
      }

      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
      anim.currentValue = progress;
      i++;
    }
  }

  function setCallback(cb) {
    if (instance[cb] && !instance.passThrough) {
      instance[cb](instance);
    }
  }

  function countIteration() {
    if (instance.remaining && instance.remaining !== true) {
      instance.remaining--;
    }
  }

  function setInstanceProgress(engineTime) {
    var insDuration = instance.duration;
    var insDelay = instance.delay;
    var insEndDelay = insDuration - instance.endDelay;
    var insTime = adjustTime(engineTime);
    instance.progress = minMax(insTime / insDuration * 100, 0, 100);
    instance.reversePlayback = insTime < instance.currentTime;

    if (children) {
      syncInstanceChildren(insTime);
    }

    if (!instance.began && instance.currentTime > 0) {
      instance.began = true;
      setCallback('begin');
    }

    if (!instance.loopBegan && instance.currentTime > 0) {
      instance.loopBegan = true;
      setCallback('loopBegin');
    }

    if (insTime <= insDelay && instance.currentTime !== 0) {
      setAnimationsProgress(0);
    }

    if (insTime >= insEndDelay && instance.currentTime !== insDuration || !insDuration) {
      setAnimationsProgress(insDuration);
    }

    if (insTime > insDelay && insTime < insEndDelay) {
      if (!instance.changeBegan) {
        instance.changeBegan = true;
        instance.changeCompleted = false;
        setCallback('changeBegin');
      }

      setCallback('change');
      setAnimationsProgress(insTime);
    } else {
      if (instance.changeBegan) {
        instance.changeCompleted = true;
        instance.changeBegan = false;
        setCallback('changeComplete');
      }
    }

    instance.currentTime = minMax(insTime, 0, insDuration);

    if (instance.began) {
      setCallback('update');
    }

    if (engineTime >= insDuration) {
      lastTime = 0;
      countIteration();

      if (!instance.remaining) {
        instance.paused = true;

        if (!instance.completed) {
          instance.completed = true;
          setCallback('loopComplete');
          setCallback('complete');

          if (!instance.passThrough && 'Promise' in window) {
            resolve();
            promise = makePromise(instance);
          }
        }
      } else {
        startTime = now;
        setCallback('loopComplete');
        instance.loopBegan = false;

        if (instance.direction === 'alternate') {
          toggleInstanceDirection();
        }
      }
    }
  }

  instance.reset = function () {
    var direction = instance.direction;
    instance.passThrough = false;
    instance.currentTime = 0;
    instance.progress = 0;
    instance.paused = true;
    instance.began = false;
    instance.loopBegan = false;
    instance.changeBegan = false;
    instance.completed = false;
    instance.changeCompleted = false;
    instance.reversePlayback = false;
    instance.reversed = direction === 'reverse';
    instance.remaining = instance.loop;
    children = instance.children;
    childrenLength = children.length;

    for (var i = childrenLength; i--;) {
      instance.children[i].reset();
    }

    if (instance.reversed && instance.loop !== true || direction === 'alternate' && instance.loop === 1) {
      instance.remaining++;
    }

    setAnimationsProgress(instance.reversed ? instance.duration : 0);
  }; // Set Value helper


  instance.set = function (targets, properties) {
    setTargetsValue(targets, properties);
    return instance;
  };

  instance.tick = function (t) {
    now = t;

    if (!startTime) {
      startTime = now;
    }

    setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
  };

  instance.seek = function (time) {
    setInstanceProgress(adjustTime(time));
  };

  instance.pause = function () {
    instance.paused = true;
    resetTime();
  };

  instance.play = function () {
    if (!instance.paused) {
      return;
    }

    if (instance.completed) {
      instance.reset();
    }

    instance.paused = false;
    activeInstances.push(instance);
    resetTime();

    if (!raf) {
      engine();
    }
  };

  instance.reverse = function () {
    toggleInstanceDirection();
    resetTime();
  };

  instance.restart = function () {
    instance.reset();
    instance.play();
  };

  instance.reset();

  if (instance.autoplay) {
    instance.play();
  }

  return instance;
} // Remove targets from animation


function removeTargetsFromAnimations(targetsArray, animations) {
  for (var a = animations.length; a--;) {
    if (arrayContains(targetsArray, animations[a].animatable.target)) {
      animations.splice(a, 1);
    }
  }
}

function removeTargets(targets) {
  var targetsArray = parseTargets(targets);

  for (var i = activeInstances.length; i--;) {
    var instance = activeInstances[i];
    var animations = instance.animations;
    var children = instance.children;
    removeTargetsFromAnimations(targetsArray, animations);

    for (var c = children.length; c--;) {
      var child = children[c];
      var childAnimations = child.animations;
      removeTargetsFromAnimations(targetsArray, childAnimations);

      if (!childAnimations.length && !child.children.length) {
        children.splice(c, 1);
      }
    }

    if (!animations.length && !children.length) {
      instance.pause();
    }
  }
} // Stagger helpers


function stagger(val, params) {
  if (params === void 0) params = {};
  var direction = params.direction || 'normal';
  var easing = params.easing ? parseEasings(params.easing) : null;
  var grid = params.grid;
  var axis = params.axis;
  var fromIndex = params.from || 0;
  var fromFirst = fromIndex === 'first';
  var fromCenter = fromIndex === 'center';
  var fromLast = fromIndex === 'last';
  var isRange = is.arr(val);
  var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
  var val2 = isRange ? parseFloat(val[1]) : 0;
  var unit = getUnit(isRange ? val[1] : val) || 0;
  var start = params.start || 0 + (isRange ? val1 : 0);
  var values = [];
  var maxValue = 0;
  return function (el, i, t) {
    if (fromFirst) {
      fromIndex = 0;
    }

    if (fromCenter) {
      fromIndex = (t - 1) / 2;
    }

    if (fromLast) {
      fromIndex = t - 1;
    }

    if (!values.length) {
      for (var index = 0; index < t; index++) {
        if (!grid) {
          values.push(Math.abs(fromIndex - index));
        } else {
          var fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;
          var fromY = !fromCenter ? Math.floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;
          var toX = index % grid[0];
          var toY = Math.floor(index / grid[0]);
          var distanceX = fromX - toX;
          var distanceY = fromY - toY;
          var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

          if (axis === 'x') {
            value = -distanceX;
          }

          if (axis === 'y') {
            value = -distanceY;
          }

          values.push(value);
        }

        maxValue = Math.max.apply(Math, values);
      }

      if (easing) {
        values = values.map(function (val) {
          return easing(val / maxValue) * maxValue;
        });
      }

      if (direction === 'reverse') {
        values = values.map(function (val) {
          return axis ? val < 0 ? val * -1 : -val : Math.abs(maxValue - val);
        });
      }
    }

    var spacing = isRange ? (val2 - val1) / maxValue : val1;
    return start + spacing * (Math.round(values[i] * 100) / 100) + unit;
  };
} // Timeline


function timeline(params) {
  if (params === void 0) params = {};
  var tl = anime(params);
  tl.duration = 0;

  tl.add = function (instanceParams, timelineOffset) {
    var tlIndex = activeInstances.indexOf(tl);
    var children = tl.children;

    if (tlIndex > -1) {
      activeInstances.splice(tlIndex, 1);
    }

    function passThrough(ins) {
      ins.passThrough = true;
    }

    for (var i = 0; i < children.length; i++) {
      passThrough(children[i]);
    }

    var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
    insParams.targets = insParams.targets || params.targets;
    var tlDuration = tl.duration;
    insParams.autoplay = false;
    insParams.direction = tl.direction;
    insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
    passThrough(tl);
    tl.seek(insParams.timelineOffset);
    var ins = anime(insParams);
    passThrough(ins);
    children.push(ins);
    var timings = getInstanceTimings(children, params);
    tl.delay = timings.delay;
    tl.endDelay = timings.endDelay;
    tl.duration = timings.duration;
    tl.seek(0);
    tl.reset();

    if (tl.autoplay) {
      tl.play();
    }

    return tl;
  };

  return tl;
}

anime.version = '3.1.0';
anime.speed = 1;
anime.running = activeInstances;
anime.remove = removeTargets;
anime.get = getOriginalTargetValue;
anime.set = setTargetsValue;
anime.convertPx = convertPxToUnit;
anime.path = getPath;
anime.setDashoffset = setDashoffset;
anime.stagger = stagger;
anime.timeline = timeline;
anime.easing = parseEasings;
anime.penner = penner;

anime.random = function (min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

var _default = anime;
exports.default = _default;
},{}],"../node_modules/inherits/inherits_browser.js":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],"../node_modules/node-libs-browser/node_modules/events/events.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = $getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  var args = [];

  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);

  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}
},{}],"../node_modules/right-now/browser.js":[function(require,module,exports) {
var global = arguments[3];
module.exports =
  global.performance &&
  global.performance.now ? function now() {
    return performance.now()
  } : Date.now || function now() {
    return +new Date
  }

},{}],"../node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"../node_modules/performance-now/lib/performance-now.js":[function(require,module,exports) {
var process = require("process");
// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);



},{"process":"../node_modules/process/browser.js"}],"../node_modules/raf/index.js":[function(require,module,exports) {
var global = arguments[3];
var now = require('performance-now')
  , root = typeof window === 'undefined' ? global : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf
  object.cancelAnimationFrame = caf
}

},{"performance-now":"../node_modules/performance-now/lib/performance-now.js"}],"../node_modules/raf-loop/index.js":[function(require,module,exports) {
var inherits = require('inherits')
var EventEmitter = require('events').EventEmitter
var now = require('right-now')
var raf = require('raf')

module.exports = Engine
function Engine(fn) {
    if (!(this instanceof Engine)) 
        return new Engine(fn)
    this.running = false
    this.last = now()
    this._frame = 0
    this._tick = this.tick.bind(this)

    if (fn)
        this.on('tick', fn)
}

inherits(Engine, EventEmitter)

Engine.prototype.start = function() {
    if (this.running) 
        return
    this.running = true
    this.last = now()
    this._frame = raf(this._tick)
    return this
}

Engine.prototype.stop = function() {
    this.running = false
    if (this._frame !== 0)
        raf.cancel(this._frame)
    this._frame = 0
    return this
}

Engine.prototype.tick = function() {
    this._frame = raf(this._tick)
    var time = now()
    var dt = time - this.last
    this.emit('tick', dt)
    this.last = time
}
},{"inherits":"../node_modules/inherits/inherits_browser.js","events":"../node_modules/node-libs-browser/node_modules/events/events.js","right-now":"../node_modules/right-now/browser.js","raf":"../node_modules/raf/index.js"}],"../node_modules/three/examples/jsm/controls/OrbitControls.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MapControls = exports.OrbitControls = void 0;

var _threeModule = require("../../../build/three.module.js");

/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 * @author ScieCode / http://github.com/sciecode
 */
// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move
var OrbitControls = function (object, domElement) {
  this.object = object;
  this.domElement = domElement !== undefined ? domElement : document; // Set to false to disable this control

  this.enabled = true; // "target" sets the location of focus, where the object orbits around

  this.target = new _threeModule.Vector3(); // How far you can dolly in and out ( PerspectiveCamera only )

  this.minDistance = 0;
  this.maxDistance = Infinity; // How far you can zoom in and out ( OrthographicCamera only )

  this.minZoom = 0;
  this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits.
  // Range is 0 to Math.PI radians.

  this.minPolarAngle = 0; // radians

  this.maxPolarAngle = Math.PI; // radians
  // How far you can orbit horizontally, upper and lower limits.
  // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].

  this.minAzimuthAngle = -Infinity; // radians

  this.maxAzimuthAngle = Infinity; // radians
  // Set to true to enable damping (inertia)
  // If damping is enabled, you must call controls.update() in your animation loop

  this.enableDamping = false;
  this.dampingFactor = 0.05; // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
  // Set to false to disable zooming

  this.enableZoom = true;
  this.zoomSpeed = 1.0; // Set to false to disable rotating

  this.enableRotate = true;
  this.rotateSpeed = 1.0; // Set to false to disable panning

  this.enablePan = true;
  this.panSpeed = 1.0;
  this.screenSpacePanning = false; // if true, pan in screen-space

  this.keyPanSpeed = 7.0; // pixels moved per arrow key push
  // Set to true to automatically rotate around the target
  // If auto-rotate is enabled, you must call controls.update() in your animation loop

  this.autoRotate = false;
  this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60
  // Set to false to disable use of the keys

  this.enableKeys = true; // The four arrow keys

  this.keys = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    BOTTOM: 40
  }; // Mouse buttons

  this.mouseButtons = {
    LEFT: _threeModule.MOUSE.ROTATE,
    MIDDLE: _threeModule.MOUSE.DOLLY,
    RIGHT: _threeModule.MOUSE.PAN
  }; // Touch fingers

  this.touches = {
    ONE: _threeModule.TOUCH.ROTATE,
    TWO: _threeModule.TOUCH.DOLLY_PAN
  }; // for reset

  this.target0 = this.target.clone();
  this.position0 = this.object.position.clone();
  this.zoom0 = this.object.zoom; //
  // public methods
  //

  this.getPolarAngle = function () {
    return spherical.phi;
  };

  this.getAzimuthalAngle = function () {
    return spherical.theta;
  };

  this.saveState = function () {
    scope.target0.copy(scope.target);
    scope.position0.copy(scope.object.position);
    scope.zoom0 = scope.object.zoom;
  };

  this.reset = function () {
    scope.target.copy(scope.target0);
    scope.object.position.copy(scope.position0);
    scope.object.zoom = scope.zoom0;
    scope.object.updateProjectionMatrix();
    scope.dispatchEvent(changeEvent);
    scope.update();
    state = STATE.NONE;
  }; // this method is exposed, but perhaps it would be better if we can make it private...


  this.update = function () {
    var offset = new _threeModule.Vector3(); // so camera.up is the orbit axis

    var quat = new _threeModule.Quaternion().setFromUnitVectors(object.up, new _threeModule.Vector3(0, 1, 0));
    var quatInverse = quat.clone().inverse();
    var lastPosition = new _threeModule.Vector3();
    var lastQuaternion = new _threeModule.Quaternion();
    return function update() {
      var position = scope.object.position;
      offset.copy(position).sub(scope.target); // rotate offset to "y-axis-is-up" space

      offset.applyQuaternion(quat); // angle from z-axis around y-axis

      spherical.setFromVector3(offset);

      if (scope.autoRotate && state === STATE.NONE) {
        rotateLeft(getAutoRotationAngle());
      }

      if (scope.enableDamping) {
        spherical.theta += sphericalDelta.theta * scope.dampingFactor;
        spherical.phi += sphericalDelta.phi * scope.dampingFactor;
      } else {
        spherical.theta += sphericalDelta.theta;
        spherical.phi += sphericalDelta.phi;
      } // restrict theta to be between desired limits


      spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta)); // restrict phi to be between desired limits

      spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
      spherical.makeSafe();
      spherical.radius *= scale; // restrict radius to be between desired limits

      spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius)); // move target to panned location

      if (scope.enableDamping === true) {
        scope.target.addScaledVector(panOffset, scope.dampingFactor);
      } else {
        scope.target.add(panOffset);
      }

      offset.setFromSpherical(spherical); // rotate offset back to "camera-up-vector-is-up" space

      offset.applyQuaternion(quatInverse);
      position.copy(scope.target).add(offset);
      scope.object.lookAt(scope.target);

      if (scope.enableDamping === true) {
        sphericalDelta.theta *= 1 - scope.dampingFactor;
        sphericalDelta.phi *= 1 - scope.dampingFactor;
        panOffset.multiplyScalar(1 - scope.dampingFactor);
      } else {
        sphericalDelta.set(0, 0, 0);
        panOffset.set(0, 0, 0);
      }

      scale = 1; // update condition is:
      // min(camera displacement, camera rotation in radians)^2 > EPS
      // using small-angle approximation cos(x/2) = 1 - x^2 / 8

      if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
        scope.dispatchEvent(changeEvent);
        lastPosition.copy(scope.object.position);
        lastQuaternion.copy(scope.object.quaternion);
        zoomChanged = false;
        return true;
      }

      return false;
    };
  }();

  this.dispose = function () {
    scope.domElement.removeEventListener('contextmenu', onContextMenu, false);
    scope.domElement.removeEventListener('mousedown', onMouseDown, false);
    scope.domElement.removeEventListener('wheel', onMouseWheel, false);
    scope.domElement.removeEventListener('touchstart', onTouchStart, false);
    scope.domElement.removeEventListener('touchend', onTouchEnd, false);
    scope.domElement.removeEventListener('touchmove', onTouchMove, false);
    document.removeEventListener('mousemove', onMouseMove, false);
    document.removeEventListener('mouseup', onMouseUp, false);
    window.removeEventListener('keydown', onKeyDown, false); //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
  }; //
  // internals
  //


  var scope = this;
  var changeEvent = {
    type: 'change'
  };
  var startEvent = {
    type: 'start'
  };
  var endEvent = {
    type: 'end'
  };
  var STATE = {
    NONE: -1,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_PAN: 4,
    TOUCH_DOLLY_PAN: 5,
    TOUCH_DOLLY_ROTATE: 6
  };
  var state = STATE.NONE;
  var EPS = 0.000001; // current position in spherical coordinates

  var spherical = new _threeModule.Spherical();
  var sphericalDelta = new _threeModule.Spherical();
  var scale = 1;
  var panOffset = new _threeModule.Vector3();
  var zoomChanged = false;
  var rotateStart = new _threeModule.Vector2();
  var rotateEnd = new _threeModule.Vector2();
  var rotateDelta = new _threeModule.Vector2();
  var panStart = new _threeModule.Vector2();
  var panEnd = new _threeModule.Vector2();
  var panDelta = new _threeModule.Vector2();
  var dollyStart = new _threeModule.Vector2();
  var dollyEnd = new _threeModule.Vector2();
  var dollyDelta = new _threeModule.Vector2();

  function getAutoRotationAngle() {
    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
  }

  function getZoomScale() {
    return Math.pow(0.95, scope.zoomSpeed);
  }

  function rotateLeft(angle) {
    sphericalDelta.theta -= angle;
  }

  function rotateUp(angle) {
    sphericalDelta.phi -= angle;
  }

  var panLeft = function () {
    var v = new _threeModule.Vector3();
    return function panLeft(distance, objectMatrix) {
      v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix

      v.multiplyScalar(-distance);
      panOffset.add(v);
    };
  }();

  var panUp = function () {
    var v = new _threeModule.Vector3();
    return function panUp(distance, objectMatrix) {
      if (scope.screenSpacePanning === true) {
        v.setFromMatrixColumn(objectMatrix, 1);
      } else {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.crossVectors(scope.object.up, v);
      }

      v.multiplyScalar(distance);
      panOffset.add(v);
    };
  }(); // deltaX and deltaY are in pixels; right and down are positive


  var pan = function () {
    var offset = new _threeModule.Vector3();
    return function pan(deltaX, deltaY) {
      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

      if (scope.object.isPerspectiveCamera) {
        // perspective
        var position = scope.object.position;
        offset.copy(position).sub(scope.target);
        var targetDistance = offset.length(); // half of the fov is center to top of screen

        targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0); // we use only clientHeight here so aspect ratio does not distort speed

        panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
        panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
      } else if (scope.object.isOrthographicCamera) {
        // orthographic
        panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
        panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
      } else {
        // camera neither orthographic nor perspective
        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
        scope.enablePan = false;
      }
    };
  }();

  function dollyIn(dollyScale) {
    if (scope.object.isPerspectiveCamera) {
      scale /= dollyScale;
    } else if (scope.object.isOrthographicCamera) {
      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
      scope.object.updateProjectionMatrix();
      zoomChanged = true;
    } else {
      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
      scope.enableZoom = false;
    }
  }

  function dollyOut(dollyScale) {
    if (scope.object.isPerspectiveCamera) {
      scale *= dollyScale;
    } else if (scope.object.isOrthographicCamera) {
      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
      scope.object.updateProjectionMatrix();
      zoomChanged = true;
    } else {
      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
      scope.enableZoom = false;
    }
  } //
  // event callbacks - update the object state
  //


  function handleMouseDownRotate(event) {
    rotateStart.set(event.clientX, event.clientY);
  }

  function handleMouseDownDolly(event) {
    dollyStart.set(event.clientX, event.clientY);
  }

  function handleMouseDownPan(event) {
    panStart.set(event.clientX, event.clientY);
  }

  function handleMouseMoveRotate(event) {
    rotateEnd.set(event.clientX, event.clientY);
    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
    rotateStart.copy(rotateEnd);
    scope.update();
  }

  function handleMouseMoveDolly(event) {
    dollyEnd.set(event.clientX, event.clientY);
    dollyDelta.subVectors(dollyEnd, dollyStart);

    if (dollyDelta.y > 0) {
      dollyIn(getZoomScale());
    } else if (dollyDelta.y < 0) {
      dollyOut(getZoomScale());
    }

    dollyStart.copy(dollyEnd);
    scope.update();
  }

  function handleMouseMovePan(event) {
    panEnd.set(event.clientX, event.clientY);
    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
    pan(panDelta.x, panDelta.y);
    panStart.copy(panEnd);
    scope.update();
  }

  function handleMouseUp()
  /*event*/
  {// no-op
  }

  function handleMouseWheel(event) {
    if (event.deltaY < 0) {
      dollyOut(getZoomScale());
    } else if (event.deltaY > 0) {
      dollyIn(getZoomScale());
    }

    scope.update();
  }

  function handleKeyDown(event) {
    var needsUpdate = false;

    switch (event.keyCode) {
      case scope.keys.UP:
        pan(0, scope.keyPanSpeed);
        needsUpdate = true;
        break;

      case scope.keys.BOTTOM:
        pan(0, -scope.keyPanSpeed);
        needsUpdate = true;
        break;

      case scope.keys.LEFT:
        pan(scope.keyPanSpeed, 0);
        needsUpdate = true;
        break;

      case scope.keys.RIGHT:
        pan(-scope.keyPanSpeed, 0);
        needsUpdate = true;
        break;
    }

    if (needsUpdate) {
      // prevent the browser from scrolling on cursor keys
      event.preventDefault();
      scope.update();
    }
  }

  function handleTouchStartRotate(event) {
    if (event.touches.length == 1) {
      rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
    } else {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      rotateStart.set(x, y);
    }
  }

  function handleTouchStartPan(event) {
    if (event.touches.length == 1) {
      panStart.set(event.touches[0].pageX, event.touches[0].pageY);
    } else {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      panStart.set(x, y);
    }
  }

  function handleTouchStartDolly(event) {
    var dx = event.touches[0].pageX - event.touches[1].pageX;
    var dy = event.touches[0].pageY - event.touches[1].pageY;
    var distance = Math.sqrt(dx * dx + dy * dy);
    dollyStart.set(0, distance);
  }

  function handleTouchStartDollyPan(event) {
    if (scope.enableZoom) handleTouchStartDolly(event);
    if (scope.enablePan) handleTouchStartPan(event);
  }

  function handleTouchStartDollyRotate(event) {
    if (scope.enableZoom) handleTouchStartDolly(event);
    if (scope.enableRotate) handleTouchStartRotate(event);
  }

  function handleTouchMoveRotate(event) {
    if (event.touches.length == 1) {
      rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
    } else {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      rotateEnd.set(x, y);
    }

    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
    rotateStart.copy(rotateEnd);
  }

  function handleTouchMovePan(event) {
    if (event.touches.length == 1) {
      panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
    } else {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      panEnd.set(x, y);
    }

    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
    pan(panDelta.x, panDelta.y);
    panStart.copy(panEnd);
  }

  function handleTouchMoveDolly(event) {
    var dx = event.touches[0].pageX - event.touches[1].pageX;
    var dy = event.touches[0].pageY - event.touches[1].pageY;
    var distance = Math.sqrt(dx * dx + dy * dy);
    dollyEnd.set(0, distance);
    dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
    dollyIn(dollyDelta.y);
    dollyStart.copy(dollyEnd);
  }

  function handleTouchMoveDollyPan(event) {
    if (scope.enableZoom) handleTouchMoveDolly(event);
    if (scope.enablePan) handleTouchMovePan(event);
  }

  function handleTouchMoveDollyRotate(event) {
    if (scope.enableZoom) handleTouchMoveDolly(event);
    if (scope.enableRotate) handleTouchMoveRotate(event);
  }

  function handleTouchEnd()
  /*event*/
  {} // no-op
  //
  // event handlers - FSM: listen for events and reset state
  //


  function onMouseDown(event) {
    if (scope.enabled === false) return; // Prevent the browser from scrolling.

    event.preventDefault(); // Manually set the focus since calling preventDefault above
    // prevents the browser from setting it automatically.

    scope.domElement.focus ? scope.domElement.focus() : window.focus();

    switch (event.button) {
      case 0:
        switch (scope.mouseButtons.LEFT) {
          case _threeModule.MOUSE.ROTATE:
            if (event.ctrlKey || event.metaKey || event.shiftKey) {
              if (scope.enablePan === false) return;
              handleMouseDownPan(event);
              state = STATE.PAN;
            } else {
              if (scope.enableRotate === false) return;
              handleMouseDownRotate(event);
              state = STATE.ROTATE;
            }

            break;

          case _threeModule.MOUSE.PAN:
            if (event.ctrlKey || event.metaKey || event.shiftKey) {
              if (scope.enableRotate === false) return;
              handleMouseDownRotate(event);
              state = STATE.ROTATE;
            } else {
              if (scope.enablePan === false) return;
              handleMouseDownPan(event);
              state = STATE.PAN;
            }

            break;

          default:
            state = STATE.NONE;
        }

        break;

      case 1:
        switch (scope.mouseButtons.MIDDLE) {
          case _threeModule.MOUSE.DOLLY:
            if (scope.enableZoom === false) return;
            handleMouseDownDolly(event);
            state = STATE.DOLLY;
            break;

          default:
            state = STATE.NONE;
        }

        break;

      case 2:
        switch (scope.mouseButtons.RIGHT) {
          case _threeModule.MOUSE.ROTATE:
            if (scope.enableRotate === false) return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
            break;

          case _threeModule.MOUSE.PAN:
            if (scope.enablePan === false) return;
            handleMouseDownPan(event);
            state = STATE.PAN;
            break;

          default:
            state = STATE.NONE;
        }

        break;
    }

    if (state !== STATE.NONE) {
      document.addEventListener('mousemove', onMouseMove, false);
      document.addEventListener('mouseup', onMouseUp, false);
      scope.dispatchEvent(startEvent);
    }
  }

  function onMouseMove(event) {
    if (scope.enabled === false) return;
    event.preventDefault();

    switch (state) {
      case STATE.ROTATE:
        if (scope.enableRotate === false) return;
        handleMouseMoveRotate(event);
        break;

      case STATE.DOLLY:
        if (scope.enableZoom === false) return;
        handleMouseMoveDolly(event);
        break;

      case STATE.PAN:
        if (scope.enablePan === false) return;
        handleMouseMovePan(event);
        break;
    }
  }

  function onMouseUp(event) {
    if (scope.enabled === false) return;
    handleMouseUp(event);
    document.removeEventListener('mousemove', onMouseMove, false);
    document.removeEventListener('mouseup', onMouseUp, false);
    scope.dispatchEvent(endEvent);
    state = STATE.NONE;
  }

  function onMouseWheel(event) {
    if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;
    event.preventDefault();
    event.stopPropagation();
    scope.dispatchEvent(startEvent);
    handleMouseWheel(event);
    scope.dispatchEvent(endEvent);
  }

  function onKeyDown(event) {
    if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;
    handleKeyDown(event);
  }

  function onTouchStart(event) {
    if (scope.enabled === false) return;
    event.preventDefault();

    switch (event.touches.length) {
      case 1:
        switch (scope.touches.ONE) {
          case _threeModule.TOUCH.ROTATE:
            if (scope.enableRotate === false) return;
            handleTouchStartRotate(event);
            state = STATE.TOUCH_ROTATE;
            break;

          case _threeModule.TOUCH.PAN:
            if (scope.enablePan === false) return;
            handleTouchStartPan(event);
            state = STATE.TOUCH_PAN;
            break;

          default:
            state = STATE.NONE;
        }

        break;

      case 2:
        switch (scope.touches.TWO) {
          case _threeModule.TOUCH.DOLLY_PAN:
            if (scope.enableZoom === false && scope.enablePan === false) return;
            handleTouchStartDollyPan(event);
            state = STATE.TOUCH_DOLLY_PAN;
            break;

          case _threeModule.TOUCH.DOLLY_ROTATE:
            if (scope.enableZoom === false && scope.enableRotate === false) return;
            handleTouchStartDollyRotate(event);
            state = STATE.TOUCH_DOLLY_ROTATE;
            break;

          default:
            state = STATE.NONE;
        }

        break;

      default:
        state = STATE.NONE;
    }

    if (state !== STATE.NONE) {
      scope.dispatchEvent(startEvent);
    }
  }

  function onTouchMove(event) {
    if (scope.enabled === false) return;
    event.preventDefault();
    event.stopPropagation();

    switch (state) {
      case STATE.TOUCH_ROTATE:
        if (scope.enableRotate === false) return;
        handleTouchMoveRotate(event);
        scope.update();
        break;

      case STATE.TOUCH_PAN:
        if (scope.enablePan === false) return;
        handleTouchMovePan(event);
        scope.update();
        break;

      case STATE.TOUCH_DOLLY_PAN:
        if (scope.enableZoom === false && scope.enablePan === false) return;
        handleTouchMoveDollyPan(event);
        scope.update();
        break;

      case STATE.TOUCH_DOLLY_ROTATE:
        if (scope.enableZoom === false && scope.enableRotate === false) return;
        handleTouchMoveDollyRotate(event);
        scope.update();
        break;

      default:
        state = STATE.NONE;
    }
  }

  function onTouchEnd(event) {
    if (scope.enabled === false) return;
    handleTouchEnd(event);
    scope.dispatchEvent(endEvent);
    state = STATE.NONE;
  }

  function onContextMenu(event) {
    if (scope.enabled === false) return;
    event.preventDefault();
  } //


  scope.domElement.addEventListener('contextmenu', onContextMenu, false);
  scope.domElement.addEventListener('mousedown', onMouseDown, false);
  scope.domElement.addEventListener('wheel', onMouseWheel, false);
  scope.domElement.addEventListener('touchstart', onTouchStart, false);
  scope.domElement.addEventListener('touchend', onTouchEnd, false);
  scope.domElement.addEventListener('touchmove', onTouchMove, false);
  window.addEventListener('keydown', onKeyDown, false); // force an update at start

  this.update();
};

exports.OrbitControls = OrbitControls;
OrbitControls.prototype = Object.create(_threeModule.EventDispatcher.prototype);
OrbitControls.prototype.constructor = OrbitControls; // This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
// This is very similar to OrbitControls, another set of touch behavior
//
//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - left mouse, or arrow keys / touch: one-finger move

var MapControls = function (object, domElement) {
  OrbitControls.call(this, object, domElement);
  this.mouseButtons.LEFT = _threeModule.MOUSE.PAN;
  this.mouseButtons.RIGHT = _threeModule.MOUSE.ROTATE;
  this.touches.ONE = _threeModule.TOUCH.PAN;
  this.touches.TWO = _threeModule.TOUCH.DOLLY_ROTATE;
};

exports.MapControls = MapControls;
MapControls.prototype = Object.create(_threeModule.EventDispatcher.prototype);
MapControls.prototype.constructor = MapControls;
},{"../../../build/three.module.js":"../node_modules/three/build/three.module.js"}],"../node_modules/three/examples/jsm/shaders/CopyShader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CopyShader = void 0;

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */
var CopyShader = {
  uniforms: {
    "tDiffuse": {
      value: null
    },
    "opacity": {
      value: 1.0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n")
};
exports.CopyShader = CopyShader;
},{}],"../node_modules/three/examples/jsm/postprocessing/Pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pass = Pass;

var _threeModule = require("../../../build/three.module.js");

function Pass() {
  // if set to true, the pass is processed by the composer
  this.enabled = true; // if set to true, the pass indicates to swap read and write buffer after rendering

  this.needsSwap = true; // if set to true, the pass clears its buffer before rendering

  this.clear = false; // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.

  this.renderToScreen = false;
}

Object.assign(Pass.prototype, {
  setSize: function ()
  /* width, height */
  {},
  render: function ()
  /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */
  {
    console.error('THREE.Pass: .render() must be implemented in derived pass.');
  }
}); // Helper for passes that need to fill the viewport with a single quad.

Pass.FullScreenQuad = function () {
  var camera = new _threeModule.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  var geometry = new _threeModule.PlaneBufferGeometry(2, 2);

  var FullScreenQuad = function (material) {
    this._mesh = new _threeModule.Mesh(geometry, material);
  };

  Object.defineProperty(FullScreenQuad.prototype, 'material', {
    get: function () {
      return this._mesh.material;
    },
    set: function (value) {
      this._mesh.material = value;
    }
  });
  Object.assign(FullScreenQuad.prototype, {
    render: function (renderer) {
      renderer.render(this._mesh, camera);
    }
  });
  return FullScreenQuad;
}();
},{"../../../build/three.module.js":"../node_modules/three/build/three.module.js"}],"../node_modules/three/examples/jsm/postprocessing/ShaderPass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShaderPass = void 0;

var _threeModule = require("../../../build/three.module.js");

var _Pass = require("../postprocessing/Pass.js");

/**
 * @author alteredq / http://alteredqualia.com/
 */
var ShaderPass = function (shader, textureID) {
  _Pass.Pass.call(this);

  this.textureID = textureID !== undefined ? textureID : "tDiffuse";

  if (shader instanceof _threeModule.ShaderMaterial) {
    this.uniforms = shader.uniforms;
    this.material = shader;
  } else if (shader) {
    this.uniforms = _threeModule.UniformsUtils.clone(shader.uniforms);
    this.material = new _threeModule.ShaderMaterial({
      defines: Object.assign({}, shader.defines),
      uniforms: this.uniforms,
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader
    });
  }

  this.fsQuad = new _Pass.Pass.FullScreenQuad(this.material);
};

exports.ShaderPass = ShaderPass;
ShaderPass.prototype = Object.assign(Object.create(_Pass.Pass.prototype), {
  constructor: ShaderPass,
  render: function (renderer, writeBuffer, readBuffer
  /*, deltaTime, maskActive */
  ) {
    if (this.uniforms[this.textureID]) {
      this.uniforms[this.textureID].value = readBuffer.texture;
    }

    this.fsQuad.material = this.material;

    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer); // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600

      if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      this.fsQuad.render(renderer);
    }
  }
});
},{"../../../build/three.module.js":"../node_modules/three/build/three.module.js","../postprocessing/Pass.js":"../node_modules/three/examples/jsm/postprocessing/Pass.js"}],"../node_modules/three/examples/jsm/postprocessing/MaskPass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ClearMaskPass = exports.MaskPass = void 0;

var _Pass = require("../postprocessing/Pass.js");

/**
 * @author alteredq / http://alteredqualia.com/
 */
var MaskPass = function (scene, camera) {
  _Pass.Pass.call(this);

  this.scene = scene;
  this.camera = camera;
  this.clear = true;
  this.needsSwap = false;
  this.inverse = false;
};

exports.MaskPass = MaskPass;
MaskPass.prototype = Object.assign(Object.create(_Pass.Pass.prototype), {
  constructor: MaskPass,
  render: function (renderer, writeBuffer, readBuffer
  /*, deltaTime, maskActive */
  ) {
    var context = renderer.getContext();
    var state = renderer.state; // don't update color or depth

    state.buffers.color.setMask(false);
    state.buffers.depth.setMask(false); // lock buffers

    state.buffers.color.setLocked(true);
    state.buffers.depth.setLocked(true); // set up stencil

    var writeValue, clearValue;

    if (this.inverse) {
      writeValue = 0;
      clearValue = 1;
    } else {
      writeValue = 1;
      clearValue = 0;
    }

    state.buffers.stencil.setTest(true);
    state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
    state.buffers.stencil.setClear(clearValue);
    state.buffers.stencil.setLocked(true); // draw into the stencil buffer

    renderer.setRenderTarget(readBuffer);
    if (this.clear) renderer.clear();
    renderer.render(this.scene, this.camera);
    renderer.setRenderTarget(writeBuffer);
    if (this.clear) renderer.clear();
    renderer.render(this.scene, this.camera); // unlock color and depth buffer for subsequent rendering

    state.buffers.color.setLocked(false);
    state.buffers.depth.setLocked(false); // only render where stencil is set to 1

    state.buffers.stencil.setLocked(false);
    state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1

    state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    state.buffers.stencil.setLocked(true);
  }
});

var ClearMaskPass = function () {
  _Pass.Pass.call(this);

  this.needsSwap = false;
};

exports.ClearMaskPass = ClearMaskPass;
ClearMaskPass.prototype = Object.create(_Pass.Pass.prototype);
Object.assign(ClearMaskPass.prototype, {
  render: function (renderer
  /*, writeBuffer, readBuffer, deltaTime, maskActive */
  ) {
    renderer.state.buffers.stencil.setLocked(false);
    renderer.state.buffers.stencil.setTest(false);
  }
});
},{"../postprocessing/Pass.js":"../node_modules/three/examples/jsm/postprocessing/Pass.js"}],"../node_modules/three/examples/jsm/postprocessing/EffectComposer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pass = exports.EffectComposer = void 0;

var _threeModule = require("../../../build/three.module.js");

var _CopyShader = require("../shaders/CopyShader.js");

var _ShaderPass = require("../postprocessing/ShaderPass.js");

var _MaskPass = require("../postprocessing/MaskPass.js");

/**
 * @author alteredq / http://alteredqualia.com/
 */
var EffectComposer = function (renderer, renderTarget) {
  this.renderer = renderer;

  if (renderTarget === undefined) {
    var parameters = {
      minFilter: _threeModule.LinearFilter,
      magFilter: _threeModule.LinearFilter,
      format: _threeModule.RGBAFormat,
      stencilBuffer: false
    };
    var size = renderer.getSize(new _threeModule.Vector2());
    this._pixelRatio = renderer.getPixelRatio();
    this._width = size.width;
    this._height = size.height;
    renderTarget = new _threeModule.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, parameters);
    renderTarget.texture.name = 'EffectComposer.rt1';
  } else {
    this._pixelRatio = 1;
    this._width = renderTarget.width;
    this._height = renderTarget.height;
  }

  this.renderTarget1 = renderTarget;
  this.renderTarget2 = renderTarget.clone();
  this.renderTarget2.texture.name = 'EffectComposer.rt2';
  this.writeBuffer = this.renderTarget1;
  this.readBuffer = this.renderTarget2;
  this.renderToScreen = true;
  this.passes = []; // dependencies

  if (_CopyShader.CopyShader === undefined) {
    console.error('THREE.EffectComposer relies on CopyShader');
  }

  if (_ShaderPass.ShaderPass === undefined) {
    console.error('THREE.EffectComposer relies on ShaderPass');
  }

  this.copyPass = new _ShaderPass.ShaderPass(_CopyShader.CopyShader);
  this.clock = new _threeModule.Clock();
};

exports.EffectComposer = EffectComposer;
Object.assign(EffectComposer.prototype, {
  swapBuffers: function () {
    var tmp = this.readBuffer;
    this.readBuffer = this.writeBuffer;
    this.writeBuffer = tmp;
  },
  addPass: function (pass) {
    this.passes.push(pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  },
  insertPass: function (pass, index) {
    this.passes.splice(index, 0, pass);
  },
  isLastEnabledPass: function (passIndex) {
    for (var i = passIndex + 1; i < this.passes.length; i++) {
      if (this.passes[i].enabled) {
        return false;
      }
    }

    return true;
  },
  render: function (deltaTime) {
    // deltaTime value is in seconds
    if (deltaTime === undefined) {
      deltaTime = this.clock.getDelta();
    }

    var currentRenderTarget = this.renderer.getRenderTarget();
    var maskActive = false;
    var pass,
        i,
        il = this.passes.length;

    for (i = 0; i < il; i++) {
      pass = this.passes[i];
      if (pass.enabled === false) continue;
      pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
      pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);

      if (pass.needsSwap) {
        if (maskActive) {
          var context = this.renderer.getContext();
          var stencil = this.renderer.state.buffers.stencil; //context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

          stencil.setFunc(context.NOTEQUAL, 1, 0xffffffff);
          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime); //context.stencilFunc( context.EQUAL, 1, 0xffffffff );

          stencil.setFunc(context.EQUAL, 1, 0xffffffff);
        }

        this.swapBuffers();
      }

      if (_MaskPass.MaskPass !== undefined) {
        if (pass instanceof _MaskPass.MaskPass) {
          maskActive = true;
        } else if (pass instanceof _MaskPass.ClearMaskPass) {
          maskActive = false;
        }
      }
    }

    this.renderer.setRenderTarget(currentRenderTarget);
  },
  reset: function (renderTarget) {
    if (renderTarget === undefined) {
      var size = this.renderer.getSize(new _threeModule.Vector2());
      this._pixelRatio = this.renderer.getPixelRatio();
      this._width = size.width;
      this._height = size.height;
      renderTarget = this.renderTarget1.clone();
      renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }

    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
  },
  setSize: function (width, height) {
    this._width = width;
    this._height = height;
    var effectiveWidth = this._width * this._pixelRatio;
    var effectiveHeight = this._height * this._pixelRatio;
    this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
    this.renderTarget2.setSize(effectiveWidth, effectiveHeight);

    for (var i = 0; i < this.passes.length; i++) {
      this.passes[i].setSize(effectiveWidth, effectiveHeight);
    }
  },
  setPixelRatio: function (pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
});

var Pass = function () {
  // if set to true, the pass is processed by the composer
  this.enabled = true; // if set to true, the pass indicates to swap read and write buffer after rendering

  this.needsSwap = true; // if set to true, the pass clears its buffer before rendering

  this.clear = false; // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.

  this.renderToScreen = false;
};

exports.Pass = Pass;
Object.assign(Pass.prototype, {
  setSize: function ()
  /* width, height */
  {},
  render: function ()
  /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */
  {
    console.error('THREE.Pass: .render() must be implemented in derived pass.');
  }
}); // Helper for passes that need to fill the viewport with a single quad.

Pass.FullScreenQuad = function () {
  var camera = new _threeModule.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  var geometry = new _threeModule.PlaneBufferGeometry(2, 2);

  var FullScreenQuad = function (material) {
    this._mesh = new _threeModule.Mesh(geometry, material);
  };

  Object.defineProperty(FullScreenQuad.prototype, 'material', {
    get: function () {
      return this._mesh.material;
    },
    set: function (value) {
      this._mesh.material = value;
    }
  });
  Object.assign(FullScreenQuad.prototype, {
    render: function (renderer) {
      renderer.render(this._mesh, camera);
    }
  });
  return FullScreenQuad;
}();
},{"../../../build/three.module.js":"../node_modules/three/build/three.module.js","../shaders/CopyShader.js":"../node_modules/three/examples/jsm/shaders/CopyShader.js","../postprocessing/ShaderPass.js":"../node_modules/three/examples/jsm/postprocessing/ShaderPass.js","../postprocessing/MaskPass.js":"../node_modules/three/examples/jsm/postprocessing/MaskPass.js"}],"../node_modules/three/examples/jsm/postprocessing/RenderPass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RenderPass = void 0;

var _Pass = require("../postprocessing/Pass.js");

/**
 * @author alteredq / http://alteredqualia.com/
 */
var RenderPass = function (scene, camera, overrideMaterial, clearColor, clearAlpha) {
  _Pass.Pass.call(this);

  this.scene = scene;
  this.camera = camera;
  this.overrideMaterial = overrideMaterial;
  this.clearColor = clearColor;
  this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;
  this.clear = true;
  this.clearDepth = false;
  this.needsSwap = false;
};

exports.RenderPass = RenderPass;
RenderPass.prototype = Object.assign(Object.create(_Pass.Pass.prototype), {
  constructor: RenderPass,
  render: function (renderer, writeBuffer, readBuffer
  /*, deltaTime, maskActive */
  ) {
    var oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    this.scene.overrideMaterial = this.overrideMaterial;
    var oldClearColor, oldClearAlpha;

    if (this.clearColor) {
      oldClearColor = renderer.getClearColor().getHex();
      oldClearAlpha = renderer.getClearAlpha();
      renderer.setClearColor(this.clearColor, this.clearAlpha);
    }

    if (this.clearDepth) {
      renderer.clearDepth();
    }

    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer); // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600

    if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    renderer.render(this.scene, this.camera);

    if (this.clearColor) {
      renderer.setClearColor(oldClearColor, oldClearAlpha);
    }

    this.scene.overrideMaterial = null;
    renderer.autoClear = oldAutoClear;
  }
});
},{"../postprocessing/Pass.js":"../node_modules/three/examples/jsm/postprocessing/Pass.js"}],"../node_modules/three/examples/jsm/shaders/FilmShader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilmShader = void 0;

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Film grain & scanlines shader
 *
 * - ported from HLSL to WebGL / GLSL
 * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html
 *
 * Screen Space Static Postprocessor
 *
 * Produces an analogue noise overlay similar to a film grain / TV static
 *
 * Original implementation and noise algorithm
 * Pat 'Hawthorne' Shearon
 *
 * Optimized scanlines + noise version with intensity scaling
 * Georg 'Leviathan' Steinrohder
 *
 * This version is provided under a Creative Commons Attribution 3.0 License
 * http://creativecommons.org/licenses/by/3.0/
 */
var FilmShader = {
  uniforms: {
    "tDiffuse": {
      value: null
    },
    "time": {
      value: 0.0
    },
    "nIntensity": {
      value: 0.5
    },
    "sIntensity": {
      value: 0.05
    },
    "sCount": {
      value: 4096
    },
    "grayscale": {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["#include <common>", // control parameter
  "uniform float time;", "uniform bool grayscale;", // noise effect intensity value (0 = no effect, 1 = full effect)
  "uniform float nIntensity;", // scanlines effect intensity value (0 = no effect, 1 = full effect)
  "uniform float sIntensity;", // scanlines effect count value (0 = no effect, 4096 = full effect)
  "uniform float sCount;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", // sample the source
  "vec4 cTextureScreen = texture2D( tDiffuse, vUv );", // make some noise
  "float dx = rand( vUv + time );", // add noise
  "vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );", // get us a sine and cosine
  "vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );", // add scanlines
  "cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;", // interpolate between source and result by intensity
  "cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );", // convert to grayscale if desired
  "if( grayscale ) {", "cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );", "}", "gl_FragColor =  vec4( cResult, cTextureScreen.a );", "}"].join("\n")
};
exports.FilmShader = FilmShader;
},{}],"../node_modules/three/examples/jsm/postprocessing/FilmPass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilmPass = void 0;

var _threeModule = require("../../../build/three.module.js");

var _Pass = require("../postprocessing/Pass.js");

var _FilmShader = require("../shaders/FilmShader.js");

/**
 * @author alteredq / http://alteredqualia.com/
 */
var FilmPass = function (noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale) {
  _Pass.Pass.call(this);

  if (_FilmShader.FilmShader === undefined) console.error("FilmPass relies on FilmShader");
  var shader = _FilmShader.FilmShader;
  this.uniforms = _threeModule.UniformsUtils.clone(shader.uniforms);
  this.material = new _threeModule.ShaderMaterial({
    uniforms: this.uniforms,
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader
  });
  if (grayscale !== undefined) this.uniforms.grayscale.value = grayscale;
  if (noiseIntensity !== undefined) this.uniforms.nIntensity.value = noiseIntensity;
  if (scanlinesIntensity !== undefined) this.uniforms.sIntensity.value = scanlinesIntensity;
  if (scanlinesCount !== undefined) this.uniforms.sCount.value = scanlinesCount;
  this.fsQuad = new _Pass.Pass.FullScreenQuad(this.material);
};

exports.FilmPass = FilmPass;
FilmPass.prototype = Object.assign(Object.create(_Pass.Pass.prototype), {
  constructor: FilmPass,
  render: function (renderer, writeBuffer, readBuffer, deltaTime
  /*, maskActive */
  ) {
    this.uniforms["tDiffuse"].value = readBuffer.texture;
    this.uniforms["time"].value += deltaTime;

    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear) renderer.clear();
      this.fsQuad.render(renderer);
    }
  }
});
},{"../../../build/three.module.js":"../node_modules/three/build/three.module.js","../postprocessing/Pass.js":"../node_modules/three/examples/jsm/postprocessing/Pass.js","../shaders/FilmShader.js":"../node_modules/three/examples/jsm/shaders/FilmShader.js"}],"../node_modules/three/examples/jsm/shaders/ConvolutionShader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConvolutionShader = void 0;

var _threeModule = require("../../../build/three.module.js");

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Convolution shader
 * ported from o3d sample to WebGL / GLSL
 * http://o3d.googlecode.com/svn/trunk/samples/convolution.html
 */
var ConvolutionShader = {
  defines: {
    "KERNEL_SIZE_FLOAT": "25.0",
    "KERNEL_SIZE_INT": "25"
  },
  uniforms: {
    "tDiffuse": {
      value: null
    },
    "uImageIncrement": {
      value: new _threeModule.Vector2(0.001953125, 0.0)
    },
    "cKernel": {
      value: []
    }
  },
  vertexShader: ["uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float cKernel[ KERNEL_SIZE_INT ];", "uniform sampler2D tDiffuse;", "uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "vec2 imageCoord = vUv;", "vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );", "for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {", "sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];", "imageCoord += uImageIncrement;", "}", "gl_FragColor = sum;", "}"].join("\n"),
  buildKernel: function (sigma) {
    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.
    function gauss(x, sigma) {
      return Math.exp(-(x * x) / (2.0 * sigma * sigma));
    }

    var i,
        values,
        sum,
        halfWidth,
        kMaxKernelSize = 25,
        kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;
    if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;
    halfWidth = (kernelSize - 1) * 0.5;
    values = new Array(kernelSize);
    sum = 0.0;

    for (i = 0; i < kernelSize; ++i) {
      values[i] = gauss(i - halfWidth, sigma);
      sum += values[i];
    } // normalize the kernel


    for (i = 0; i < kernelSize; ++i) values[i] /= sum;

    return values;
  }
};
exports.ConvolutionShader = ConvolutionShader;
},{"../../../build/three.module.js":"../node_modules/three/build/three.module.js"}],"../node_modules/three/examples/jsm/postprocessing/BloomPass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BloomPass = void 0;

var _threeModule = require("../../../build/three.module.js");

var _Pass = require("../postprocessing/Pass.js");

var _CopyShader = require("../shaders/CopyShader.js");

var _ConvolutionShader = require("../shaders/ConvolutionShader.js");

/**
 * @author alteredq / http://alteredqualia.com/
 */
var BloomPass = function (strength, kernelSize, sigma, resolution) {
  _Pass.Pass.call(this);

  strength = strength !== undefined ? strength : 1;
  kernelSize = kernelSize !== undefined ? kernelSize : 25;
  sigma = sigma !== undefined ? sigma : 4.0;
  resolution = resolution !== undefined ? resolution : 256; // render targets

  var pars = {
    minFilter: _threeModule.LinearFilter,
    magFilter: _threeModule.LinearFilter,
    format: _threeModule.RGBAFormat
  };
  this.renderTargetX = new _threeModule.WebGLRenderTarget(resolution, resolution, pars);
  this.renderTargetX.texture.name = "BloomPass.x";
  this.renderTargetY = new _threeModule.WebGLRenderTarget(resolution, resolution, pars);
  this.renderTargetY.texture.name = "BloomPass.y"; // copy material

  if (_CopyShader.CopyShader === undefined) console.error("BloomPass relies on CopyShader");
  var copyShader = _CopyShader.CopyShader;
  this.copyUniforms = _threeModule.UniformsUtils.clone(copyShader.uniforms);
  this.copyUniforms["opacity"].value = strength;
  this.materialCopy = new _threeModule.ShaderMaterial({
    uniforms: this.copyUniforms,
    vertexShader: copyShader.vertexShader,
    fragmentShader: copyShader.fragmentShader,
    blending: _threeModule.AdditiveBlending,
    transparent: true
  }); // convolution material

  if (_ConvolutionShader.ConvolutionShader === undefined) console.error("BloomPass relies on ConvolutionShader");
  var convolutionShader = _ConvolutionShader.ConvolutionShader;
  this.convolutionUniforms = _threeModule.UniformsUtils.clone(convolutionShader.uniforms);
  this.convolutionUniforms["uImageIncrement"].value = BloomPass.blurX;
  this.convolutionUniforms["cKernel"].value = _ConvolutionShader.ConvolutionShader.buildKernel(sigma);
  this.materialConvolution = new _threeModule.ShaderMaterial({
    uniforms: this.convolutionUniforms,
    vertexShader: convolutionShader.vertexShader,
    fragmentShader: convolutionShader.fragmentShader,
    defines: {
      "KERNEL_SIZE_FLOAT": kernelSize.toFixed(1),
      "KERNEL_SIZE_INT": kernelSize.toFixed(0)
    }
  });
  this.needsSwap = false;
  this.fsQuad = new _Pass.Pass.FullScreenQuad(null);
};

exports.BloomPass = BloomPass;
BloomPass.prototype = Object.assign(Object.create(_Pass.Pass.prototype), {
  constructor: BloomPass,
  render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render quad with blured scene into texture (convolution pass 1)

    this.fsQuad.material = this.materialConvolution;
    this.convolutionUniforms["tDiffuse"].value = readBuffer.texture;
    this.convolutionUniforms["uImageIncrement"].value = BloomPass.blurX;
    renderer.setRenderTarget(this.renderTargetX);
    renderer.clear();
    this.fsQuad.render(renderer); // Render quad with blured scene into texture (convolution pass 2)

    this.convolutionUniforms["tDiffuse"].value = this.renderTargetX.texture;
    this.convolutionUniforms["uImageIncrement"].value = BloomPass.blurY;
    renderer.setRenderTarget(this.renderTargetY);
    renderer.clear();
    this.fsQuad.render(renderer); // Render original scene with superimposed blur to texture

    this.fsQuad.material = this.materialCopy;
    this.copyUniforms["tDiffuse"].value = this.renderTargetY.texture;
    if (maskActive) renderer.state.buffers.stencil.setTest(true);
    renderer.setRenderTarget(readBuffer);
    if (this.clear) renderer.clear();
    this.fsQuad.render(renderer);
  }
});
BloomPass.blurX = new _threeModule.Vector2(0.001953125, 0.0);
BloomPass.blurY = new _threeModule.Vector2(0.0, 0.001953125);
},{"../../../build/three.module.js":"../node_modules/three/build/three.module.js","../postprocessing/Pass.js":"../node_modules/three/examples/jsm/postprocessing/Pass.js","../shaders/CopyShader.js":"../node_modules/three/examples/jsm/shaders/CopyShader.js","../shaders/ConvolutionShader.js":"../node_modules/three/examples/jsm/shaders/ConvolutionShader.js"}],"../node_modules/three/examples/jsm/shaders/DigitalGlitch.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DigitalGlitch = void 0;

/**
 * @author felixturner / http://airtight.cc/
 *
 * RGB Shift Shader
 * Shifts red and blue channels from center in opposite directions
 * Ported from http://kriss.cx/tom/2009/05/rgb-shift/
 * by Tom Butterworth / http://kriss.cx/tom/
 *
 * amount: shift distance (1 is width of input)
 * angle: shift angle in radians
 */
var DigitalGlitch = {
  uniforms: {
    "tDiffuse": {
      value: null
    },
    //diffuse texture
    "tDisp": {
      value: null
    },
    //displacement texture for digital glitch squares
    "byp": {
      value: 0
    },
    //apply the glitch ?
    "amount": {
      value: 0.08
    },
    "angle": {
      value: 0.02
    },
    "seed": {
      value: 0.02
    },
    "seed_x": {
      value: 0.02
    },
    //-1,1
    "seed_y": {
      value: 0.02
    },
    //-1,1
    "distortion_x": {
      value: 0.5
    },
    "distortion_y": {
      value: 0.6
    },
    "col_s": {
      value: 0.05
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform int byp;", //should we apply the glitch ?
  "uniform sampler2D tDiffuse;", "uniform sampler2D tDisp;", "uniform float amount;", "uniform float angle;", "uniform float seed;", "uniform float seed_x;", "uniform float seed_y;", "uniform float distortion_x;", "uniform float distortion_y;", "uniform float col_s;", "varying vec2 vUv;", "float rand(vec2 co){", "return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);", "}", "void main() {", "if(byp<1) {", "vec2 p = vUv;", "float xs = floor(gl_FragCoord.x / 0.5);", "float ys = floor(gl_FragCoord.y / 0.5);", //based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch
  "vec4 normal = texture2D (tDisp, p*seed*seed);", "if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {", "if(seed_x>0.){", "p.y = 1. - (p.y + distortion_y);", "}", "else {", "p.y = distortion_y;", "}", "}", "if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {", "if(seed_y>0.){", "p.x=distortion_x;", "}", "else {", "p.x = 1. - (p.x + distortion_x);", "}", "}", "p.x+=normal.x*seed_x*(seed/5.);", "p.y+=normal.y*seed_y*(seed/5.);", //base from RGB shift shader
  "vec2 offset = amount * vec2( cos(angle), sin(angle));", "vec4 cr = texture2D(tDiffuse, p + offset);", "vec4 cga = texture2D(tDiffuse, p);", "vec4 cb = texture2D(tDiffuse, p - offset);", "gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);", //add noise
  "vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);", "gl_FragColor = gl_FragColor+ snow;", "}", "else {", "gl_FragColor=texture2D (tDiffuse, vUv);", "}", "}"].join("\n")
};
exports.DigitalGlitch = DigitalGlitch;
},{}],"../node_modules/three/examples/jsm/postprocessing/GlitchPass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GlitchPass = void 0;

var _threeModule = require("../../../build/three.module.js");

var _Pass = require("../postprocessing/Pass.js");

var _DigitalGlitch = require("../shaders/DigitalGlitch.js");

/**
 * @author alteredq / http://alteredqualia.com/
 */
var GlitchPass = function (dt_size) {
  _Pass.Pass.call(this);

  if (_DigitalGlitch.DigitalGlitch === undefined) console.error("GlitchPass relies on DigitalGlitch");
  var shader = _DigitalGlitch.DigitalGlitch;
  this.uniforms = _threeModule.UniformsUtils.clone(shader.uniforms);
  if (dt_size == undefined) dt_size = 64;
  this.uniforms["tDisp"].value = this.generateHeightmap(dt_size);
  this.material = new _threeModule.ShaderMaterial({
    uniforms: this.uniforms,
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader
  });
  this.fsQuad = new _Pass.Pass.FullScreenQuad(this.material);
  this.goWild = false;
  this.curF = 0;
  this.generateTrigger();
};

exports.GlitchPass = GlitchPass;
GlitchPass.prototype = Object.assign(Object.create(_Pass.Pass.prototype), {
  constructor: GlitchPass,
  render: function (renderer, writeBuffer, readBuffer
  /*, deltaTime, maskActive */
  ) {
    this.uniforms["tDiffuse"].value = readBuffer.texture;
    this.uniforms['seed'].value = Math.random(); //default seeding

    this.uniforms['byp'].value = 0;

    if (this.curF % this.randX == 0 || this.goWild == true) {
      this.uniforms['amount'].value = Math.random() / 30;
      this.uniforms['angle'].value = _threeModule.Math.randFloat(-Math.PI, Math.PI);
      this.uniforms['seed_x'].value = _threeModule.Math.randFloat(-1, 1);
      this.uniforms['seed_y'].value = _threeModule.Math.randFloat(-1, 1);
      this.uniforms['distortion_x'].value = _threeModule.Math.randFloat(0, 1);
      this.uniforms['distortion_y'].value = _threeModule.Math.randFloat(0, 1);
      this.curF = 0;
      this.generateTrigger();
    } else if (this.curF % this.randX < this.randX / 5) {
      this.uniforms['amount'].value = Math.random() / 90;
      this.uniforms['angle'].value = _threeModule.Math.randFloat(-Math.PI, Math.PI);
      this.uniforms['distortion_x'].value = _threeModule.Math.randFloat(0, 1);
      this.uniforms['distortion_y'].value = _threeModule.Math.randFloat(0, 1);
      this.uniforms['seed_x'].value = _threeModule.Math.randFloat(-0.3, 0.3);
      this.uniforms['seed_y'].value = _threeModule.Math.randFloat(-0.3, 0.3);
    } else if (this.goWild == false) {
      this.uniforms['byp'].value = 1;
    }

    this.curF++;

    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear) renderer.clear();
      this.fsQuad.render(renderer);
    }
  },
  generateTrigger: function () {
    this.randX = _threeModule.Math.randInt(120, 240);
  },
  generateHeightmap: function (dt_size) {
    var data_arr = new Float32Array(dt_size * dt_size * 3);
    var length = dt_size * dt_size;

    for (var i = 0; i < length; i++) {
      var val = _threeModule.Math.randFloat(0, 1);

      data_arr[i * 3 + 0] = val;
      data_arr[i * 3 + 1] = val;
      data_arr[i * 3 + 2] = val;
    }

    var texture = new _threeModule.DataTexture(data_arr, dt_size, dt_size, _threeModule.RGBFormat, _threeModule.FloatType);
    texture.needsUpdate = true;
    return texture;
  }
});
},{"../../../build/three.module.js":"../node_modules/three/build/three.module.js","../postprocessing/Pass.js":"../node_modules/three/examples/jsm/postprocessing/Pass.js","../shaders/DigitalGlitch.js":"../node_modules/three/examples/jsm/shaders/DigitalGlitch.js"}],"js/utils/engine3d.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rafLoop = _interopRequireDefault(require("raf-loop"));

var _three = require("three");

var _OrbitControls = require("three/examples/jsm/controls/OrbitControls");

var _EffectComposer = require("three/examples/jsm/postprocessing/EffectComposer");

var _RenderPass = require("three/examples/jsm/postprocessing/RenderPass");

var _FilmPass = require("three/examples/jsm/postprocessing/FilmPass");

var _BloomPass = require("three/examples/jsm/postprocessing/BloomPass");

var _GlitchPass = require("three/examples/jsm/postprocessing/GlitchPass");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DEFAULTS = {
  debug: false,
  width: 480,
  height: 480,
  pixelRatio: window.devicePixelRatio,
  clickToggleDebug: true,
  postProcessing: false
};
var RENDERER_DEFAULTS = {
  alpha: false
};

var SketchEngine3D =
/*#__PURE__*/
function () {
  function SketchEngine3D(mountEl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var rendererOpts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, SketchEngine3D);

    this.options = _objectSpread({}, DEFAULTS, {}, opts);
    this.rendererOptions = _objectSpread({}, RENDERER_DEFAULTS, {}, rendererOpts);
    this.mountEl = mountEl;
    this.scene = new _three.Scene();
    this.renderer = new _three.WebGLRenderer(this.rendererOptions);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = _three.PCFSoftShadowMap;
    this.updateDimensions(this.options.width, this.options.height, this.options.pixelRatio);
    this.mountEl.appendChild(this.renderer.domElement);
    this.frame = 0;
    this.loop = (0, _rafLoop.default)(this.update.bind(this));

    this._renderer = function () {};
  }

  _createClass(SketchEngine3D, [{
    key: "setCamera",
    value: function setCamera(camera) {
      var orbitControls = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref$autoRotate = _ref.autoRotate,
          autoRotate = _ref$autoRotate === void 0 ? false : _ref$autoRotate,
          _ref$enableZoom = _ref.enableZoom,
          enableZoom = _ref$enableZoom === void 0 ? false : _ref$enableZoom;

      this.camera = camera;

      if (orbitControls) {
        this.orbit = new _OrbitControls.OrbitControls(this.camera, this.renderer.domElement);
        this.orbit.autoRotate = autoRotate;
        this.orbit.enableZoom = enableZoom; // this.orbit.enabled = false;
      } else {
        this.orbit = null;
      }

      if (this.options.postProcessing) {
        this.addPostProcessing();
      }
    }
  }, {
    key: "addPostProcessing",
    value: function addPostProcessing() {
      this.composer = new _EffectComposer.EffectComposer(this.renderer);
      this.renderScene = new _RenderPass.RenderPass(this.scene, this.camera);
      this.composer.addPass(this.renderScene);
      this.bloomPass = new _BloomPass.BloomPass(3, // strength
      50, // kernel size
      1, // sigma ?
      1000);
      this.composer.addPass(this.bloomPass);
      this.filmPass = new _FilmPass.FilmPass(5, // noise intensity
      1, // scanline intensity
      1000, // scanline count
      false);
      this.composer.addPass(this.filmPass);
    }
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      var _this = this;

      this.mountEl.addEventListener('click', function () {
        _this.options.debug = !_this.options.debug;
        document.body.classList.toggle('debug', _this.options.debug);
      }, false);
    }
  }, {
    key: "updateDimensions",
    value: function updateDimensions(width, height, pixelRatio) {
      this.mountEl.style.width = "".concat(width, "px");
      this.mountEl.style.height = "".concat(height, "px");
      this.renderer.setSize(width, height);
      this.renderer.setPixelRatio(pixelRatio);
    }
  }, {
    key: "onRender",
    value: function onRender() {
      var fn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
      this._renderer = fn;
    }
  }, {
    key: "start",
    value: function start() {
      this.loop.start();
    }
  }, {
    key: "update",
    value: function update(dt) {
      if (!this.camera) {
        console.log("There is no camera");
        return false;
      }

      this._renderer({
        debug: this.options.debug,
        frame: this.frame,
        deltaTime: dt,
        width: this.options.width,
        height: this.options.height
      });

      if (this.orbit) {
        this.orbit.update();
      }

      if (this.options.postProcessing) {
        this.composer.render();
      } else {
        this.renderer.render(this.scene, this.camera);
      }

      this.frame++;
    }
  }, {
    key: "stop",
    value: function stop() {
      this.loop.stop();
    }
  }], [{
    key: "ORTHOPGRAPHIC_CAMERA",
    value: function ORTHOPGRAPHIC_CAMERA(width, height) {
      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref2$near = _ref2.near,
          near = _ref2$near === void 0 ? 1 : _ref2$near,
          _ref2$far = _ref2.far,
          far = _ref2$far === void 0 ? 1000 : _ref2$far;

      var camera = new _three.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, near, far);
      camera.position.z = 500;
      camera.zoom = 50;
      camera.updateProjectionMatrix();
      return camera;
    }
  }, {
    key: "PERSPECTIVE_CAMERA",
    value: function PERSPECTIVE_CAMERA(width, height) {
      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref3$fov = _ref3.fov,
          fov = _ref3$fov === void 0 ? 45 : _ref3$fov,
          _ref3$near = _ref3.near,
          near = _ref3$near === void 0 ? 1 : _ref3$near,
          _ref3$far = _ref3.far,
          far = _ref3$far === void 0 ? 1000 : _ref3$far;

      var camera = new _three.PerspectiveCamera(fov, width / height, near, far);
      camera.position.z = 15;
      return camera;
    }
  }]);

  return SketchEngine3D;
}();

var _default = SketchEngine3D;
exports.default = _default;
},{"raf-loop":"../node_modules/raf-loop/index.js","three":"../node_modules/three/build/three.module.js","three/examples/jsm/controls/OrbitControls":"../node_modules/three/examples/jsm/controls/OrbitControls.js","three/examples/jsm/postprocessing/EffectComposer":"../node_modules/three/examples/jsm/postprocessing/EffectComposer.js","three/examples/jsm/postprocessing/RenderPass":"../node_modules/three/examples/jsm/postprocessing/RenderPass.js","three/examples/jsm/postprocessing/FilmPass":"../node_modules/three/examples/jsm/postprocessing/FilmPass.js","three/examples/jsm/postprocessing/BloomPass":"../node_modules/three/examples/jsm/postprocessing/BloomPass.js","three/examples/jsm/postprocessing/GlitchPass":"../node_modules/three/examples/jsm/postprocessing/GlitchPass.js"}],"js/utils/paths.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPointOnArc = exports.arcPath = exports.circlePath = exports.rectPath = exports.getPointOnLinePath = exports.linePath = exports.cubicBezierPath = exports.getPointOnCubicBezier = exports.quadraticBezierPath = exports.getPointOnQuadraticBezier = void 0;

var getPointOnQuadraticBezier = function getPointOnQuadraticBezier(t, p0, p1, p2) {
  var invT = 1 - t;
  return {
    x: invT * invT * p0.x + 2 * invT * t * p1.x + t * t * p2.x,
    y: invT * invT * p0.y + 2 * invT * t * p1.y + t * t * p2.y
  };
};

exports.getPointOnQuadraticBezier = getPointOnQuadraticBezier;

var quadraticBezierPath = function quadraticBezierPath(p1, cp1, p2) {
  var segments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 50;
  var angleSegment = 1 / segments;
  var line = [];

  for (var i = 0; i < segments; i++) {
    var t = angleSegment * i;
    line.push(getPointOnQuadraticBezier(t, p1, cp1, p2));
  }

  return line;
};

exports.quadraticBezierPath = quadraticBezierPath;

var getPointOnCubicBezier = function getPointOnCubicBezier(t, p0, p1, p2, p3) {
  return {
    x: Math.pow(1 - t, 3) * p0.x + 3 * Math.pow(1 - t, 2) * t * p1.x + 3 * (1 - t) * Math.pow(t, 2) * p2.x + Math.pow(t, 3) * p3.x,
    y: Math.pow(1 - t, 3) * p0.y + 3 * Math.pow(1 - t, 2) * t * p1.y + 3 * (1 - t) * Math.pow(t, 2) * p2.y + Math.pow(t, 3) * p3.y
  };
};

exports.getPointOnCubicBezier = getPointOnCubicBezier;

var cubicBezierPath = function cubicBezierPath(p1, cp1, cp2, p2) {
  var segments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 50;
  var angleSegment = 1 / segments;
  var line = [];

  for (var i = 0; i < segments; i++) {
    var t = angleSegment * i;
    line.push(getPointOnCubicBezier(t, p1, cp1, cp2, p2));
  }

  return line;
};

exports.cubicBezierPath = cubicBezierPath;

var linePath = function linePath(p1, p2) {
  var segments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 50;
  var slice = 1 / segments;
  var line = [];

  for (var i = 0; i < segments; i++) {
    var t = slice * i;
    line.push(getPointOnLinePath(t, p1, p2));
  }

  return line;
};

exports.linePath = linePath;

var getPointOnLinePath = function getPointOnLinePath(t, p1, p2) {
  return {
    x: p1.x + (p2.x - p1.x) * t,
    y: p1.y + (p2.y - p1.y) * t
  };
};

exports.getPointOnLinePath = getPointOnLinePath;

var rectPath = function rectPath(tlx, tly, width, height) {
  return [{
    x: tlx,
    y: tly
  }, {
    x: tlx + width,
    y: tly
  }, {
    x: tlx + width,
    y: tly + height
  }, {
    x: tlx,
    y: tly + height
  }];
};

exports.rectPath = rectPath;

var circlePath = function circlePath(cx, cy, radius) {
  var segments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 50;
  var startingAngle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  return arcPath(cx, cy, radius, Math.PI * 2, segments, startingAngle);
};

exports.circlePath = circlePath;

var arcPath = function arcPath(cx, cy, radius, angle) {
  var segments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 50;
  var startingAngle = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
  var angleSegment = angle / segments;
  var angleOffset = startingAngle;
  var path = [];

  for (var i = 0; i < segments; i++) {
    path.push(getPointOnArc(cx, cy, angleOffset + angleSegment * i, radius));
  }

  return path;
};

exports.arcPath = arcPath;

var getPointOnArc = function getPointOnArc(cx, cy, angle, radius) {
  return {
    x: cx + Math.cos(angle) * radius,
    y: cy + Math.sin(angle) * radius
  };
};

exports.getPointOnArc = getPointOnArc;
},{}],"js/data/Raleway_Medium_Regular.json":[function(require,module,exports) {
module.exports = {
  "glyphs": {
    "0": {
      "ha": 853,
      "x_min": 75,
      "x_max": 778,
      "o": "m 778 407 q 751 238 778 315 q 678 105 725 161 q 566 17 631 49 q 426 -14 501 -14 q 285 17 350 -14 q 174 105 221 49 q 101 238 128 161 q 75 407 75 315 q 101 576 75 499 q 174 709 128 653 q 285 797 221 765 q 426 829 350 829 q 566 797 501 829 q 678 709 631 765 q 751 576 725 653 q 778 407 778 499 m 654 407 q 638 532 654 475 q 590 630 621 589 q 518 693 560 671 q 426 715 476 715 q 333 693 375 715 q 260 630 290 671 q 214 532 231 589 q 197 407 197 475 q 214 281 197 338 q 260 185 231 225 q 333 122 290 144 q 426 100 375 100 q 518 122 476 100 q 590 185 560 144 q 638 281 621 225 q 654 407 654 338 z "
    },
    "1": {
      "ha": 625,
      "x_min": 64,
      "x_max": 592,
      "o": "m 592 111 l 592 0 l 93 0 l 93 111 l 290 111 l 290 653 q 251 617 278 636 q 192 583 225 599 q 125 556 160 567 q 64 544 90 544 l 64 661 q 132 678 94 661 q 203 719 169 696 q 262 763 238 742 q 290 793 286 785 l 415 793 l 415 111 l 592 111 z "
    },
    "2": {
      "ha": 743,
      "x_min": 60,
      "x_max": 678,
      "o": "m 60 0 q 69 104 60 56 q 103 197 78 153 q 172 282 128 242 q 286 363 215 322 q 371 406 328 385 q 449 452 414 428 q 508 504 485 476 q 531 569 531 532 q 519 617 531 593 q 488 658 508 640 q 435 688 467 676 q 364 699 404 699 q 288 687 322 699 q 228 658 254 675 q 182 621 201 640 q 150 586 163 601 l 71 675 q 108 709 82 688 q 175 753 135 731 q 268 791 215 775 q 386 807 321 807 q 501 790 450 807 q 588 742 553 772 q 643 670 624 711 q 663 583 663 629 q 639 489 663 529 q 581 418 615 449 q 508 366 547 388 q 439 329 469 344 q 370 292 408 314 q 297 244 332 271 q 237 183 263 217 q 204 111 211 150 l 678 111 l 678 0 l 60 0 z "
    },
    "3": {
      "ha": 750,
      "x_min": 49,
      "x_max": 690,
      "o": "m 497 328 q 638 246 586 313 q 690 81 690 179 q 667 -36 690 17 q 599 -126 643 -89 q 494 -184 556 -164 q 358 -204 433 -204 q 173 -165 253 -204 q 49 -53 93 -125 l 131 29 q 217 -60 163 -28 q 358 -93 271 -93 q 509 -50 454 -93 q 564 81 564 -7 q 505 220 564 168 q 333 272 446 272 l 297 272 l 297 375 l 336 375 q 490 423 436 375 q 543 544 543 471 q 492 654 543 618 q 363 690 440 690 q 228 658 286 690 q 139 567 171 625 l 64 644 q 113 708 82 679 q 185 757 144 736 q 274 789 226 778 q 375 800 322 800 q 495 782 440 800 q 590 732 550 764 q 651 654 629 700 q 672 553 672 608 q 660 474 672 511 q 626 406 649 436 q 570 355 603 375 q 497 328 538 335 z "
    },
    "4": {
      "ha": 775,
      "x_min": 33,
      "x_max": 724,
      "o": "m 479 -176 l 479 58 l 33 58 l 33 167 l 518 793 l 601 793 l 601 169 l 724 169 l 724 58 l 601 58 l 601 -176 l 479 -176 m 160 169 l 492 169 l 492 604 l 160 169 z "
    },
    "5": {
      "ha": 761,
      "x_min": 46,
      "x_max": 713,
      "o": "m 390 436 q 517 413 458 436 q 619 349 576 390 q 688 249 663 307 q 713 121 713 190 q 685 -13 713 47 q 611 -117 658 -74 q 500 -183 564 -160 q 364 -207 436 -207 q 174 -157 258 -207 q 46 -24 89 -107 l 122 43 q 226 -60 161 -21 q 365 -99 290 -99 q 453 -83 413 -99 q 524 -38 494 -67 q 571 31 554 -10 q 588 119 588 71 q 571 204 588 165 q 526 271 554 243 q 458 314 497 299 q 375 329 419 329 q 263 303 315 329 q 178 228 211 276 l 68 228 q 75 263 69 235 q 89 333 81 292 q 107 424 97 374 q 126 525 117 474 q 179 793 150 644 l 658 793 l 658 681 l 269 681 l 210 367 q 286 417 240 399 q 390 436 332 436 z "
    },
    "6": {
      "ha": 842,
      "x_min": 71,
      "x_max": 781,
      "o": "m 781 326 q 753 194 781 256 q 678 85 726 132 q 567 13 631 39 q 428 -14 503 -14 q 283 15 349 -14 q 169 99 217 44 q 97 233 122 154 q 71 411 71 311 q 97 666 71 557 q 172 848 124 775 q 289 957 221 921 q 440 993 357 993 q 615 947 536 993 q 738 818 693 901 l 663 744 q 572 848 632 810 q 439 886 513 886 q 336 860 382 886 q 257 785 290 835 q 206 663 224 735 q 186 500 188 592 q 285 615 217 572 q 440 658 353 658 q 574 633 511 658 q 682 562 636 607 q 754 456 728 517 q 781 326 781 396 m 429 92 q 519 110 476 92 q 594 161 563 129 q 645 235 626 193 q 664 326 664 278 q 645 417 664 374 q 594 491 626 460 q 519 541 563 522 q 429 560 476 560 q 338 541 381 560 q 264 491 296 522 q 213 417 232 460 q 194 326 194 374 q 213 235 194 278 q 264 161 232 193 q 338 110 296 129 q 429 92 381 92 z "
    },
    "7": {
      "ha": 743,
      "x_min": 38,
      "x_max": 738,
      "o": "m 544 697 l 38 697 l 38 810 l 738 810 l 242 -176 l 103 -176 l 544 697 z "
    },
    "8": {
      "ha": 831,
      "x_min": 68,
      "x_max": 763,
      "o": "m 763 279 q 734 159 763 213 q 658 68 706 106 q 547 10 610 31 q 413 -11 483 -11 q 276 12 339 -11 q 167 74 213 35 q 94 168 121 114 q 68 285 68 222 q 85 369 68 331 q 127 439 101 408 q 186 492 153 469 q 253 528 219 515 q 194 560 222 540 q 146 606 167 581 q 113 663 125 632 q 101 728 101 693 q 130 838 101 790 q 203 919 158 886 q 304 969 249 953 q 415 986 360 986 q 527 969 471 986 q 628 920 583 953 q 702 840 674 888 q 731 729 731 792 q 685 607 731 660 q 576 528 639 554 q 648 489 614 513 q 707 434 682 465 q 747 364 732 403 q 763 279 763 325 m 639 288 q 619 367 639 332 q 567 427 599 403 q 494 464 535 451 q 414 476 454 476 q 333 463 372 476 q 262 425 293 450 q 212 365 231 400 q 193 286 193 329 q 213 207 193 242 q 265 149 233 172 q 337 112 297 125 q 417 99 376 99 q 498 113 458 99 q 569 151 538 126 q 619 211 600 176 q 639 288 639 246 m 225 724 q 242 658 225 686 q 288 610 260 629 q 349 581 315 590 q 415 571 382 571 q 482 581 449 571 q 543 611 515 592 q 588 660 571 631 q 606 726 606 689 q 590 789 606 761 q 547 836 574 817 q 486 866 521 856 q 414 876 451 876 q 342 866 376 876 q 283 835 308 856 q 241 787 257 815 q 225 724 225 758 z "
    },
    "9": {
      "ha": 818,
      "x_min": 50,
      "x_max": 760,
      "o": "m 50 453 q 77 585 50 524 q 152 694 104 647 q 264 767 200 740 q 403 793 328 793 q 548 764 482 793 q 661 680 614 735 q 734 547 708 625 q 760 368 760 468 q 733 113 760 222 q 658 -69 707 4 q 542 -178 610 -142 q 390 -214 474 -214 q 216 -168 294 -214 q 93 -39 138 -122 l 168 35 q 258 -69 199 -31 q 392 -107 318 -107 q 574 -6 506 -107 q 644 279 642 96 q 546 164 614 207 q 390 121 478 121 q 257 147 319 121 q 149 217 194 172 q 76 322 103 261 q 50 453 50 383 m 401 688 q 310 669 353 688 q 236 618 268 650 q 185 544 204 586 q 167 453 167 501 q 185 362 167 404 q 236 288 204 319 q 310 238 268 257 q 401 219 353 219 q 492 238 450 219 q 567 288 535 257 q 617 362 599 319 q 636 453 636 404 q 617 543 636 500 q 567 618 599 586 q 492 669 535 650 q 401 688 449 688 z "
    },
    " ": {
      "ha": 351,
      "x_min": 0,
      "x_max": 0,
      "o": ""
    },
    "Ǽ": {
      "ha": 1335,
      "x_min": -35,
      "x_max": 1285,
      "o": "m 760 1104 l 679 1132 l 760 1272 l 882 1272 l 760 1104 m 594 986 l 1272 986 l 1272 875 l 751 875 l 751 558 l 1197 558 l 1197 447 l 751 447 l 751 111 l 1285 111 l 1285 0 l 628 0 l 628 289 l 282 289 l 101 0 l -35 0 l 594 986 m 619 400 l 619 840 l 338 400 l 619 400 z "
    },
    "´": {
      "ha": 322,
      "x_min": 67,
      "x_max": 269,
      "o": "m 147 846 l 67 874 l 147 1014 l 269 1014 l 147 846 z "
    },
    "Á": {
      "ha": 940,
      "x_min": 14,
      "x_max": 926,
      "o": "m 418 986 l 524 986 l 926 0 l 793 0 l 676 289 l 263 289 l 147 0 l 14 0 l 418 986 m 649 386 l 471 842 l 288 386 l 649 386 m 492 1104 l 411 1132 l 492 1272 l 614 1272 l 492 1104 z "
    },
    "Ă": {
      "ha": 940,
      "x_min": 14,
      "x_max": 926,
      "o": "m 418 986 l 524 986 l 926 0 l 793 0 l 676 289 l 263 289 l 147 0 l 14 0 l 418 986 m 649 386 l 471 842 l 288 386 l 649 386 m 471 1178 q 524 1205 501 1178 q 551 1272 547 1232 l 621 1272 q 609 1211 621 1239 q 577 1163 597 1183 q 530 1130 557 1142 q 471 1118 503 1118 q 412 1130 439 1118 q 365 1163 385 1142 q 333 1211 344 1183 q 321 1272 321 1239 l 392 1272 q 415 1206 392 1235 q 471 1178 439 1178 z "
    },
    "˘": {
      "ha": 411,
      "x_min": 56,
      "x_max": 356,
      "o": "m 206 919 q 259 947 236 919 q 286 1014 282 974 l 356 1014 q 344 953 356 981 q 312 904 332 925 q 265 872 292 883 q 206 860 238 860 q 147 872 174 860 q 99 904 119 883 q 67 953 79 925 q 56 1014 56 981 l 126 1014 q 150 948 126 976 q 206 919 174 919 z "
    },
    "Â": {
      "ha": 940,
      "x_min": 14,
      "x_max": 926,
      "o": "m 418 986 l 524 986 l 926 0 l 793 0 l 676 289 l 263 289 l 147 0 l 14 0 l 418 986 m 649 386 l 471 842 l 288 386 l 649 386 m 286 1147 l 426 1272 l 515 1272 l 656 1147 l 589 1114 l 471 1201 l 353 1114 l 286 1147 z "
    },
    "ˆ": {
      "ha": 475,
      "x_min": 53,
      "x_max": 422,
      "o": "m 53 889 l 193 1014 l 282 1014 l 422 889 l 356 856 l 238 943 l 119 856 l 53 889 z "
    },
    "Ä": {
      "ha": 940,
      "x_min": 14,
      "x_max": 926,
      "o": "m 418 986 l 524 986 l 926 0 l 793 0 l 676 289 l 263 289 l 147 0 l 14 0 l 418 986 m 649 386 l 471 842 l 288 386 l 649 386 m 307 1126 l 307 1268 l 410 1268 l 410 1126 l 307 1126 m 532 1126 l 532 1268 l 635 1268 l 635 1126 l 532 1126 z "
    },
    "¨": {
      "ha": 511,
      "x_min": 92,
      "x_max": 419,
      "o": "m 92 867 l 92 1008 l 194 1008 l 194 867 l 92 867 m 317 867 l 317 1008 l 419 1008 l 419 867 l 317 867 z "
    },
    "À": {
      "ha": 940,
      "x_min": 14,
      "x_max": 926,
      "o": "m 418 986 l 524 986 l 926 0 l 793 0 l 676 289 l 263 289 l 147 0 l 14 0 l 418 986 m 649 386 l 471 842 l 288 386 l 649 386 m 326 1274 l 447 1274 l 529 1133 l 450 1106 l 326 1274 z "
    },
    "`": {
      "ha": 322,
      "x_min": 67,
      "x_max": 269,
      "o": "m 67 1014 l 188 1014 l 269 874 l 190 846 l 67 1014 z "
    },
    "Ā": {
      "ha": 940,
      "x_min": 14,
      "x_max": 926,
      "o": "m 418 986 l 524 986 l 926 0 l 793 0 l 676 289 l 263 289 l 147 0 l 14 0 l 418 986 m 649 386 l 471 842 l 288 386 l 649 386 m 268 1167 l 268 1247 l 674 1247 l 674 1167 l 268 1167 z "
    },
    "¯": {
      "ha": 560,
      "x_min": 78,
      "x_max": 483,
      "o": "m 78 908 l 78 989 l 483 989 l 483 908 l 78 908 z "
    },
    "Ą": {
      "ha": 939,
      "x_min": 14,
      "x_max": 926,
      "o": "m 858 -251 q 771 -212 800 -240 q 742 -144 742 -183 q 767 -72 742 -108 q 849 0 793 -36 l 793 0 l 676 289 l 263 289 l 147 0 l 14 0 l 418 986 l 524 986 l 926 0 q 839 -67 865 -37 q 813 -128 813 -97 q 889 -187 813 -179 l 858 -251 m 649 386 l 471 842 l 288 386 l 649 386 z "
    },
    "˛": {
      "ha": 354,
      "x_min": 81,
      "x_max": 265,
      "o": "m 197 -251 q 110 -212 139 -240 q 81 -144 81 -183 q 116 -61 81 -103 q 229 25 151 -19 l 265 0 q 178 -67 204 -37 q 151 -128 151 -97 q 228 -187 151 -179 l 197 -251 l 197 -251 z "
    },
    "Å": {
      "ha": 940,
      "x_min": 14,
      "x_max": 926,
      "o": "m 418 986 l 524 986 l 926 0 l 793 0 l 676 289 l 263 289 l 147 0 l 14 0 l 418 986 m 649 386 l 471 842 l 288 386 l 649 386 m 357 1176 q 389 1247 357 1221 q 469 1272 421 1272 q 551 1247 519 1272 q 582 1176 582 1221 q 551 1106 582 1132 q 469 1081 519 1081 q 389 1106 421 1081 q 357 1176 357 1132 m 469 1229 q 430 1215 446 1229 q 414 1176 414 1200 q 430 1139 414 1154 q 469 1124 446 1124 q 509 1138 492 1124 q 526 1176 526 1153 q 510 1215 526 1200 q 469 1229 493 1229 z "
    },
    "˚": {
      "ha": 350,
      "x_min": 63,
      "x_max": 288,
      "o": "m 63 918 q 94 988 63 963 q 175 1014 126 1014 q 256 988 225 1014 q 288 918 288 963 q 256 848 288 874 q 175 822 225 822 q 94 848 126 822 q 63 918 63 874 m 175 971 q 135 956 151 971 q 119 918 119 942 q 135 881 119 896 q 175 865 151 865 q 215 880 197 865 q 232 918 232 894 q 215 956 232 942 q 175 971 199 971 z "
    },
    "Ǻ": {
      "ha": 940,
      "x_min": 14,
      "x_max": 926,
      "o": "m 510 1129 q 563 1096 543 1119 q 582 1039 582 1072 q 569 990 582 1011 q 535 958 557 969 l 926 0 l 793 0 l 676 289 l 263 289 l 147 0 l 14 0 l 406 957 q 357 1039 357 983 q 380 1100 357 1075 q 439 1132 403 1125 l 500 1275 l 622 1275 l 510 1129 m 649 386 l 471 842 l 288 386 l 649 386 m 469 1092 q 430 1077 446 1092 q 414 1039 414 1063 q 430 1001 414 1017 q 469 986 446 986 q 509 1001 492 986 q 526 1039 526 1015 q 510 1077 526 1063 q 469 1092 493 1092 z "
    },
    "Ã": {
      "ha": 940,
      "x_min": 14,
      "x_max": 926,
      "o": "m 418 986 l 524 986 l 926 0 l 793 0 l 676 289 l 263 289 l 147 0 l 14 0 l 418 986 m 649 386 l 471 842 l 288 386 l 649 386 m 557 1129 q 502 1138 525 1129 q 459 1158 479 1147 q 419 1178 439 1169 q 378 1188 400 1188 q 341 1178 354 1188 q 321 1156 328 1168 q 312 1133 314 1144 q 310 1121 310 1122 l 238 1121 q 244 1153 238 1129 q 265 1201 250 1176 q 307 1245 281 1226 q 375 1264 333 1264 q 426 1255 404 1264 q 469 1234 449 1246 q 509 1213 489 1222 q 554 1204 529 1204 q 596 1214 581 1204 q 619 1236 611 1224 q 630 1259 628 1249 q 632 1272 632 1269 l 704 1272 q 698 1241 704 1264 q 675 1193 692 1218 q 630 1149 658 1168 q 557 1129 601 1129 z "
    },
    "˜": {
      "ha": 576,
      "x_min": 56,
      "x_max": 522,
      "o": "m 375 871 q 320 880 343 871 q 277 900 297 889 q 238 920 257 911 q 196 929 218 929 q 159 919 172 929 q 139 898 146 910 q 130 875 132 886 q 128 863 128 864 l 56 863 q 62 894 56 871 q 83 943 68 918 q 125 987 99 968 q 193 1006 151 1006 q 244 997 222 1006 q 287 976 267 988 q 327 955 307 964 q 372 946 347 946 q 414 956 399 946 q 438 978 429 965 q 448 1001 446 990 q 450 1014 450 1011 l 522 1014 q 516 983 522 1006 q 493 935 510 960 q 448 890 476 910 q 375 871 419 871 z "
    },
    "B": {
      "ha": 932,
      "x_min": 118,
      "x_max": 875,
      "o": "m 875 254 q 852 150 875 197 q 790 69 829 103 q 698 18 750 36 q 586 0 646 0 l 118 0 l 118 986 l 608 986 q 701 964 660 986 q 772 906 743 942 q 817 826 801 871 q 833 735 833 781 q 797 599 833 661 q 692 506 760 536 q 826 413 776 481 q 875 254 875 346 m 749 276 q 737 341 749 310 q 705 396 725 372 q 657 433 685 419 q 596 447 629 447 l 243 447 l 243 108 l 586 108 q 650 122 621 108 q 701 159 679 136 q 736 213 724 182 q 749 276 749 243 m 243 878 l 243 549 l 557 549 q 618 562 590 549 q 666 597 646 575 q 698 649 686 619 q 710 713 710 679 q 699 778 710 747 q 669 831 688 808 q 623 865 650 853 q 565 878 596 878 l 243 878 z "
    },
    "C": {
      "ha": 947,
      "x_min": 54,
      "x_max": 908,
      "o": "m 54 500 q 85 677 54 589 q 177 835 117 765 q 325 949 238 906 q 524 992 413 992 q 750 932 656 992 q 890 776 844 872 l 792 713 q 738 792 769 760 q 670 843 707 824 q 594 871 633 863 q 518 879 556 879 q 373 845 436 879 q 267 756 310 811 q 202 633 224 701 q 181 494 181 564 q 206 347 181 417 q 278 222 232 276 q 386 136 324 168 q 522 104 449 104 q 602 114 561 104 q 681 145 643 124 q 751 199 718 167 q 804 278 783 232 l 908 221 q 842 123 885 165 q 747 51 800 81 q 633 7 693 22 q 517 -8 574 -8 q 331 36 415 -8 q 184 152 246 81 q 88 315 122 224 q 54 500 54 406 z "
    },
    "Ć": {
      "ha": 947,
      "x_min": 54,
      "x_max": 908,
      "o": "m 543 1104 l 463 1132 l 543 1272 l 665 1272 l 543 1104 m 54 500 q 85 677 54 589 q 177 835 117 765 q 325 949 238 906 q 524 992 413 992 q 750 932 656 992 q 890 776 844 872 l 792 713 q 738 792 769 760 q 670 843 707 824 q 594 871 633 863 q 518 879 556 879 q 373 845 436 879 q 267 756 310 811 q 202 633 224 701 q 181 494 181 564 q 206 347 181 417 q 278 222 232 276 q 386 136 324 168 q 522 104 449 104 q 602 114 561 104 q 681 145 643 124 q 751 199 718 167 q 804 278 783 232 l 908 221 q 842 123 885 165 q 747 51 800 81 q 633 7 693 22 q 517 -8 574 -8 q 331 36 415 -8 q 184 152 246 81 q 88 315 122 224 q 54 500 54 406 z "
    },
    "Č": {
      "ha": 947,
      "x_min": 54,
      "x_max": 908,
      "o": "m 404 1272 l 522 1185 l 640 1272 l 707 1239 l 567 1114 l 478 1114 l 338 1239 l 404 1272 m 54 500 q 85 677 54 589 q 177 835 117 765 q 325 949 238 906 q 524 992 413 992 q 750 932 656 992 q 890 776 844 872 l 792 713 q 738 792 769 760 q 670 843 707 824 q 594 871 633 863 q 518 879 556 879 q 373 845 436 879 q 267 756 310 811 q 202 633 224 701 q 181 494 181 564 q 206 347 181 417 q 278 222 232 276 q 386 136 324 168 q 522 104 449 104 q 602 114 561 104 q 681 145 643 124 q 751 199 718 167 q 804 278 783 232 l 908 221 q 842 123 885 165 q 747 51 800 81 q 633 7 693 22 q 517 -8 574 -8 q 331 36 415 -8 q 184 152 246 81 q 88 315 122 224 q 54 500 54 406 z "
    },
    "ˇ": {
      "ha": 475,
      "x_min": 53,
      "x_max": 422,
      "o": "m 119 1014 l 238 926 l 356 1014 l 422 981 l 282 856 l 193 856 l 53 981 l 119 1014 z "
    },
    "Ç": {
      "ha": 943,
      "x_min": 50,
      "x_max": 904,
      "o": "m 406 -175 q 458 -193 424 -185 q 528 -201 492 -201 q 586 -190 565 -201 q 607 -153 607 -179 q 588 -115 607 -125 q 536 -104 568 -104 q 475 -110 507 -104 q 425 -122 443 -117 l 486 -7 q 310 44 390 -1 q 172 161 229 90 q 82 321 114 232 q 50 500 50 410 q 81 677 50 589 q 173 835 113 765 q 321 949 233 906 q 519 992 408 992 q 746 932 651 992 q 886 776 840 872 l 788 713 q 734 792 765 760 q 666 843 703 824 q 590 871 629 863 q 514 879 551 879 q 369 845 432 879 q 263 756 306 811 q 198 633 219 701 q 176 494 176 564 q 202 347 176 417 q 274 222 228 276 q 382 136 319 168 q 518 104 444 104 q 598 114 557 104 q 676 145 639 124 q 747 199 714 167 q 800 278 779 232 l 904 221 q 844 129 882 169 q 758 60 806 89 q 656 14 710 31 q 549 -7 603 -3 l 511 -67 q 536 -61 522 -62 q 561 -60 550 -60 q 640 -82 610 -60 q 671 -149 671 -104 q 632 -225 671 -197 q 518 -253 593 -253 q 441 -245 476 -253 q 378 -226 406 -237 l 406 -175 z "
    },
    "¸": {
      "ha": 411,
      "x_min": 31,
      "x_max": 324,
      "o": "m 58 -175 q 110 -193 76 -185 q 181 -201 144 -201 q 239 -190 218 -201 q 260 -153 260 -179 q 240 -115 260 -125 q 189 -104 221 -104 q 128 -110 160 -104 q 78 -122 96 -117 l 158 29 l 213 10 l 164 -67 q 189 -61 175 -62 q 214 -60 203 -60 q 293 -82 263 -60 q 324 -149 324 -104 q 285 -225 324 -197 q 171 -253 246 -253 q 94 -245 129 -253 q 31 -226 58 -237 l 58 -175 z "
    },
    "Ĉ": {
      "ha": 947,
      "x_min": 54,
      "x_max": 908,
      "o": "m 338 1147 l 478 1272 l 567 1272 l 707 1147 l 640 1114 l 522 1201 l 404 1114 l 338 1147 m 54 500 q 85 677 54 589 q 177 835 117 765 q 325 949 238 906 q 524 992 413 992 q 750 932 656 992 q 890 776 844 872 l 792 713 q 738 792 769 760 q 670 843 707 824 q 594 871 633 863 q 518 879 556 879 q 373 845 436 879 q 267 756 310 811 q 202 633 224 701 q 181 494 181 564 q 206 347 181 417 q 278 222 232 276 q 386 136 324 168 q 522 104 449 104 q 602 114 561 104 q 681 145 643 124 q 751 199 718 167 q 804 278 783 232 l 908 221 q 842 123 885 165 q 747 51 800 81 q 633 7 693 22 q 517 -8 574 -8 q 331 36 415 -8 q 184 152 246 81 q 88 315 122 224 q 54 500 54 406 z "
    },
    "Ċ": {
      "ha": 947,
      "x_min": 54,
      "x_max": 908,
      "o": "m 54 500 q 85 677 54 589 q 177 835 117 765 q 325 949 238 906 q 524 992 413 992 q 750 932 656 992 q 890 776 844 872 l 792 713 q 738 792 769 760 q 670 843 707 824 q 594 871 633 863 q 518 879 556 879 q 373 845 436 879 q 267 756 310 811 q 202 633 224 701 q 181 494 181 564 q 206 347 181 417 q 278 222 232 276 q 386 136 324 168 q 522 104 449 104 q 602 114 561 104 q 681 145 643 124 q 751 199 718 167 q 804 278 783 232 l 908 221 q 842 123 885 165 q 747 51 800 81 q 633 7 693 22 q 517 -8 574 -8 q 331 36 415 -8 q 184 152 246 81 q 88 315 122 224 q 54 500 54 406 m 467 1125 l 467 1272 l 578 1272 l 578 1125 l 467 1125 z "
    },
    "˙": {
      "ha": 250,
      "x_min": 69,
      "x_max": 181,
      "o": "m 69 867 l 69 1014 l 181 1014 l 181 867 l 69 867 z "
    },
    "D": {
      "ha": 994,
      "x_min": 118,
      "x_max": 936,
      "o": "m 118 0 l 118 986 l 460 986 q 667 947 578 986 q 817 842 757 908 q 906 685 876 775 q 936 494 936 596 q 903 291 936 382 q 807 135 869 200 q 656 35 744 71 q 460 0 568 0 l 118 0 m 810 494 q 787 648 810 578 q 719 768 764 718 q 608 847 674 818 q 460 875 543 875 l 243 875 l 243 111 l 460 111 q 610 140 544 111 q 720 221 676 169 q 787 342 764 272 q 810 494 810 413 z "
    },
    "Ď": {
      "ha": 994,
      "x_min": 118,
      "x_max": 936,
      "o": "m 354 1272 l 472 1185 l 590 1272 l 657 1239 l 517 1114 l 428 1114 l 288 1239 l 354 1272 m 118 0 l 118 986 l 460 986 q 667 947 578 986 q 817 842 757 908 q 906 685 876 775 q 936 494 936 596 q 903 291 936 382 q 807 135 869 200 q 656 35 744 71 q 460 0 568 0 l 118 0 m 810 494 q 787 648 810 578 q 719 768 764 718 q 608 847 674 818 q 460 875 543 875 l 243 875 l 243 111 l 460 111 q 610 140 544 111 q 720 221 676 169 q 787 342 764 272 q 810 494 810 413 z "
    },
    "Đ": {
      "ha": 1003,
      "x_min": 47,
      "x_max": 944,
      "o": "m 126 0 l 126 449 l 47 449 l 47 543 l 126 543 l 126 986 l 468 986 q 676 947 586 986 q 825 842 765 908 q 915 685 885 775 q 944 494 944 596 q 911 291 944 382 q 815 135 878 200 q 665 35 753 71 q 468 0 576 0 l 126 0 m 818 494 q 795 648 818 578 q 727 768 772 718 q 617 847 682 818 q 468 875 551 875 l 251 875 l 251 543 l 475 543 l 475 449 l 251 449 l 251 111 l 468 111 q 619 140 553 111 q 728 221 685 169 q 795 342 772 272 q 818 494 818 413 z "
    },
    "E": {
      "ha": 840,
      "x_min": 118,
      "x_max": 788,
      "o": "m 788 111 l 788 0 l 118 0 l 118 986 l 775 986 l 775 875 l 243 875 l 243 556 l 706 556 l 706 451 l 243 451 l 243 111 l 788 111 z "
    },
    "É": {
      "ha": 840,
      "x_min": 118,
      "x_max": 788,
      "o": "m 485 1104 l 404 1132 l 485 1272 l 607 1272 l 485 1104 m 788 111 l 788 0 l 118 0 l 118 986 l 775 986 l 775 875 l 243 875 l 243 556 l 706 556 l 706 451 l 243 451 l 243 111 l 788 111 z "
    },
    "Ĕ": {
      "ha": 840,
      "x_min": 118,
      "x_max": 788,
      "o": "m 788 111 l 788 0 l 118 0 l 118 986 l 775 986 l 775 875 l 243 875 l 243 556 l 706 556 l 706 451 l 243 451 l 243 111 l 788 111 m 464 1178 q 517 1205 494 1178 q 544 1272 540 1232 l 614 1272 q 602 1211 614 1239 q 570 1163 590 1183 q 523 1130 550 1142 q 464 1118 496 1118 q 405 1130 432 1118 q 358 1163 378 1142 q 326 1211 338 1183 q 314 1272 314 1239 l 385 1272 q 408 1206 385 1235 q 464 1178 432 1178 z "
    },
    "Ě": {
      "ha": 840,
      "x_min": 118,
      "x_max": 788,
      "o": "m 346 1272 l 464 1185 l 582 1272 l 649 1239 l 508 1114 l 419 1114 l 279 1239 l 346 1272 m 788 111 l 788 0 l 118 0 l 118 986 l 775 986 l 775 875 l 243 875 l 243 556 l 706 556 l 706 451 l 243 451 l 243 111 l 788 111 z "
    },
    "Ê": {
      "ha": 840,
      "x_min": 118,
      "x_max": 788,
      "o": "m 279 1147 l 419 1272 l 508 1272 l 649 1147 l 582 1114 l 464 1201 l 346 1114 l 279 1147 m 788 111 l 788 0 l 118 0 l 118 986 l 775 986 l 775 875 l 243 875 l 243 556 l 706 556 l 706 451 l 243 451 l 243 111 l 788 111 z "
    },
    "Ë": {
      "ha": 840,
      "x_min": 118,
      "x_max": 788,
      "o": "m 300 1126 l 300 1268 l 403 1268 l 403 1126 l 300 1126 m 525 1126 l 525 1268 l 628 1268 l 628 1126 l 525 1126 m 788 111 l 788 0 l 118 0 l 118 986 l 775 986 l 775 875 l 243 875 l 243 556 l 706 556 l 706 451 l 243 451 l 243 111 l 788 111 z "
    },
    "Ė": {
      "ha": 840,
      "x_min": 118,
      "x_max": 788,
      "o": "m 788 111 l 788 0 l 118 0 l 118 986 l 775 986 l 775 875 l 243 875 l 243 556 l 706 556 l 706 451 l 243 451 l 243 111 l 788 111 m 408 1125 l 408 1272 l 519 1272 l 519 1125 l 408 1125 z "
    },
    "È": {
      "ha": 840,
      "x_min": 118,
      "x_max": 788,
      "o": "m 788 111 l 788 0 l 118 0 l 118 986 l 775 986 l 775 875 l 243 875 l 243 556 l 706 556 l 706 451 l 243 451 l 243 111 l 788 111 m 319 1274 l 440 1274 l 522 1133 l 443 1106 l 319 1274 z "
    },
    "Ē": {
      "ha": 840,
      "x_min": 118,
      "x_max": 788,
      "o": "m 788 111 l 788 0 l 118 0 l 118 986 l 775 986 l 775 875 l 243 875 l 243 556 l 706 556 l 706 451 l 243 451 l 243 111 l 788 111 m 263 1167 l 263 1247 l 668 1247 l 668 1167 l 263 1167 z "
    },
    "Ŋ": {
      "ha": 1058,
      "x_min": 118,
      "x_max": 940,
      "o": "m 243 750 l 243 0 l 118 0 l 118 986 l 214 986 l 815 224 l 815 985 l 940 985 l 940 -28 q 922 -122 940 -79 q 871 -194 903 -164 q 798 -242 839 -225 q 714 -258 757 -258 q 624 -244 667 -258 q 549 -200 582 -231 l 606 -118 q 650 -143 625 -136 q 700 -150 675 -150 q 744 -141 722 -150 q 782 -117 765 -132 q 808 -79 799 -101 q 818 -32 818 -57 l 818 21 l 243 750 z "
    },
    "Ę": {
      "ha": 840,
      "x_min": 118,
      "x_max": 788,
      "o": "m 788 111 l 788 0 q 700 -67 726 -37 q 674 -128 674 -97 q 750 -187 674 -179 l 719 -251 q 632 -212 661 -240 q 603 -144 603 -183 q 628 -72 603 -108 q 710 0 654 -36 l 118 0 l 118 986 l 775 986 l 775 875 l 243 875 l 243 556 l 706 556 l 706 451 l 243 451 l 243 111 l 788 111 z "
    },
    "Ð": {
      "ha": 1003,
      "x_min": 47,
      "x_max": 944,
      "o": "m 126 0 l 126 449 l 47 449 l 47 543 l 126 543 l 126 986 l 468 986 q 676 947 586 986 q 825 842 765 908 q 915 685 885 775 q 944 494 944 596 q 911 291 944 382 q 815 135 878 200 q 665 35 753 71 q 468 0 576 0 l 126 0 m 818 494 q 795 648 818 578 q 727 768 772 718 q 617 847 682 818 q 468 875 551 875 l 251 875 l 251 543 l 475 543 l 475 449 l 251 449 l 251 111 l 468 111 q 619 140 553 111 q 728 221 685 169 q 795 342 772 272 q 818 494 818 413 z "
    },
    "Ẽ": {
      "ha": 840,
      "x_min": 118,
      "x_max": 788,
      "o": "m 788 111 l 788 0 l 118 0 l 118 986 l 775 986 l 775 875 l 243 875 l 243 556 l 706 556 l 706 451 l 243 451 l 243 111 l 788 111 m 550 1129 q 495 1138 518 1129 q 452 1158 472 1147 q 413 1178 432 1169 q 371 1188 393 1188 q 334 1178 347 1188 q 314 1156 321 1168 q 305 1133 307 1144 q 303 1121 303 1122 l 231 1121 q 237 1153 231 1129 q 258 1201 243 1176 q 300 1245 274 1226 q 368 1264 326 1264 q 419 1255 397 1264 q 462 1234 442 1246 q 502 1213 482 1222 q 547 1204 522 1204 q 589 1214 574 1204 q 613 1236 604 1224 q 623 1259 621 1249 q 625 1272 625 1269 l 697 1272 q 691 1241 697 1264 q 668 1193 685 1218 q 623 1149 651 1168 q 550 1129 594 1129 z "
    },
    "€": {
      "ha": 1104,
      "x_min": 46,
      "x_max": 1035,
      "o": "m 188 586 q 238 738 201 665 q 334 867 275 811 q 472 958 393 924 q 650 992 551 992 q 876 932 782 992 q 1017 776 971 872 l 918 713 q 865 792 896 760 q 797 843 833 824 q 721 871 760 863 q 644 879 682 879 q 520 855 575 879 q 424 790 465 831 q 355 697 382 750 q 315 586 328 644 l 753 586 l 722 514 l 307 514 l 307 494 q 311 432 307 461 l 704 432 l 674 360 l 328 360 q 376 258 346 306 q 449 177 407 211 q 541 124 490 143 q 649 104 592 104 q 728 114 688 104 q 807 145 769 124 q 877 199 844 167 q 931 278 910 232 l 1035 221 q 969 123 1011 165 q 873 51 926 81 q 760 7 819 22 q 643 -8 700 -8 q 488 22 560 -8 q 360 101 417 51 q 262 218 303 151 q 200 360 221 285 l 46 360 l 76 432 l 185 432 q 181 500 181 465 l 181 514 l 79 514 l 110 586 l 188 586 z "
    },
    "F": {
      "ha": 810,
      "x_min": 118,
      "x_max": 769,
      "o": "m 118 0 l 118 986 l 769 986 l 769 875 l 243 875 l 243 546 l 686 546 l 686 442 l 243 442 l 243 0 l 118 0 z "
    },
    "G": {
      "ha": 992,
      "x_min": 54,
      "x_max": 919,
      "o": "m 814 133 q 514 -7 683 -7 q 331 36 415 -7 q 186 149 247 79 q 90 310 125 219 q 54 496 54 400 q 89 685 54 596 q 185 844 124 775 q 331 953 246 913 q 514 993 415 993 q 749 933 657 993 q 890 778 842 874 l 794 711 q 676 839 750 797 q 511 881 603 881 q 375 848 436 881 q 271 762 314 815 q 204 638 228 708 q 181 493 181 568 q 207 344 181 414 q 279 220 233 274 q 388 136 325 167 q 524 106 450 106 q 814 261 685 106 l 814 397 l 601 397 l 601 492 l 919 492 l 919 0 l 814 0 l 814 133 z "
    },
    "Ğ": {
      "ha": 992,
      "x_min": 54,
      "x_max": 919,
      "o": "m 814 133 q 514 -7 683 -7 q 331 36 415 -7 q 186 149 247 79 q 90 310 125 219 q 54 496 54 400 q 89 685 54 596 q 185 844 124 775 q 331 953 246 913 q 514 993 415 993 q 749 933 657 993 q 890 778 842 874 l 794 711 q 676 839 750 797 q 511 881 603 881 q 375 848 436 881 q 271 762 314 815 q 204 638 228 708 q 181 493 181 568 q 207 344 181 414 q 279 220 233 274 q 388 136 325 167 q 524 106 450 106 q 814 261 685 106 l 814 397 l 601 397 l 601 492 l 919 492 l 919 0 l 814 0 l 814 133 m 513 1178 q 566 1205 543 1178 q 593 1272 589 1232 l 663 1272 q 651 1211 663 1239 q 619 1163 639 1183 q 572 1130 599 1142 q 513 1118 544 1118 q 453 1130 481 1118 q 406 1163 426 1142 q 374 1211 386 1183 q 363 1272 363 1239 l 433 1272 q 457 1206 433 1235 q 513 1178 481 1178 z "
    },
    "Ĝ": {
      "ha": 992,
      "x_min": 54,
      "x_max": 919,
      "o": "m 328 1147 l 468 1272 l 557 1272 l 697 1147 l 631 1114 l 513 1201 l 394 1114 l 328 1147 m 814 133 q 514 -7 683 -7 q 331 36 415 -7 q 186 149 247 79 q 90 310 125 219 q 54 496 54 400 q 89 685 54 596 q 185 844 124 775 q 331 953 246 913 q 514 993 415 993 q 749 933 657 993 q 890 778 842 874 l 794 711 q 676 839 750 797 q 511 881 603 881 q 375 848 436 881 q 271 762 314 815 q 204 638 228 708 q 181 493 181 568 q 207 344 181 414 q 279 220 233 274 q 388 136 325 167 q 524 106 450 106 q 814 261 685 106 l 814 397 l 601 397 l 601 492 l 919 492 l 919 0 l 814 0 l 814 133 z "
    },
    "Ģ": {
      "ha": 992,
      "x_min": 54,
      "x_max": 919,
      "o": "m 468 -296 l 496 -183 l 461 -183 l 461 -67 l 569 -67 l 569 -183 l 528 -296 l 468 -296 m 814 133 q 514 -7 683 -7 q 331 36 415 -7 q 186 149 247 79 q 90 310 125 219 q 54 496 54 400 q 89 685 54 596 q 185 844 124 775 q 331 953 246 913 q 514 993 415 993 q 749 933 657 993 q 890 778 842 874 l 794 711 q 676 839 750 797 q 511 881 603 881 q 375 848 436 881 q 271 762 314 815 q 204 638 228 708 q 181 493 181 568 q 207 344 181 414 q 279 220 233 274 q 388 136 325 167 q 524 106 450 106 q 814 261 685 106 l 814 397 l 601 397 l 601 492 l 919 492 l 919 0 l 814 0 l 814 133 z "
    },
    "": {
      "ha": 233,
      "x_min": 81,
      "x_max": 189,
      "o": "m 88 -296 l 115 -183 l 81 -183 l 81 -67 l 189 -67 l 189 -183 l 147 -296 l 88 -296 z "
    },
    "Ġ": {
      "ha": 992,
      "x_min": 54,
      "x_max": 919,
      "o": "m 814 133 q 514 -7 683 -7 q 331 36 415 -7 q 186 149 247 79 q 90 310 125 219 q 54 496 54 400 q 89 685 54 596 q 185 844 124 775 q 331 953 246 913 q 514 993 415 993 q 749 933 657 993 q 890 778 842 874 l 794 711 q 676 839 750 797 q 511 881 603 881 q 375 848 436 881 q 271 762 314 815 q 204 638 228 708 q 181 493 181 568 q 207 344 181 414 q 279 220 233 274 q 388 136 325 167 q 524 106 450 106 q 814 261 685 106 l 814 397 l 601 397 l 601 492 l 919 492 l 919 0 l 814 0 l 814 133 m 457 1125 l 457 1272 l 568 1272 l 568 1125 l 457 1125 z "
    },
    "H": {
      "ha": 1029,
      "x_min": 118,
      "x_max": 911,
      "o": "m 911 986 l 911 0 l 786 0 l 786 449 l 243 449 l 243 0 l 118 0 l 118 986 l 243 986 l 243 560 l 786 560 l 786 986 l 911 986 z "
    },
    "Ħ": {
      "ha": 1043,
      "x_min": 56,
      "x_max": 988,
      "o": "m 918 986 l 918 826 l 988 826 l 988 761 l 918 761 l 918 0 l 793 0 l 793 449 l 250 449 l 250 0 l 125 0 l 125 761 l 56 761 l 56 826 l 125 826 l 125 986 l 250 986 l 250 826 l 793 826 l 793 986 l 918 986 m 793 560 l 793 761 l 250 761 l 250 560 l 793 560 z "
    },
    "Ĥ": {
      "ha": 1029,
      "x_min": 118,
      "x_max": 911,
      "o": "m 333 1147 l 474 1272 l 563 1272 l 703 1147 l 636 1114 l 518 1201 l 400 1114 l 333 1147 m 911 986 l 911 0 l 786 0 l 786 449 l 243 449 l 243 0 l 118 0 l 118 986 l 243 986 l 243 560 l 786 560 l 786 986 l 911 986 z "
    },
    "I": {
      "ha": 361,
      "x_min": 118,
      "x_max": 243,
      "o": "m 118 0 l 118 986 l 243 986 l 243 0 l 118 0 z "
    },
    "Ĳ": {
      "ha": 1035,
      "x_min": 118,
      "x_max": 928,
      "o": "m 118 0 l 118 986 l 243 986 l 243 0 l 118 0 m 410 147 q 485 113 438 128 q 592 97 532 97 q 704 122 663 97 q 767 197 746 147 q 796 318 789 246 q 803 485 803 390 l 803 986 l 928 986 l 928 485 q 917 280 928 372 q 872 122 907 188 q 770 21 836 57 q 592 -15 704 -15 q 378 46 467 -15 l 410 147 z "
    },
    "J": {
      "ha": 674,
      "x_min": 17,
      "x_max": 567,
      "o": "m 49 147 q 124 113 76 128 q 231 97 171 97 q 343 122 301 97 q 406 197 385 147 q 435 318 428 246 q 442 485 442 390 l 442 986 l 567 986 l 567 485 q 556 280 567 372 q 510 122 546 188 q 409 21 475 57 q 231 -15 343 -15 q 17 46 106 -15 l 49 147 z "
    },
    "Í": {
      "ha": 361,
      "x_min": 118,
      "x_max": 324,
      "o": "m 118 0 l 118 986 l 243 986 l 243 0 l 118 0 m 201 1104 l 121 1132 l 201 1272 l 324 1272 l 201 1104 z "
    },
    "Ĭ": {
      "ha": 361,
      "x_min": 31,
      "x_max": 331,
      "o": "m 118 0 l 118 986 l 243 986 l 243 0 l 118 0 m 181 1178 q 234 1205 211 1178 q 261 1272 257 1232 l 331 1272 q 319 1211 331 1239 q 287 1163 307 1183 q 240 1130 267 1142 q 181 1118 213 1118 q 122 1130 149 1118 q 74 1163 94 1142 q 42 1211 54 1183 q 31 1272 31 1239 l 101 1272 q 125 1206 101 1235 q 181 1178 149 1178 z "
    },
    "Î": {
      "ha": 361,
      "x_min": -4,
      "x_max": 365,
      "o": "m 118 0 l 118 986 l 243 986 l 243 0 l 118 0 m -4 1147 l 136 1272 l 225 1272 l 365 1147 l 299 1114 l 181 1201 l 63 1114 l -4 1147 z "
    },
    "Ï": {
      "ha": 361,
      "x_min": 17,
      "x_max": 344,
      "o": "m 118 0 l 118 986 l 243 986 l 243 0 l 118 0 m 17 1126 l 17 1268 l 119 1268 l 119 1126 l 17 1126 m 242 1126 l 242 1268 l 344 1268 l 344 1126 l 242 1126 z "
    },
    "İ": {
      "ha": 361,
      "x_min": 118,
      "x_max": 243,
      "o": "m 118 0 l 118 986 l 243 986 l 243 0 l 118 0 m 125 1125 l 125 1272 l 236 1272 l 236 1125 l 125 1125 z "
    },
    "Ì": {
      "ha": 361,
      "x_min": 36,
      "x_max": 243,
      "o": "m 118 0 l 118 986 l 243 986 l 243 0 l 118 0 m 36 1274 l 157 1274 l 239 1133 l 160 1106 l 36 1274 z "
    },
    "Ī": {
      "ha": 361,
      "x_min": -21,
      "x_max": 385,
      "o": "m 118 0 l 118 986 l 243 986 l 243 0 l 118 0 m -21 1167 l -21 1247 l 385 1247 l 385 1167 l -21 1167 z "
    },
    "Į": {
      "ha": 361,
      "x_min": 58,
      "x_max": 243,
      "o": "m 175 -251 q 88 -212 117 -240 q 58 -144 58 -183 q 84 -72 58 -108 q 165 0 110 -36 l 118 0 l 118 986 l 243 986 l 243 0 q 156 -67 182 -37 q 129 -128 129 -97 q 206 -187 129 -179 l 175 -251 l 175 -251 z "
    },
    "Ĩ": {
      "ha": 361,
      "x_min": -53,
      "x_max": 414,
      "o": "m 118 0 l 118 986 l 243 986 l 243 0 l 118 0 m 267 1129 q 212 1138 235 1129 q 169 1158 189 1147 q 129 1178 149 1169 q 88 1188 110 1188 q 51 1178 64 1188 q 31 1156 38 1168 q 22 1133 24 1144 q 19 1121 19 1122 l -53 1121 q -47 1153 -53 1129 q -25 1201 -40 1176 q 17 1245 -10 1226 q 85 1264 43 1264 q 136 1255 114 1264 q 178 1234 158 1246 q 219 1213 199 1222 q 264 1204 239 1204 q 306 1214 290 1204 q 329 1236 321 1224 q 340 1259 338 1249 q 342 1272 342 1269 l 414 1272 q 408 1241 414 1264 q 385 1193 401 1218 q 340 1149 368 1168 q 267 1129 311 1129 z "
    },
    "Ĵ": {
      "ha": 674,
      "x_min": 17,
      "x_max": 690,
      "o": "m 321 1147 l 461 1272 l 550 1272 l 690 1147 l 624 1114 l 506 1201 l 388 1114 l 321 1147 m 49 147 q 124 113 76 128 q 231 97 171 97 q 343 122 301 97 q 406 197 385 147 q 435 318 428 246 q 442 485 442 390 l 442 986 l 567 986 l 567 485 q 556 280 567 372 q 510 122 546 188 q 409 21 475 57 q 231 -15 343 -15 q 17 46 106 -15 l 49 147 z "
    },
    "K": {
      "ha": 906,
      "x_min": 118,
      "x_max": 908,
      "o": "m 118 0 l 118 985 l 243 985 l 243 440 l 751 986 l 886 986 l 490 551 l 908 0 l 772 0 l 414 479 l 243 301 l 243 0 l 118 0 z "
    },
    "Ķ": {
      "ha": 906,
      "x_min": 118,
      "x_max": 908,
      "o": "m 417 -296 l 444 -183 l 410 -183 l 410 -67 l 518 -67 l 518 -183 l 476 -296 l 417 -296 m 118 0 l 118 985 l 243 985 l 243 440 l 751 986 l 886 986 l 490 551 l 908 0 l 772 0 l 414 479 l 243 301 l 243 0 l 118 0 z "
    },
    "L": {
      "ha": 811,
      "x_min": 118,
      "x_max": 793,
      "o": "m 118 0 l 118 986 l 243 986 l 243 111 l 793 111 l 793 0 l 118 0 z "
    },
    "Ĺ": {
      "ha": 811,
      "x_min": 118,
      "x_max": 793,
      "o": "m 504 1104 l 424 1132 l 504 1272 l 626 1272 l 504 1104 m 118 0 l 118 986 l 243 986 l 243 111 l 793 111 l 793 0 l 118 0 z "
    },
    "Ľ": {
      "ha": 811,
      "x_min": 118,
      "x_max": 793,
      "o": "m 543 846 l 463 874 l 543 1014 l 665 1014 l 543 846 m 118 0 l 118 986 l 243 986 l 243 111 l 793 111 l 793 0 l 118 0 z "
    },
    "Ļ": {
      "ha": 811,
      "x_min": 118,
      "x_max": 793,
      "o": "m 413 -296 l 440 -183 l 406 -183 l 406 -67 l 514 -67 l 514 -183 l 472 -296 l 413 -296 m 118 0 l 118 986 l 243 986 l 243 111 l 793 111 l 793 0 l 118 0 z "
    },
    "Ŀ": {
      "ha": 811,
      "x_min": 118,
      "x_max": 793,
      "o": "m 118 0 l 118 986 l 243 986 l 243 111 l 793 111 l 793 0 l 118 0 m 508 476 l 508 649 l 611 649 l 611 476 l 508 476 z "
    },
    "·": {
      "ha": 281,
      "x_min": 89,
      "x_max": 192,
      "o": "m 89 340 l 89 513 l 192 513 l 192 340 l 89 340 z "
    },
    "Ł": {
      "ha": 821,
      "x_min": 14,
      "x_max": 803,
      "o": "m 128 0 l 128 383 l 50 324 l 14 393 l 128 479 l 128 986 l 253 986 l 253 575 l 450 726 l 485 658 l 253 479 l 253 111 l 803 111 l 803 0 l 128 0 z "
    },
    "M": {
      "ha": 1214,
      "x_min": 118,
      "x_max": 1096,
      "o": "m 971 0 l 971 763 l 643 178 l 572 178 l 243 763 l 243 0 l 118 0 l 118 986 l 250 986 l 607 346 l 965 986 l 1096 986 l 1096 0 l 971 0 z "
    },
    "N": {
      "ha": 1069,
      "x_min": 118,
      "x_max": 951,
      "o": "m 243 753 l 243 0 l 118 0 l 118 986 l 215 986 l 826 218 l 826 985 l 951 985 l 951 0 l 846 0 l 243 753 z "
    },
    "A": {
      "ha": 940,
      "x_min": 14,
      "x_max": 926,
      "o": "m 418 986 l 524 986 l 926 0 l 793 0 l 676 289 l 263 289 l 147 0 l 14 0 l 418 986 m 649 386 l 471 842 l 288 386 l 649 386 z "
    },
    "Ń": {
      "ha": 1069,
      "x_min": 118,
      "x_max": 951,
      "o": "m 558 1104 l 478 1132 l 558 1272 l 681 1272 l 558 1104 m 243 753 l 243 0 l 118 0 l 118 986 l 215 986 l 826 218 l 826 985 l 951 985 l 951 0 l 846 0 l 243 753 z "
    },
    "Ň": {
      "ha": 1069,
      "x_min": 118,
      "x_max": 951,
      "o": "m 419 1272 l 538 1185 l 656 1272 l 722 1239 l 582 1114 l 493 1114 l 353 1239 l 419 1272 m 243 753 l 243 0 l 118 0 l 118 986 l 215 986 l 826 218 l 826 985 l 951 985 l 951 0 l 846 0 l 243 753 z "
    },
    "Ņ": {
      "ha": 1069,
      "x_min": 118,
      "x_max": 951,
      "o": "m 486 -296 l 514 -183 l 479 -183 l 479 -67 l 588 -67 l 588 -183 l 546 -296 l 486 -296 m 243 753 l 243 0 l 118 0 l 118 986 l 215 986 l 826 218 l 826 985 l 951 985 l 951 0 l 846 0 l 243 753 z "
    },
    "Ṅ": {
      "ha": 1069,
      "x_min": 118,
      "x_max": 951,
      "o": "m 482 1125 l 482 1272 l 593 1272 l 593 1125 l 482 1125 m 243 753 l 243 0 l 118 0 l 118 986 l 215 986 l 826 218 l 826 985 l 951 985 l 951 0 l 846 0 l 243 753 z "
    },
    "Ñ": {
      "ha": 1069,
      "x_min": 118,
      "x_max": 951,
      "o": "m 243 753 l 243 0 l 118 0 l 118 986 l 215 986 l 826 218 l 826 985 l 951 985 l 951 0 l 846 0 l 243 753 m 624 1129 q 569 1138 592 1129 q 526 1158 546 1147 q 486 1178 506 1169 q 444 1188 467 1188 q 408 1178 421 1188 q 388 1156 394 1168 q 378 1133 381 1144 q 376 1121 376 1122 l 304 1121 q 310 1153 304 1129 q 332 1201 317 1176 q 374 1245 347 1226 q 442 1264 400 1264 q 493 1255 471 1264 q 535 1234 515 1246 q 576 1213 556 1222 q 621 1204 596 1204 q 663 1214 647 1204 q 686 1236 678 1224 q 697 1259 694 1249 q 699 1272 699 1269 l 771 1272 q 765 1241 771 1264 q 742 1193 758 1218 q 697 1149 725 1168 q 624 1129 668 1129 z "
    },
    "O": {
      "ha": 1039,
      "x_min": 54,
      "x_max": 983,
      "o": "m 518 -7 q 328 35 414 -7 q 182 148 243 78 q 88 308 121 218 q 54 493 54 399 q 90 682 54 592 q 188 842 125 772 q 335 952 250 911 q 521 993 421 993 q 710 949 625 993 q 856 835 794 906 q 950 674 917 764 q 983 492 983 585 q 948 303 983 393 q 851 144 913 213 q 703 34 789 75 q 518 -7 618 -7 m 181 493 q 205 348 181 418 q 274 224 229 278 q 381 138 318 169 q 519 106 443 106 q 661 140 599 106 q 767 228 724 174 q 834 353 811 283 q 857 493 857 422 q 833 638 857 568 q 763 762 808 708 q 656 847 718 815 q 519 879 594 879 q 378 846 440 879 q 272 758 315 813 q 204 635 228 704 q 181 493 181 565 z "
    },
    "Œ": {
      "ha": 1571,
      "x_min": 54,
      "x_max": 1519,
      "o": "m 1519 111 l 1519 0 l 861 0 l 861 218 q 803 128 838 169 q 724 58 768 88 q 628 10 679 28 q 519 -7 576 -7 q 330 35 415 -7 q 183 148 244 78 q 88 308 122 218 q 54 493 54 399 q 90 682 54 592 q 188 842 125 772 q 335 952 250 911 q 521 993 421 993 q 631 976 579 993 q 726 928 683 958 q 803 856 769 897 q 861 768 838 815 l 861 986 l 1507 986 l 1507 875 l 986 875 l 986 558 l 1432 558 l 1432 447 l 986 447 l 986 111 l 1519 111 m 519 106 q 661 139 599 106 q 767 227 724 172 q 834 352 811 282 q 857 494 857 422 q 833 639 857 569 q 763 763 808 708 q 656 849 718 817 q 519 881 594 881 q 378 847 440 881 q 272 759 315 814 q 204 635 228 704 q 181 493 181 565 q 205 348 181 418 q 274 224 229 278 q 381 138 318 169 q 519 106 443 106 z "
    },
    "Ó": {
      "ha": 1039,
      "x_min": 54,
      "x_max": 983,
      "o": "m 542 1104 l 461 1132 l 542 1272 l 664 1272 l 542 1104 m 518 -7 q 328 35 414 -7 q 182 148 243 78 q 88 308 121 218 q 54 493 54 399 q 90 682 54 592 q 188 842 125 772 q 335 952 250 911 q 521 993 421 993 q 710 949 625 993 q 856 835 794 906 q 950 674 917 764 q 983 492 983 585 q 948 303 983 393 q 851 144 913 213 q 703 34 789 75 q 518 -7 618 -7 m 181 493 q 205 348 181 418 q 274 224 229 278 q 381 138 318 169 q 519 106 443 106 q 661 140 599 106 q 767 228 724 174 q 834 353 811 283 q 857 493 857 422 q 833 638 857 568 q 763 762 808 708 q 656 847 718 815 q 519 879 594 879 q 378 846 440 879 q 272 758 315 813 q 204 635 228 704 q 181 493 181 565 z "
    },
    "Ŏ": {
      "ha": 1039,
      "x_min": 54,
      "x_max": 983,
      "o": "m 518 -7 q 328 35 414 -7 q 182 148 243 78 q 88 308 121 218 q 54 493 54 399 q 90 682 54 592 q 188 842 125 772 q 335 952 250 911 q 521 993 421 993 q 710 949 625 993 q 856 835 794 906 q 950 674 917 764 q 983 492 983 585 q 948 303 983 393 q 851 144 913 213 q 703 34 789 75 q 518 -7 618 -7 m 181 493 q 205 348 181 418 q 274 224 229 278 q 381 138 318 169 q 519 106 443 106 q 661 140 599 106 q 767 228 724 174 q 834 353 811 283 q 857 493 857 422 q 833 638 857 568 q 763 762 808 708 q 656 847 718 815 q 519 879 594 879 q 378 846 440 879 q 272 758 315 813 q 204 635 228 704 q 181 493 181 565 m 521 1178 q 574 1205 551 1178 q 601 1272 597 1232 l 671 1272 q 659 1211 671 1239 q 627 1163 647 1183 q 580 1130 607 1142 q 521 1118 553 1118 q 462 1130 489 1118 q 415 1163 435 1142 q 383 1211 394 1183 q 371 1272 371 1239 l 442 1272 q 465 1206 442 1235 q 521 1178 489 1178 z "
    },
    "Ô": {
      "ha": 1039,
      "x_min": 54,
      "x_max": 983,
      "o": "m 336 1147 l 476 1272 l 565 1272 l 706 1147 l 639 1114 l 521 1201 l 403 1114 l 336 1147 m 518 -7 q 328 35 414 -7 q 182 148 243 78 q 88 308 121 218 q 54 493 54 399 q 90 682 54 592 q 188 842 125 772 q 335 952 250 911 q 521 993 421 993 q 710 949 625 993 q 856 835 794 906 q 950 674 917 764 q 983 492 983 585 q 948 303 983 393 q 851 144 913 213 q 703 34 789 75 q 518 -7 618 -7 m 181 493 q 205 348 181 418 q 274 224 229 278 q 381 138 318 169 q 519 106 443 106 q 661 140 599 106 q 767 228 724 174 q 834 353 811 283 q 857 493 857 422 q 833 638 857 568 q 763 762 808 708 q 656 847 718 815 q 519 879 594 879 q 378 846 440 879 q 272 758 315 813 q 204 635 228 704 q 181 493 181 565 z "
    },
    "Ö": {
      "ha": 1039,
      "x_min": 54,
      "x_max": 983,
      "o": "m 357 1126 l 357 1268 l 460 1268 l 460 1126 l 357 1126 m 582 1126 l 582 1268 l 685 1268 l 685 1126 l 582 1126 m 518 -7 q 328 35 414 -7 q 182 148 243 78 q 88 308 121 218 q 54 493 54 399 q 90 682 54 592 q 188 842 125 772 q 335 952 250 911 q 521 993 421 993 q 710 949 625 993 q 856 835 794 906 q 950 674 917 764 q 983 492 983 585 q 948 303 983 393 q 851 144 913 213 q 703 34 789 75 q 518 -7 618 -7 m 181 493 q 205 348 181 418 q 274 224 229 278 q 381 138 318 169 q 519 106 443 106 q 661 140 599 106 q 767 228 724 174 q 834 353 811 283 q 857 493 857 422 q 833 638 857 568 q 763 762 808 708 q 656 847 718 815 q 519 879 594 879 q 378 846 440 879 q 272 758 315 813 q 204 635 228 704 q 181 493 181 565 z "
    },
    "Ò": {
      "ha": 1039,
      "x_min": 54,
      "x_max": 983,
      "o": "m 518 -7 q 328 35 414 -7 q 182 148 243 78 q 88 308 121 218 q 54 493 54 399 q 90 682 54 592 q 188 842 125 772 q 335 952 250 911 q 521 993 421 993 q 710 949 625 993 q 856 835 794 906 q 950 674 917 764 q 983 492 983 585 q 948 303 983 393 q 851 144 913 213 q 703 34 789 75 q 518 -7 618 -7 m 181 493 q 205 348 181 418 q 274 224 229 278 q 381 138 318 169 q 519 106 443 106 q 661 140 599 106 q 767 228 724 174 q 834 353 811 283 q 857 493 857 422 q 833 638 857 568 q 763 762 808 708 q 656 847 718 815 q 519 879 594 879 q 378 846 440 879 q 272 758 315 813 q 204 635 228 704 q 181 493 181 565 m 376 1274 l 497 1274 l 579 1133 l 500 1106 l 376 1274 z "
    },
    "Ő": {
      "ha": 1039,
      "x_min": 54,
      "x_max": 983,
      "o": "m 433 1106 l 369 1133 l 444 1274 l 550 1274 l 433 1106 m 622 1106 l 558 1133 l 633 1274 l 739 1274 l 622 1106 m 518 -7 q 328 35 414 -7 q 182 148 243 78 q 88 308 121 218 q 54 493 54 399 q 90 682 54 592 q 188 842 125 772 q 335 952 250 911 q 521 993 421 993 q 710 949 625 993 q 856 835 794 906 q 950 674 917 764 q 983 492 983 585 q 948 303 983 393 q 851 144 913 213 q 703 34 789 75 q 518 -7 618 -7 m 181 493 q 205 348 181 418 q 274 224 229 278 q 381 138 318 169 q 519 106 443 106 q 661 140 599 106 q 767 228 724 174 q 834 353 811 283 q 857 493 857 422 q 833 638 857 568 q 763 762 808 708 q 656 847 718 815 q 519 879 594 879 q 378 846 440 879 q 272 758 315 813 q 204 635 228 704 q 181 493 181 565 z "
    },
    "˝": {
      "ha": 469,
      "x_min": 56,
      "x_max": 425,
      "o": "m 119 846 l 56 874 l 131 1014 l 236 1014 l 119 846 m 308 846 l 244 874 l 319 1014 l 425 1014 l 308 846 z "
    },
    "Ō": {
      "ha": 1039,
      "x_min": 54,
      "x_max": 983,
      "o": "m 319 1167 l 319 1247 l 725 1247 l 725 1167 l 319 1167 m 518 -7 q 328 35 414 -7 q 182 148 243 78 q 88 308 121 218 q 54 493 54 399 q 90 682 54 592 q 188 842 125 772 q 335 952 250 911 q 521 993 421 993 q 710 949 625 993 q 856 835 794 906 q 950 674 917 764 q 983 492 983 585 q 948 303 983 393 q 851 144 913 213 q 703 34 789 75 q 518 -7 618 -7 m 181 493 q 205 348 181 418 q 274 224 229 278 q 381 138 318 169 q 519 106 443 106 q 661 140 599 106 q 767 228 724 174 q 834 353 811 283 q 857 493 857 422 q 833 638 857 568 q 763 762 808 708 q 656 847 718 815 q 519 879 594 879 q 378 846 440 879 q 272 758 315 813 q 204 635 228 704 q 181 493 181 565 z "
    },
    "Ǫ": {
      "ha": 1039,
      "x_min": 54,
      "x_max": 983,
      "o": "m 485 -254 q 397 -215 426 -243 q 368 -147 368 -186 q 393 -76 368 -111 q 472 -4 418 -40 q 301 51 378 6 q 169 165 224 96 q 84 318 114 233 q 54 493 54 403 q 90 682 54 592 q 188 842 125 772 q 335 952 250 911 q 521 993 421 993 q 710 949 625 993 q 856 835 794 906 q 950 674 917 764 q 983 492 983 585 q 951 310 983 397 q 860 154 918 222 q 722 43 801 86 q 547 -6 642 0 q 464 -71 489 -42 q 439 -131 439 -100 q 515 -190 439 -182 l 485 -254 m 181 493 q 205 348 181 418 q 274 224 229 278 q 381 138 318 169 q 519 106 443 106 q 661 140 599 106 q 767 228 724 174 q 834 353 811 283 q 857 493 857 422 q 833 638 857 568 q 763 762 808 708 q 656 847 718 815 q 519 879 594 879 q 378 846 440 879 q 272 758 315 813 q 204 635 228 704 q 181 493 181 565 z "
    },
    "Ø": {
      "ha": 1039,
      "x_min": 54,
      "x_max": 983,
      "o": "m 921 986 l 835 858 q 944 688 906 785 q 983 492 983 592 q 948 303 983 393 q 851 144 913 213 q 703 34 789 75 q 518 -7 618 -7 q 397 9 454 -7 q 292 56 340 25 l 254 0 l 118 0 l 203 126 q 93 293 132 197 q 54 493 54 389 q 90 682 54 592 q 188 842 125 772 q 335 952 250 911 q 521 993 421 993 q 640 976 583 993 q 744 929 696 960 l 783 986 l 921 986 m 857 493 q 833 636 857 568 q 767 757 810 704 l 356 151 q 519 106 429 106 q 661 140 599 106 q 767 228 724 174 q 834 353 811 283 q 857 493 857 422 m 181 493 q 203 349 181 418 q 271 226 226 279 l 681 833 q 519 879 607 879 q 378 846 440 879 q 272 758 315 813 q 204 635 228 704 q 181 493 181 565 z "
    },
    "/": {
      "ha": 879,
      "x_min": 38,
      "x_max": 840,
      "o": "m 840 986 l 174 0 l 38 0 l 703 986 l 840 986 z "
    },
    "Ǿ": {
      "ha": 1039,
      "x_min": 54,
      "x_max": 983,
      "o": "m 921 986 l 835 858 q 944 688 906 785 q 983 492 983 592 q 948 303 983 393 q 851 144 913 213 q 703 34 789 75 q 518 -7 618 -7 q 397 9 454 -7 q 292 56 340 25 l 254 0 l 118 0 l 203 126 q 93 293 132 197 q 54 493 54 389 q 90 682 54 592 q 188 842 125 772 q 335 952 250 911 q 521 993 421 993 q 640 976 583 993 q 744 929 696 960 l 783 986 l 921 986 m 857 493 q 833 636 857 568 q 767 757 810 704 l 356 151 q 519 106 429 106 q 661 140 599 106 q 767 228 724 174 q 834 353 811 283 q 857 493 857 422 m 181 493 q 203 349 181 418 q 271 226 226 279 l 681 833 q 519 879 607 879 q 378 846 440 879 q 272 758 315 813 q 204 635 228 704 q 181 493 181 565 m 542 1104 l 461 1132 l 542 1272 l 664 1272 l 542 1104 z "
    },
    "Õ": {
      "ha": 1039,
      "x_min": 54,
      "x_max": 983,
      "o": "m 518 -7 q 328 35 414 -7 q 182 148 243 78 q 88 308 121 218 q 54 493 54 399 q 90 682 54 592 q 188 842 125 772 q 335 952 250 911 q 521 993 421 993 q 710 949 625 993 q 856 835 794 906 q 950 674 917 764 q 983 492 983 585 q 948 303 983 393 q 851 144 913 213 q 703 34 789 75 q 518 -7 618 -7 m 181 493 q 205 348 181 418 q 274 224 229 278 q 381 138 318 169 q 519 106 443 106 q 661 140 599 106 q 767 228 724 174 q 834 353 811 283 q 857 493 857 422 q 833 638 857 568 q 763 762 808 708 q 656 847 718 815 q 519 879 594 879 q 378 846 440 879 q 272 758 315 813 q 204 635 228 704 q 181 493 181 565 m 607 1129 q 552 1138 575 1129 q 509 1158 529 1147 q 469 1178 489 1169 q 428 1188 450 1188 q 391 1178 404 1188 q 371 1156 378 1168 q 362 1133 364 1144 q 360 1121 360 1122 l 288 1121 q 294 1153 288 1129 q 315 1201 300 1176 q 357 1245 331 1226 q 425 1264 383 1264 q 476 1255 454 1264 q 519 1234 499 1246 q 559 1213 539 1222 q 604 1204 579 1204 q 646 1214 631 1204 q 669 1236 661 1224 q 680 1259 678 1249 q 682 1272 682 1269 l 754 1272 q 748 1241 754 1264 q 725 1193 742 1218 q 680 1149 708 1168 q 607 1129 651 1129 z "
    },
    "P": {
      "ha": 865,
      "x_min": 118,
      "x_max": 828,
      "o": "m 118 0 l 118 986 l 529 986 q 649 959 594 986 q 744 887 704 932 q 806 785 783 842 q 828 671 828 729 q 807 553 828 610 q 748 451 786 496 q 656 381 710 407 q 538 354 603 354 l 243 354 l 243 0 l 118 0 m 243 465 l 531 465 q 601 481 569 465 q 654 526 632 497 q 689 592 676 554 q 701 671 701 629 q 687 751 701 714 q 648 817 672 789 q 591 860 624 844 q 522 875 558 875 l 243 875 l 243 465 z "
    },
    "Q": {
      "ha": 1036,
      "x_min": 54,
      "x_max": 983,
      "o": "m 782 81 q 660 17 726 40 q 518 -7 593 -7 q 328 36 414 -7 q 182 149 243 79 q 88 308 121 218 q 54 493 54 399 q 90 682 54 592 q 188 842 125 772 q 335 952 250 911 q 521 993 421 993 q 710 949 625 993 q 856 835 794 906 q 950 674 917 764 q 983 492 983 585 q 948 302 983 392 q 850 143 913 213 l 974 0 l 851 0 l 782 81 m 519 106 q 621 122 574 106 q 707 168 668 139 l 575 322 l 697 322 l 772 235 q 835 356 813 289 q 857 493 857 422 q 833 638 857 568 q 763 763 808 708 q 656 849 718 817 q 519 881 594 881 q 378 847 440 881 q 272 759 315 814 q 204 635 228 704 q 181 493 181 565 q 205 348 181 418 q 274 224 229 278 q 381 138 318 169 q 519 106 443 106 z "
    },
    "R": {
      "ha": 913,
      "x_min": 118,
      "x_max": 871,
      "o": "m 118 0 l 118 986 l 540 986 q 660 959 606 986 q 755 887 715 932 q 817 785 794 842 q 839 671 839 729 q 824 572 839 619 q 783 485 810 524 q 717 418 756 446 q 632 378 679 390 l 871 0 l 729 0 l 504 354 l 243 354 l 243 0 l 118 0 m 243 465 l 542 465 q 612 482 581 465 q 665 527 643 499 q 700 593 688 556 q 713 671 713 631 q 698 749 713 713 q 659 815 683 786 q 602 859 635 843 q 533 875 569 875 l 243 875 l 243 465 z "
    },
    "Ŕ": {
      "ha": 913,
      "x_min": 118,
      "x_max": 871,
      "o": "m 464 1107 l 383 1135 l 464 1275 l 586 1275 l 464 1107 m 118 0 l 118 986 l 540 986 q 660 959 606 986 q 755 887 715 932 q 817 785 794 842 q 839 671 839 729 q 824 572 839 619 q 783 485 810 524 q 717 418 756 446 q 632 378 679 390 l 871 0 l 729 0 l 504 354 l 243 354 l 243 0 l 118 0 m 243 465 l 542 465 q 612 482 581 465 q 665 527 643 499 q 700 593 688 556 q 713 671 713 631 q 698 749 713 713 q 659 815 683 786 q 602 859 635 843 q 533 875 569 875 l 243 875 l 243 465 z "
    },
    "Ř": {
      "ha": 913,
      "x_min": 118,
      "x_max": 871,
      "o": "m 324 1275 l 442 1188 l 560 1275 l 626 1242 l 486 1117 l 397 1117 l 257 1242 l 324 1275 m 118 0 l 118 986 l 540 986 q 660 959 606 986 q 755 887 715 932 q 817 785 794 842 q 839 671 839 729 q 824 572 839 619 q 783 485 810 524 q 717 418 756 446 q 632 378 679 390 l 871 0 l 729 0 l 504 354 l 243 354 l 243 0 l 118 0 m 243 465 l 542 465 q 612 482 581 465 q 665 527 643 499 q 700 593 688 556 q 713 671 713 631 q 698 749 713 713 q 659 815 683 786 q 602 859 635 843 q 533 875 569 875 l 243 875 l 243 465 z "
    },
    "Ŗ": {
      "ha": 913,
      "x_min": 118,
      "x_max": 871,
      "o": "m 410 -296 l 438 -183 l 403 -183 l 403 -67 l 511 -67 l 511 -183 l 469 -296 l 410 -296 m 118 0 l 118 986 l 540 986 q 660 959 606 986 q 755 887 715 932 q 817 785 794 842 q 839 671 839 729 q 824 572 839 619 q 783 485 810 524 q 717 418 756 446 q 632 378 679 390 l 871 0 l 729 0 l 504 354 l 243 354 l 243 0 l 118 0 m 243 465 l 542 465 q 612 482 581 465 q 665 527 643 499 q 700 593 688 556 q 713 671 713 631 q 698 749 713 713 q 659 815 683 786 q 602 859 635 843 q 533 875 569 875 l 243 875 l 243 465 z "
    },
    "S": {
      "ha": 846,
      "x_min": 40,
      "x_max": 800,
      "o": "m 697 779 q 653 817 681 799 q 590 849 625 835 q 515 873 556 864 q 429 882 474 882 q 260 839 314 882 q 207 721 207 796 q 222 654 207 681 q 270 609 238 628 q 351 576 303 590 q 467 547 400 563 q 605 509 543 531 q 710 456 667 488 q 777 378 754 424 q 800 265 800 332 q 772 142 800 194 q 697 56 744 90 q 583 6 649 22 q 442 -10 518 -10 q 226 26 328 -10 q 40 129 124 61 l 100 235 q 158 188 122 211 q 238 145 193 164 q 335 115 283 126 q 444 103 388 103 q 608 140 550 103 q 667 253 667 178 q 648 323 667 294 q 593 372 629 351 q 503 409 557 393 q 382 442 450 425 q 250 481 307 460 q 155 531 193 501 q 97 601 117 560 q 78 701 78 643 q 104 826 78 772 q 178 918 131 881 q 290 974 225 956 q 432 993 356 993 q 613 963 532 993 q 756 881 693 932 l 697 779 z "
    },
    "Ś": {
      "ha": 846,
      "x_min": 40,
      "x_max": 800,
      "o": "m 460 1124 l 379 1151 l 460 1292 l 582 1292 l 460 1124 m 697 779 q 653 817 681 799 q 590 849 625 835 q 515 873 556 864 q 429 882 474 882 q 260 839 314 882 q 207 721 207 796 q 222 654 207 681 q 270 609 238 628 q 351 576 303 590 q 467 547 400 563 q 605 509 543 531 q 710 456 667 488 q 777 378 754 424 q 800 265 800 332 q 772 142 800 194 q 697 56 744 90 q 583 6 649 22 q 442 -10 518 -10 q 226 26 328 -10 q 40 129 124 61 l 100 235 q 158 188 122 211 q 238 145 193 164 q 335 115 283 126 q 444 103 388 103 q 608 140 550 103 q 667 253 667 178 q 648 323 667 294 q 593 372 629 351 q 503 409 557 393 q 382 442 450 425 q 250 481 307 460 q 155 531 193 501 q 97 601 117 560 q 78 701 78 643 q 104 826 78 772 q 178 918 131 881 q 290 974 225 956 q 432 993 356 993 q 613 963 532 993 q 756 881 693 932 l 697 779 z "
    },
    "Š": {
      "ha": 846,
      "x_min": 40,
      "x_max": 800,
      "o": "m 321 1292 l 439 1204 l 557 1292 l 624 1258 l 483 1133 l 394 1133 l 254 1258 l 321 1292 m 697 779 q 653 817 681 799 q 590 849 625 835 q 515 873 556 864 q 429 882 474 882 q 260 839 314 882 q 207 721 207 796 q 222 654 207 681 q 270 609 238 628 q 351 576 303 590 q 467 547 400 563 q 605 509 543 531 q 710 456 667 488 q 777 378 754 424 q 800 265 800 332 q 772 142 800 194 q 697 56 744 90 q 583 6 649 22 q 442 -10 518 -10 q 226 26 328 -10 q 40 129 124 61 l 100 235 q 158 188 122 211 q 238 145 193 164 q 335 115 283 126 q 444 103 388 103 q 608 140 550 103 q 667 253 667 178 q 648 323 667 294 q 593 372 629 351 q 503 409 557 393 q 382 442 450 425 q 250 481 307 460 q 155 531 193 501 q 97 601 117 560 q 78 701 78 643 q 104 826 78 772 q 178 918 131 881 q 290 974 225 956 q 432 993 356 993 q 613 963 532 993 q 756 881 693 932 l 697 779 z "
    },
    "Ŝ": {
      "ha": 846,
      "x_min": 40,
      "x_max": 800,
      "o": "m 254 1167 l 394 1292 l 483 1292 l 624 1167 l 557 1133 l 439 1221 l 321 1133 l 254 1167 m 697 779 q 653 817 681 799 q 590 849 625 835 q 515 873 556 864 q 429 882 474 882 q 260 839 314 882 q 207 721 207 796 q 222 654 207 681 q 270 609 238 628 q 351 576 303 590 q 467 547 400 563 q 605 509 543 531 q 710 456 667 488 q 777 378 754 424 q 800 265 800 332 q 772 142 800 194 q 697 56 744 90 q 583 6 649 22 q 442 -10 518 -10 q 226 26 328 -10 q 40 129 124 61 l 100 235 q 158 188 122 211 q 238 145 193 164 q 335 115 283 126 q 444 103 388 103 q 608 140 550 103 q 667 253 667 178 q 648 323 667 294 q 593 372 629 351 q 503 409 557 393 q 382 442 450 425 q 250 481 307 460 q 155 531 193 501 q 97 601 117 560 q 78 701 78 643 q 104 826 78 772 q 178 918 131 881 q 290 974 225 956 q 432 993 356 993 q 613 963 532 993 q 756 881 693 932 l 697 779 z "
    },
    "T": {
      "ha": 853,
      "x_min": 24,
      "x_max": 829,
      "o": "m 829 875 l 489 875 l 489 0 l 364 0 l 364 875 l 24 875 l 24 986 l 829 986 l 829 875 z "
    },
    "Ŧ": {
      "ha": 892,
      "x_min": 43,
      "x_max": 849,
      "o": "m 849 875 l 508 875 l 508 551 l 801 551 l 801 486 l 508 486 l 508 0 l 383 0 l 383 486 l 90 486 l 90 551 l 383 551 l 383 875 l 43 875 l 43 986 l 849 986 l 849 875 z "
    },
    "Ť": {
      "ha": 853,
      "x_min": 24,
      "x_max": 829,
      "o": "m 313 1272 l 431 1185 l 549 1272 l 615 1239 l 475 1114 l 386 1114 l 246 1239 l 313 1272 m 829 875 l 489 875 l 489 0 l 364 0 l 364 875 l 24 875 l 24 986 l 829 986 l 829 875 z "
    },
    "Þ": {
      "ha": 839,
      "x_min": 118,
      "x_max": 803,
      "o": "m 504 796 q 624 769 569 796 q 719 697 679 742 q 781 595 758 651 q 803 481 803 539 q 782 362 803 419 q 723 260 761 304 q 631 190 685 217 q 513 164 578 164 l 243 164 l 243 0 l 118 0 l 118 986 l 243 986 l 243 796 l 504 796 m 507 275 q 578 292 546 275 q 632 338 610 310 q 666 403 654 367 q 678 481 678 440 q 663 559 678 522 q 624 624 649 596 q 567 669 600 653 q 499 685 535 685 l 243 685 l 243 275 l 507 275 z "
    },
    "U": {
      "ha": 1049,
      "x_min": 104,
      "x_max": 944,
      "o": "m 524 106 q 667 139 610 106 q 758 226 724 172 q 806 348 792 279 q 819 488 819 417 l 819 986 l 944 986 l 944 488 q 922 298 944 388 q 849 140 899 208 q 719 33 799 72 q 525 -7 639 -7 q 326 35 407 -7 q 197 145 246 76 q 126 303 147 214 q 104 488 104 393 l 104 986 l 229 986 l 229 488 q 244 345 229 414 q 292 224 258 276 q 383 138 326 171 q 524 106 439 106 z "
    },
    "Ú": {
      "ha": 1049,
      "x_min": 104,
      "x_max": 944,
      "o": "m 546 1104 l 465 1132 l 546 1272 l 668 1272 l 546 1104 m 524 106 q 667 139 610 106 q 758 226 724 172 q 806 348 792 279 q 819 488 819 417 l 819 986 l 944 986 l 944 488 q 922 298 944 388 q 849 140 899 208 q 719 33 799 72 q 525 -7 639 -7 q 326 35 407 -7 q 197 145 246 76 q 126 303 147 214 q 104 488 104 393 l 104 986 l 229 986 l 229 488 q 244 345 229 414 q 292 224 258 276 q 383 138 326 171 q 524 106 439 106 z "
    },
    "Ŭ": {
      "ha": 1049,
      "x_min": 104,
      "x_max": 944,
      "o": "m 524 106 q 667 139 610 106 q 758 226 724 172 q 806 348 792 279 q 819 488 819 417 l 819 986 l 944 986 l 944 488 q 922 298 944 388 q 849 140 899 208 q 719 33 799 72 q 525 -7 639 -7 q 326 35 407 -7 q 197 145 246 76 q 126 303 147 214 q 104 488 104 393 l 104 986 l 229 986 l 229 488 q 244 345 229 414 q 292 224 258 276 q 383 138 326 171 q 524 106 439 106 m 525 1178 q 578 1205 556 1178 q 606 1272 601 1232 l 675 1272 q 663 1211 675 1239 q 631 1163 651 1183 q 584 1130 611 1142 q 525 1118 557 1118 q 466 1130 493 1118 q 419 1163 439 1142 q 387 1211 399 1183 q 375 1272 375 1239 l 446 1272 q 469 1206 446 1235 q 525 1178 493 1178 z "
    },
    "Û": {
      "ha": 1049,
      "x_min": 104,
      "x_max": 944,
      "o": "m 340 1147 l 481 1272 l 569 1272 l 710 1147 l 643 1114 l 525 1201 l 407 1114 l 340 1147 m 524 106 q 667 139 610 106 q 758 226 724 172 q 806 348 792 279 q 819 488 819 417 l 819 986 l 944 986 l 944 488 q 922 298 944 388 q 849 140 899 208 q 719 33 799 72 q 525 -7 639 -7 q 326 35 407 -7 q 197 145 246 76 q 126 303 147 214 q 104 488 104 393 l 104 986 l 229 986 l 229 488 q 244 345 229 414 q 292 224 258 276 q 383 138 326 171 q 524 106 439 106 z "
    },
    "Ü": {
      "ha": 1049,
      "x_min": 104,
      "x_max": 944,
      "o": "m 361 1126 l 361 1268 l 464 1268 l 464 1126 l 361 1126 m 586 1126 l 586 1268 l 689 1268 l 689 1126 l 586 1126 m 524 106 q 667 139 610 106 q 758 226 724 172 q 806 348 792 279 q 819 488 819 417 l 819 986 l 944 986 l 944 488 q 922 298 944 388 q 849 140 899 208 q 719 33 799 72 q 525 -7 639 -7 q 326 35 407 -7 q 197 145 246 76 q 126 303 147 214 q 104 488 104 393 l 104 986 l 229 986 l 229 488 q 244 345 229 414 q 292 224 258 276 q 383 138 326 171 q 524 106 439 106 z "
    },
    "Ù": {
      "ha": 1049,
      "x_min": 104,
      "x_max": 944,
      "o": "m 524 106 q 667 139 610 106 q 758 226 724 172 q 806 348 792 279 q 819 488 819 417 l 819 986 l 944 986 l 944 488 q 922 298 944 388 q 849 140 899 208 q 719 33 799 72 q 525 -7 639 -7 q 326 35 407 -7 q 197 145 246 76 q 126 303 147 214 q 104 488 104 393 l 104 986 l 229 986 l 229 488 q 244 345 229 414 q 292 224 258 276 q 383 138 326 171 q 524 106 439 106 m 381 1274 l 501 1274 l 583 1133 l 504 1106 l 381 1274 z "
    },
    "Ű": {
      "ha": 1049,
      "x_min": 104,
      "x_max": 944,
      "o": "m 524 106 q 667 139 610 106 q 758 226 724 172 q 806 348 792 279 q 819 488 819 417 l 819 986 l 944 986 l 944 488 q 922 298 944 388 q 849 140 899 208 q 719 33 799 72 q 525 -7 639 -7 q 326 35 407 -7 q 197 145 246 76 q 126 303 147 214 q 104 488 104 393 l 104 986 l 229 986 l 229 488 q 244 345 229 414 q 292 224 258 276 q 383 138 326 171 q 524 106 439 106 m 436 1106 l 372 1133 l 447 1274 l 553 1274 l 436 1106 m 625 1106 l 561 1133 l 636 1274 l 742 1274 l 625 1106 z "
    },
    "Ū": {
      "ha": 1049,
      "x_min": 104,
      "x_max": 944,
      "o": "m 524 106 q 667 139 610 106 q 758 226 724 172 q 806 348 792 279 q 819 488 819 417 l 819 986 l 944 986 l 944 488 q 922 298 944 388 q 849 140 899 208 q 719 33 799 72 q 525 -7 639 -7 q 326 35 407 -7 q 197 145 246 76 q 126 303 147 214 q 104 488 104 393 l 104 986 l 229 986 l 229 488 q 244 345 229 414 q 292 224 258 276 q 383 138 326 171 q 524 106 439 106 m 322 1167 l 322 1247 l 728 1247 l 728 1167 l 322 1167 z "
    },
    "Ų": {
      "ha": 1049,
      "x_min": 104,
      "x_max": 944,
      "o": "m 524 106 q 667 139 610 106 q 758 226 724 172 q 806 348 792 279 q 819 488 819 417 l 819 986 l 944 986 l 944 488 q 923 303 944 390 q 854 149 901 215 q 732 40 807 82 q 551 -6 657 -1 q 469 -71 493 -42 q 444 -131 444 -100 q 521 -190 444 -182 l 490 -254 q 403 -215 432 -243 q 374 -147 374 -186 q 399 -76 374 -111 q 478 -4 424 -40 q 302 48 374 4 q 187 160 231 92 q 124 313 143 228 q 104 488 104 397 l 104 986 l 229 986 l 229 488 q 244 345 229 414 q 292 224 258 276 q 383 138 326 171 q 524 106 439 106 z "
    },
    "Ů": {
      "ha": 1049,
      "x_min": 104,
      "x_max": 944,
      "o": "m 411 1176 q 443 1247 411 1221 q 524 1272 475 1272 q 605 1247 574 1272 q 636 1176 636 1221 q 605 1106 636 1132 q 524 1081 574 1081 q 443 1106 475 1081 q 411 1176 411 1132 m 524 1229 q 484 1215 500 1229 q 468 1176 468 1200 q 484 1139 468 1154 q 524 1124 500 1124 q 563 1138 546 1124 q 581 1176 581 1153 q 564 1215 581 1200 q 524 1229 547 1229 m 524 106 q 667 139 610 106 q 758 226 724 172 q 806 348 792 279 q 819 488 819 417 l 819 986 l 944 986 l 944 488 q 922 298 944 388 q 849 140 899 208 q 719 33 799 72 q 525 -7 639 -7 q 326 35 407 -7 q 197 145 246 76 q 126 303 147 214 q 104 488 104 393 l 104 986 l 229 986 l 229 488 q 244 345 229 414 q 292 224 258 276 q 383 138 326 171 q 524 106 439 106 z "
    },
    "Ũ": {
      "ha": 1049,
      "x_min": 104,
      "x_max": 944,
      "o": "m 524 106 q 667 139 610 106 q 758 226 724 172 q 806 348 792 279 q 819 488 819 417 l 819 986 l 944 986 l 944 488 q 922 298 944 388 q 849 140 899 208 q 719 33 799 72 q 525 -7 639 -7 q 326 35 407 -7 q 197 145 246 76 q 126 303 147 214 q 104 488 104 393 l 104 986 l 229 986 l 229 488 q 244 345 229 414 q 292 224 258 276 q 383 138 326 171 q 524 106 439 106 m 611 1129 q 556 1138 579 1129 q 513 1158 533 1147 q 474 1178 493 1169 q 432 1188 454 1188 q 395 1178 408 1188 q 375 1156 382 1168 q 366 1133 368 1144 q 364 1121 364 1122 l 292 1121 q 298 1153 292 1129 q 319 1201 304 1176 q 361 1245 335 1226 q 429 1264 388 1264 q 481 1255 458 1264 q 523 1234 503 1246 q 563 1213 543 1222 q 608 1204 583 1204 q 650 1214 635 1204 q 674 1236 665 1224 q 684 1259 682 1249 q 686 1272 686 1269 l 758 1272 q 752 1241 758 1264 q 729 1193 746 1218 q 684 1149 713 1168 q 611 1129 656 1129 z "
    },
    "V": {
      "ha": 944,
      "x_min": 14,
      "x_max": 929,
      "o": "m 146 986 l 472 157 l 797 986 l 929 986 l 526 0 l 418 0 l 14 986 l 146 986 z "
    },
    "W": {
      "ha": 1457,
      "x_min": 13,
      "x_max": 1446,
      "o": "m 479 981 l 597 981 l 728 638 l 860 981 l 978 981 l 807 551 l 976 144 l 1310 986 l 1446 986 l 1033 0 l 925 0 l 729 465 l 532 0 l 424 0 l 13 986 l 147 986 l 482 144 l 650 551 l 479 981 z "
    },
    "Ẃ": {
      "ha": 1457,
      "x_min": 13,
      "x_max": 1446,
      "o": "m 749 1104 l 668 1132 l 749 1272 l 871 1272 l 749 1104 m 479 981 l 597 981 l 728 638 l 860 981 l 978 981 l 807 551 l 976 144 l 1310 986 l 1446 986 l 1033 0 l 925 0 l 729 465 l 532 0 l 424 0 l 13 986 l 147 986 l 482 144 l 650 551 l 479 981 z "
    },
    "Ŵ": {
      "ha": 1457,
      "x_min": 13,
      "x_max": 1446,
      "o": "m 543 1147 l 683 1272 l 772 1272 l 913 1147 l 846 1114 l 728 1201 l 610 1114 l 543 1147 m 479 981 l 597 981 l 728 638 l 860 981 l 978 981 l 807 551 l 976 144 l 1310 986 l 1446 986 l 1033 0 l 925 0 l 729 465 l 532 0 l 424 0 l 13 986 l 147 986 l 482 144 l 650 551 l 479 981 z "
    },
    "Ẅ": {
      "ha": 1457,
      "x_min": 13,
      "x_max": 1446,
      "o": "m 564 1126 l 564 1268 l 667 1268 l 667 1126 l 564 1126 m 789 1126 l 789 1268 l 892 1268 l 892 1126 l 789 1126 m 479 981 l 597 981 l 728 638 l 860 981 l 978 981 l 807 551 l 976 144 l 1310 986 l 1446 986 l 1033 0 l 925 0 l 729 465 l 532 0 l 424 0 l 13 986 l 147 986 l 482 144 l 650 551 l 479 981 z "
    },
    "Ẁ": {
      "ha": 1457,
      "x_min": 13,
      "x_max": 1446,
      "o": "m 479 981 l 597 981 l 728 638 l 860 981 l 978 981 l 807 551 l 976 144 l 1310 986 l 1446 986 l 1033 0 l 925 0 l 729 465 l 532 0 l 424 0 l 13 986 l 147 986 l 482 144 l 650 551 l 479 981 m 583 1274 l 704 1274 l 786 1133 l 707 1106 l 583 1274 z "
    },
    "X": {
      "ha": 885,
      "x_min": 4,
      "x_max": 881,
      "o": "m 143 986 l 443 575 l 743 986 l 881 986 l 510 486 l 869 0 l 732 0 l 443 397 l 154 0 l 15 0 l 375 486 l 4 986 l 143 986 z "
    },
    "Y": {
      "ha": 910,
      "x_min": 18,
      "x_max": 892,
      "o": "m 156 986 l 454 472 l 756 986 l 892 986 l 517 360 l 517 0 l 392 0 l 392 363 l 18 986 l 156 986 z "
    },
    "Ý": {
      "ha": 910,
      "x_min": 18,
      "x_max": 892,
      "o": "m 156 986 l 454 472 l 756 986 l 892 986 l 517 360 l 517 0 l 392 0 l 392 363 l 18 986 l 156 986 m 475 1104 l 394 1132 l 475 1272 l 597 1272 l 475 1104 z "
    },
    "Ŷ": {
      "ha": 910,
      "x_min": 18,
      "x_max": 892,
      "o": "m 156 986 l 454 472 l 756 986 l 892 986 l 517 360 l 517 0 l 392 0 l 392 363 l 18 986 l 156 986 m 269 1147 l 410 1272 l 499 1272 l 639 1147 l 572 1114 l 454 1201 l 336 1114 l 269 1147 z "
    },
    "Ÿ": {
      "ha": 910,
      "x_min": 18,
      "x_max": 892,
      "o": "m 156 986 l 454 472 l 756 986 l 892 986 l 517 360 l 517 0 l 392 0 l 392 363 l 18 986 l 156 986 m 290 1126 l 290 1268 l 393 1268 l 393 1126 l 290 1126 m 515 1126 l 515 1268 l 618 1268 l 618 1126 l 515 1126 z "
    },
    "Ỳ": {
      "ha": 910,
      "x_min": 18,
      "x_max": 892,
      "o": "m 156 986 l 454 472 l 756 986 l 892 986 l 517 360 l 517 0 l 392 0 l 392 363 l 18 986 l 156 986 m 310 1274 l 431 1274 l 513 1133 l 433 1106 l 310 1274 z "
    },
    "Ỹ": {
      "ha": 910,
      "x_min": 18,
      "x_max": 892,
      "o": "m 156 986 l 454 472 l 756 986 l 892 986 l 517 360 l 517 0 l 392 0 l 392 363 l 18 986 l 156 986 m 540 1129 q 485 1138 508 1129 q 442 1158 463 1147 q 403 1178 422 1169 q 361 1188 383 1188 q 324 1178 338 1188 q 304 1156 311 1168 q 295 1133 297 1144 q 293 1121 293 1122 l 221 1121 q 227 1153 221 1129 q 249 1201 233 1176 q 290 1245 264 1226 q 358 1264 317 1264 q 410 1255 388 1264 q 452 1234 432 1246 q 492 1213 472 1222 q 538 1204 513 1204 q 579 1214 564 1204 q 603 1236 594 1224 q 613 1259 611 1249 q 615 1272 615 1269 l 688 1272 q 681 1241 688 1264 q 658 1193 675 1218 q 613 1149 642 1168 q 540 1129 585 1129 z "
    },
    "Z": {
      "ha": 876,
      "x_min": 44,
      "x_max": 826,
      "o": "m 44 97 l 681 875 l 57 875 l 57 986 l 826 986 l 826 889 l 201 111 l 826 111 l 826 0 l 44 0 l 44 97 z "
    },
    "Ź": {
      "ha": 876,
      "x_min": 44,
      "x_max": 826,
      "o": "m 481 1104 l 400 1132 l 481 1272 l 603 1272 l 481 1104 m 44 97 l 681 875 l 57 875 l 57 986 l 826 986 l 826 889 l 201 111 l 826 111 l 826 0 l 44 0 l 44 97 z "
    },
    "Ž": {
      "ha": 876,
      "x_min": 44,
      "x_max": 826,
      "o": "m 342 1272 l 460 1185 l 578 1272 l 644 1239 l 504 1114 l 415 1114 l 275 1239 l 342 1272 m 44 97 l 681 875 l 57 875 l 57 986 l 826 986 l 826 889 l 201 111 l 826 111 l 826 0 l 44 0 l 44 97 z "
    },
    "Ż": {
      "ha": 876,
      "x_min": 44,
      "x_max": 826,
      "o": "m 44 97 l 681 875 l 57 875 l 57 986 l 826 986 l 826 889 l 201 111 l 826 111 l 826 0 l 44 0 l 44 97 m 404 1125 l 404 1272 l 515 1272 l 515 1125 l 404 1125 z "
    },
    "a": {
      "ha": 769,
      "x_min": 42,
      "x_max": 711,
      "o": "m 285 -14 q 189 3 233 -14 q 112 51 144 21 q 60 123 79 82 q 42 213 42 164 q 64 303 42 263 q 127 374 86 344 q 224 419 168 403 q 347 436 281 436 q 454 426 400 436 q 550 400 508 417 l 550 458 q 500 598 550 547 q 358 649 450 649 q 128 564 249 649 l 88 643 q 369 738 228 738 q 592 661 513 738 q 672 446 672 585 l 672 150 q 711 106 672 107 l 711 0 q 679 -4 692 -3 q 653 -6 667 -6 q 595 16 617 -6 q 569 68 574 38 l 567 119 q 444 20 518 54 q 285 -14 369 -14 m 317 78 q 438 102 382 78 q 524 167 494 126 q 550 221 550 193 l 550 328 q 365 363 461 363 q 216 324 274 363 q 158 222 158 285 q 170 165 158 192 q 203 119 182 139 q 254 89 225 100 q 317 78 283 78 z "
    },
    "á": {
      "ha": 769,
      "x_min": 42,
      "x_max": 711,
      "o": "m 285 -14 q 189 3 233 -14 q 112 51 144 21 q 60 123 79 82 q 42 213 42 164 q 64 303 42 263 q 127 374 86 344 q 224 419 168 403 q 347 436 281 436 q 454 426 400 436 q 550 400 508 417 l 550 458 q 500 598 550 547 q 358 649 450 649 q 128 564 249 649 l 88 643 q 369 738 228 738 q 592 661 513 738 q 672 446 672 585 l 672 150 q 711 106 672 107 l 711 0 q 679 -4 692 -3 q 653 -6 667 -6 q 595 16 617 -6 q 569 68 574 38 l 567 119 q 444 20 518 54 q 285 -14 369 -14 m 317 78 q 438 102 382 78 q 524 167 494 126 q 550 221 550 193 l 550 328 q 365 363 461 363 q 216 324 274 363 q 158 222 158 285 q 170 165 158 192 q 203 119 182 139 q 254 89 225 100 q 317 78 283 78 m 390 846 l 310 874 l 390 1014 l 513 1014 l 390 846 z "
    },
    "ă": {
      "ha": 769,
      "x_min": 42,
      "x_max": 711,
      "o": "m 285 -14 q 189 3 233 -14 q 112 51 144 21 q 60 123 79 82 q 42 213 42 164 q 64 303 42 263 q 127 374 86 344 q 224 419 168 403 q 347 436 281 436 q 454 426 400 436 q 550 400 508 417 l 550 458 q 500 598 550 547 q 358 649 450 649 q 128 564 249 649 l 88 643 q 369 738 228 738 q 592 661 513 738 q 672 446 672 585 l 672 150 q 711 106 672 107 l 711 0 q 679 -4 692 -3 q 653 -6 667 -6 q 595 16 617 -6 q 569 68 574 38 l 567 119 q 444 20 518 54 q 285 -14 369 -14 m 317 78 q 438 102 382 78 q 524 167 494 126 q 550 221 550 193 l 550 328 q 365 363 461 363 q 216 324 274 363 q 158 222 158 285 q 170 165 158 192 q 203 119 182 139 q 254 89 225 100 q 317 78 283 78 m 369 919 q 423 947 400 919 q 450 1014 446 974 l 519 1014 q 508 953 519 981 q 476 904 496 925 q 428 872 456 883 q 369 860 401 860 q 310 872 338 860 q 263 904 283 883 q 231 953 243 925 q 219 1014 219 981 l 290 1014 q 314 948 290 976 q 369 919 338 919 z "
    },
    "â": {
      "ha": 769,
      "x_min": 42,
      "x_max": 711,
      "o": "m 285 -14 q 189 3 233 -14 q 112 51 144 21 q 60 123 79 82 q 42 213 42 164 q 64 303 42 263 q 127 374 86 344 q 224 419 168 403 q 347 436 281 436 q 454 426 400 436 q 550 400 508 417 l 550 458 q 500 598 550 547 q 358 649 450 649 q 128 564 249 649 l 88 643 q 369 738 228 738 q 592 661 513 738 q 672 446 672 585 l 672 150 q 711 106 672 107 l 711 0 q 679 -4 692 -3 q 653 -6 667 -6 q 595 16 617 -6 q 569 68 574 38 l 567 119 q 444 20 518 54 q 285 -14 369 -14 m 317 78 q 438 102 382 78 q 524 167 494 126 q 550 221 550 193 l 550 328 q 365 363 461 363 q 216 324 274 363 q 158 222 158 285 q 170 165 158 192 q 203 119 182 139 q 254 89 225 100 q 317 78 283 78 m 185 889 l 325 1014 l 414 1014 l 554 889 l 488 856 l 369 943 l 251 856 l 185 889 z "
    },
    "ä": {
      "ha": 769,
      "x_min": 42,
      "x_max": 711,
      "o": "m 285 -14 q 189 3 233 -14 q 112 51 144 21 q 60 123 79 82 q 42 213 42 164 q 64 303 42 263 q 127 374 86 344 q 224 419 168 403 q 347 436 281 436 q 454 426 400 436 q 550 400 508 417 l 550 458 q 500 598 550 547 q 358 649 450 649 q 128 564 249 649 l 88 643 q 369 738 228 738 q 592 661 513 738 q 672 446 672 585 l 672 150 q 711 106 672 107 l 711 0 q 679 -4 692 -3 q 653 -6 667 -6 q 595 16 617 -6 q 569 68 574 38 l 567 119 q 444 20 518 54 q 285 -14 369 -14 m 317 78 q 438 102 382 78 q 524 167 494 126 q 550 221 550 193 l 550 328 q 365 363 461 363 q 216 324 274 363 q 158 222 158 285 q 170 165 158 192 q 203 119 182 139 q 254 89 225 100 q 317 78 283 78 m 206 867 l 206 1008 l 308 1008 l 308 867 l 206 867 m 431 867 l 431 1008 l 533 1008 l 533 867 l 431 867 z "
    },
    "æ": {
      "ha": 1296,
      "x_min": 42,
      "x_max": 1258,
      "o": "m 283 -14 q 188 3 232 -14 q 112 51 144 21 q 60 123 79 82 q 42 213 42 164 q 64 303 42 263 q 126 374 86 344 q 223 419 167 403 q 346 436 279 436 q 440 428 393 436 q 525 408 486 421 q 532 456 528 431 q 544 500 536 481 q 485 610 533 571 q 357 649 438 649 q 126 564 249 649 l 86 643 q 368 738 229 738 q 521 703 457 738 q 619 606 585 668 q 735 701 665 665 q 890 738 804 738 q 1040 708 972 738 q 1156 626 1108 678 q 1231 507 1204 575 q 1258 363 1258 439 q 1258 341 1258 354 q 1256 321 1257 328 l 640 321 q 667 222 644 267 q 724 146 689 178 q 803 96 758 114 q 899 78 849 78 q 964 87 932 78 q 1024 111 996 96 q 1073 149 1051 126 q 1106 199 1094 171 l 1211 169 q 1162 96 1193 129 q 1090 38 1131 63 q 999 0 1049 14 q 894 -14 949 -14 q 718 29 796 -14 q 592 143 640 72 q 532 72 568 101 q 454 23 496 42 q 368 -5 413 4 q 283 -14 324 -14 m 315 78 q 438 102 382 78 q 524 167 493 126 q 550 215 547 190 q 533 274 539 239 q 525 336 526 310 q 446 356 488 349 q 364 363 404 363 q 215 324 272 363 q 157 222 157 285 q 169 165 157 192 q 203 119 182 139 q 253 89 224 100 q 315 78 282 78 m 1142 400 q 1117 499 1138 454 q 1063 577 1096 544 q 985 628 1029 610 q 889 646 940 646 q 793 628 838 646 q 715 577 749 610 q 662 499 682 544 q 639 400 642 454 l 1142 400 z "
    },
    "ǽ": {
      "ha": 1296,
      "x_min": 42,
      "x_max": 1258,
      "o": "m 639 846 l 558 874 l 639 1014 l 761 1014 l 639 846 m 283 -14 q 188 3 232 -14 q 112 51 144 21 q 60 123 79 82 q 42 213 42 164 q 64 303 42 263 q 126 374 86 344 q 223 419 167 403 q 346 436 279 436 q 440 428 393 436 q 525 408 486 421 q 532 456 528 431 q 544 500 536 481 q 485 610 533 571 q 357 649 438 649 q 126 564 249 649 l 86 643 q 368 738 229 738 q 521 703 457 738 q 619 606 585 668 q 735 701 665 665 q 890 738 804 738 q 1040 708 972 738 q 1156 626 1108 678 q 1231 507 1204 575 q 1258 363 1258 439 q 1258 341 1258 354 q 1256 321 1257 328 l 640 321 q 667 222 644 267 q 724 146 689 178 q 803 96 758 114 q 899 78 849 78 q 964 87 932 78 q 1024 111 996 96 q 1073 149 1051 126 q 1106 199 1094 171 l 1211 169 q 1162 96 1193 129 q 1090 38 1131 63 q 999 0 1049 14 q 894 -14 949 -14 q 718 29 796 -14 q 592 143 640 72 q 532 72 568 101 q 454 23 496 42 q 368 -5 413 4 q 283 -14 324 -14 m 315 78 q 438 102 382 78 q 524 167 493 126 q 550 215 547 190 q 533 274 539 239 q 525 336 526 310 q 446 356 488 349 q 364 363 404 363 q 215 324 272 363 q 157 222 157 285 q 169 165 157 192 q 203 119 182 139 q 253 89 224 100 q 315 78 282 78 m 1142 400 q 1117 499 1138 454 q 1063 577 1096 544 q 985 628 1029 610 q 889 646 940 646 q 793 628 838 646 q 715 577 749 610 q 662 499 682 544 q 639 400 642 454 l 1142 400 z "
    },
    "à": {
      "ha": 769,
      "x_min": 42,
      "x_max": 711,
      "o": "m 285 -14 q 189 3 233 -14 q 112 51 144 21 q 60 123 79 82 q 42 213 42 164 q 64 303 42 263 q 127 374 86 344 q 224 419 168 403 q 347 436 281 436 q 454 426 400 436 q 550 400 508 417 l 550 458 q 500 598 550 547 q 358 649 450 649 q 128 564 249 649 l 88 643 q 369 738 228 738 q 592 661 513 738 q 672 446 672 585 l 672 150 q 711 106 672 107 l 711 0 q 679 -4 692 -3 q 653 -6 667 -6 q 595 16 617 -6 q 569 68 574 38 l 567 119 q 444 20 518 54 q 285 -14 369 -14 m 317 78 q 438 102 382 78 q 524 167 494 126 q 550 221 550 193 l 550 328 q 365 363 461 363 q 216 324 274 363 q 158 222 158 285 q 170 165 158 192 q 203 119 182 139 q 254 89 225 100 q 317 78 283 78 m 225 1014 l 346 1014 l 428 874 l 349 846 l 225 1014 z "
    },
    "ā": {
      "ha": 769,
      "x_min": 42,
      "x_max": 711,
      "o": "m 285 -14 q 189 3 233 -14 q 112 51 144 21 q 60 123 79 82 q 42 213 42 164 q 64 303 42 263 q 127 374 86 344 q 224 419 168 403 q 347 436 281 436 q 454 426 400 436 q 550 400 508 417 l 550 458 q 500 598 550 547 q 358 649 450 649 q 128 564 249 649 l 88 643 q 369 738 228 738 q 592 661 513 738 q 672 446 672 585 l 672 150 q 711 106 672 107 l 711 0 q 679 -4 692 -3 q 653 -6 667 -6 q 595 16 617 -6 q 569 68 574 38 l 567 119 q 444 20 518 54 q 285 -14 369 -14 m 317 78 q 438 102 382 78 q 524 167 494 126 q 550 221 550 193 l 550 328 q 365 363 461 363 q 216 324 274 363 q 158 222 158 285 q 170 165 158 192 q 203 119 182 139 q 254 89 225 100 q 317 78 283 78 m 167 908 l 167 989 l 572 989 l 572 908 l 167 908 z "
    },
    "&": {
      "ha": 946,
      "x_min": 63,
      "x_max": 939,
      "o": "m 778 0 l 675 107 q 541 17 615 49 q 382 -14 467 -14 q 256 7 314 -14 q 154 65 197 28 q 87 151 111 101 q 63 261 63 201 q 78 351 63 310 q 122 428 94 393 q 183 492 149 463 q 257 549 218 522 q 200 617 224 586 q 162 674 176 647 q 140 726 147 701 q 133 776 133 750 q 153 865 133 824 q 206 935 172 906 q 287 982 240 965 q 388 999 333 999 q 481 985 438 999 q 558 944 525 971 q 609 881 590 918 q 628 797 628 843 q 612 719 628 756 q 569 652 596 683 q 504 593 542 621 q 425 538 467 565 l 676 274 q 717 383 703 324 q 732 508 732 442 l 833 508 q 810 340 832 418 q 749 199 789 263 l 939 0 l 778 0 m 394 83 q 511 108 457 83 q 608 178 565 133 l 328 474 q 222 376 263 426 q 181 260 181 325 q 199 185 181 218 q 247 129 217 151 q 315 95 276 107 q 394 83 353 83 m 246 779 q 251 749 246 764 q 267 716 256 735 q 300 672 279 697 q 354 611 321 646 q 471 699 426 657 q 515 794 515 742 q 479 874 515 843 q 388 906 443 906 q 285 869 325 906 q 246 779 246 832 z "
    },
    "ą": {
      "ha": 769,
      "x_min": 42,
      "x_max": 711,
      "o": "m 643 -251 q 556 -212 585 -240 q 526 -144 526 -183 q 551 -74 526 -108 q 629 -3 576 -39 q 588 24 603 4 q 569 68 572 43 l 567 119 q 444 20 518 54 q 285 -14 369 -14 q 189 3 233 -14 q 112 51 144 21 q 60 123 79 82 q 42 213 42 164 q 64 303 42 263 q 127 374 86 344 q 224 419 168 403 q 347 436 281 436 q 454 426 400 436 q 550 400 508 417 l 550 458 q 500 598 550 547 q 358 649 450 649 q 128 564 249 649 l 88 643 q 369 738 228 738 q 592 661 513 738 q 672 446 672 585 l 672 150 q 711 106 672 107 l 711 0 q 624 -67 650 -37 q 597 -128 597 -97 q 674 -187 597 -179 l 643 -251 m 317 78 q 438 102 382 78 q 524 167 494 126 q 550 221 550 193 l 550 328 q 365 363 461 363 q 216 324 274 363 q 158 222 158 285 q 170 165 158 192 q 203 119 182 139 q 254 89 225 100 q 317 78 283 78 z "
    },
    "ʼ": {
      "ha": 754,
      "x_min": 289,
      "x_max": 492,
      "o": "m 368 846 l 289 874 l 340 961 l 336 1014 l 492 1014 l 368 846 z "
    },
    "å": {
      "ha": 769,
      "x_min": 42,
      "x_max": 711,
      "o": "m 285 -14 q 189 3 233 -14 q 112 51 144 21 q 60 123 79 82 q 42 213 42 164 q 64 303 42 263 q 127 374 86 344 q 224 419 168 403 q 347 436 281 436 q 454 426 400 436 q 550 400 508 417 l 550 458 q 500 598 550 547 q 358 649 450 649 q 128 564 249 649 l 88 643 q 369 738 228 738 q 592 661 513 738 q 672 446 672 585 l 672 150 q 711 106 672 107 l 711 0 q 679 -4 692 -3 q 653 -6 667 -6 q 595 16 617 -6 q 569 68 574 38 l 567 119 q 444 20 518 54 q 285 -14 369 -14 m 317 78 q 438 102 382 78 q 524 167 494 126 q 550 221 550 193 l 550 328 q 365 363 461 363 q 216 324 274 363 q 158 222 158 285 q 170 165 158 192 q 203 119 182 139 q 254 89 225 100 q 317 78 283 78 m 256 918 q 288 988 256 963 q 368 1014 319 1014 q 449 988 418 1014 q 481 918 481 963 q 449 848 481 874 q 368 822 418 822 q 288 848 319 822 q 256 918 256 874 m 368 971 q 328 956 344 971 q 313 918 313 942 q 328 881 313 896 q 368 865 344 865 q 408 880 390 865 q 425 918 425 894 q 408 956 425 942 q 368 971 392 971 z "
    },
    "ǻ": {
      "ha": 769,
      "x_min": 42,
      "x_max": 711,
      "o": "m 285 -14 q 189 3 233 -14 q 112 51 144 21 q 60 123 79 82 q 42 213 42 164 q 64 303 42 263 q 127 374 86 344 q 224 419 168 403 q 347 436 281 436 q 454 426 400 436 q 550 400 508 417 l 550 458 q 500 598 550 547 q 358 649 450 649 q 128 564 249 649 l 88 643 q 369 738 228 738 q 592 661 513 738 q 672 446 672 585 l 672 150 q 711 106 672 107 l 711 0 q 679 -4 692 -3 q 653 -6 667 -6 q 595 16 617 -6 q 569 68 574 38 l 567 119 q 444 20 518 54 q 285 -14 369 -14 m 317 78 q 438 102 382 78 q 524 167 494 126 q 550 221 550 193 l 550 328 q 365 363 461 363 q 216 324 274 363 q 158 222 158 285 q 170 165 158 192 q 203 119 182 139 q 254 89 225 100 q 317 78 283 78 m 390 1063 l 310 1090 l 390 1231 l 513 1231 l 390 1063 m 256 918 q 288 988 256 963 q 368 1014 319 1014 q 449 988 418 1014 q 481 918 481 963 q 449 848 481 874 q 368 822 418 822 q 288 848 319 822 q 256 918 256 874 m 368 971 q 328 956 344 971 q 313 918 313 942 q 328 881 313 896 q 368 865 344 865 q 408 880 390 865 q 425 918 425 894 q 408 956 425 942 q 368 971 392 971 z "
    },
    "^": {
      "ha": 768,
      "x_min": 58,
      "x_max": 710,
      "o": "m 58 421 l 333 986 l 436 986 l 710 421 l 606 421 l 385 876 l 160 421 l 58 421 z "
    },
    "~": {
      "ha": 739,
      "x_min": 90,
      "x_max": 650,
      "o": "m 90 329 q 99 363 90 338 q 126 415 107 388 q 176 463 146 442 q 253 485 207 485 q 315 472 286 485 q 372 445 344 460 q 426 418 399 431 q 482 406 453 406 q 527 416 508 406 q 557 439 546 426 q 573 463 568 451 q 578 478 578 475 l 650 478 q 642 450 650 474 q 614 399 633 426 q 562 351 594 372 q 481 329 529 329 q 415 341 444 329 q 357 367 385 353 q 303 394 329 382 q 251 407 278 407 q 209 395 226 407 q 181 369 192 383 q 167 342 171 354 q 163 329 163 331 l 90 329 l 90 329 z "
    },
    "*": {
      "ha": 457,
      "x_min": 82,
      "x_max": 375,
      "o": "m 117 747 l 178 838 l 82 868 l 100 926 l 197 889 l 193 992 l 264 992 l 260 889 l 357 926 l 375 868 l 279 838 l 342 747 l 289 713 l 229 806 l 168 713 l 117 747 z "
    },
    "@": {
      "ha": 1167,
      "x_min": 64,
      "x_max": 1092,
      "o": "m 582 838 q 777 800 685 838 q 940 694 869 763 q 1051 527 1010 625 q 1092 308 1092 429 q 1090 256 1092 289 q 1081 188 1088 224 q 1060 114 1074 151 q 1024 46 1047 76 q 966 -3 1000 15 q 885 -22 932 -22 q 826 -12 849 -22 q 791 16 804 -1 q 772 56 778 33 q 764 101 767 78 q 663 31 724 60 q 528 3 601 3 q 372 56 426 3 q 317 192 317 110 q 340 283 317 246 q 400 343 363 321 q 484 375 438 365 q 576 385 531 385 q 681 373 636 385 q 747 353 725 361 q 740 437 747 399 q 713 502 732 475 q 662 544 694 529 q 579 560 629 560 q 475 542 524 560 q 388 496 426 525 l 360 564 q 467 616 410 597 q 590 635 525 635 q 718 608 671 635 q 789 540 765 582 q 819 448 813 499 q 825 349 825 397 l 825 183 q 827 126 825 153 q 836 81 829 100 q 858 50 843 61 q 896 39 872 39 q 964 68 938 39 q 1006 140 990 97 q 1028 228 1022 182 q 1033 311 1033 275 q 999 497 1033 411 q 904 646 965 582 q 760 746 843 710 q 579 782 676 782 q 400 747 483 782 q 255 651 317 713 q 158 505 193 590 q 122 319 122 419 q 156 138 122 222 q 249 -10 189 53 q 390 -110 308 -74 q 569 -147 472 -147 q 682 -133 632 -147 q 783 -94 732 -118 l 803 -147 q 687 -189 746 -175 q 568 -203 628 -203 q 372 -164 464 -203 q 212 -56 281 -125 q 103 110 143 14 q 64 319 64 206 q 107 535 64 439 q 222 698 150 631 q 387 801 293 765 q 582 838 481 838 m 661 106 q 731 166 715 131 q 746 238 746 201 l 746 289 q 683 306 728 292 q 575 319 638 319 q 507 313 539 319 q 450 292 475 307 q 410 255 425 278 q 396 197 396 232 q 433 110 396 144 q 533 75 471 75 q 601 84 567 75 q 661 106 635 93 z "
    },
    "ã": {
      "ha": 769,
      "x_min": 42,
      "x_max": 711,
      "o": "m 285 -14 q 189 3 233 -14 q 112 51 144 21 q 60 123 79 82 q 42 213 42 164 q 64 303 42 263 q 127 374 86 344 q 224 419 168 403 q 347 436 281 436 q 454 426 400 436 q 550 400 508 417 l 550 458 q 500 598 550 547 q 358 649 450 649 q 128 564 249 649 l 88 643 q 369 738 228 738 q 592 661 513 738 q 672 446 672 585 l 672 150 q 711 106 672 107 l 711 0 q 679 -4 692 -3 q 653 -6 667 -6 q 595 16 617 -6 q 569 68 574 38 l 567 119 q 444 20 518 54 q 285 -14 369 -14 m 317 78 q 438 102 382 78 q 524 167 494 126 q 550 221 550 193 l 550 328 q 365 363 461 363 q 216 324 274 363 q 158 222 158 285 q 170 165 158 192 q 203 119 182 139 q 254 89 225 100 q 317 78 283 78 m 456 871 q 401 880 424 871 q 358 900 378 889 q 318 920 338 911 q 276 929 299 929 q 240 919 253 929 q 219 898 226 910 q 210 875 213 886 q 208 863 208 864 l 136 863 q 142 894 136 871 q 164 943 149 918 q 206 987 179 968 q 274 1006 232 1006 q 325 997 303 1006 q 367 976 347 988 q 408 955 388 964 q 453 946 428 946 q 494 956 479 946 q 518 978 510 965 q 528 1001 526 990 q 531 1014 531 1011 l 603 1014 q 597 983 603 1006 q 574 935 590 960 q 528 890 557 910 q 456 871 500 871 z "
    },
    "b": {
      "ha": 865,
      "x_min": 99,
      "x_max": 814,
      "o": "m 471 -14 q 317 28 386 -14 q 207 136 247 69 l 207 0 l 99 0 l 99 1014 l 221 1014 l 221 581 q 333 694 267 651 q 489 738 400 738 q 624 706 564 738 q 726 622 683 674 q 791 501 768 569 q 814 360 814 432 q 788 215 814 283 q 715 97 761 147 q 606 16 669 46 q 471 -14 543 -14 m 440 92 q 540 114 494 92 q 619 174 586 136 q 671 259 653 211 q 689 360 689 307 q 672 462 689 413 q 623 549 654 511 q 548 609 592 586 q 451 632 504 632 q 378 618 413 632 q 313 581 343 604 q 260 528 283 558 q 221 463 238 497 l 221 253 q 251 189 228 218 q 305 138 274 160 q 372 104 336 117 q 440 92 407 92 z "
    },
    "\\": {
      "ha": 819,
      "x_min": 39,
      "x_max": 781,
      "o": "m 176 986 l 781 0 l 644 0 l 39 986 l 176 986 z "
    },
    "|": {
      "ha": 333,
      "x_min": 114,
      "x_max": 219,
      "o": "m 114 -181 l 114 1076 l 219 1076 l 219 -181 l 114 -181 z "
    },
    "{": {
      "ha": 376,
      "x_min": 65,
      "x_max": 311,
      "o": "m 235 928 l 235 589 q 226 544 235 569 q 194 500 217 519 q 225 456 215 481 q 235 411 235 431 l 235 57 l 311 57 l 311 -43 l 156 -43 q 134 -34 144 -43 q 124 -1 124 -25 l 124 375 q 108 429 124 406 q 65 457 92 453 l 65 546 q 90 554 79 546 q 109 575 101 563 q 120 601 117 588 q 124 625 124 614 l 124 986 q 136 1020 124 1013 q 156 1028 149 1028 l 311 1028 l 311 928 l 235 928 z "
    },
    "}": {
      "ha": 376,
      "x_min": 65,
      "x_max": 311,
      "o": "m 65 928 l 65 1028 l 221 1028 q 240 1020 228 1028 q 253 986 253 1013 l 253 625 q 256 601 253 614 q 267 575 260 588 q 285 554 275 563 q 311 546 296 546 l 311 457 q 268 429 283 453 q 253 375 253 406 l 253 -1 q 242 -34 253 -25 q 221 -43 231 -43 l 65 -43 l 65 57 l 142 57 l 142 411 q 151 456 142 431 q 182 500 160 481 q 151 544 160 519 q 142 589 142 569 l 142 928 l 65 928 z "
    },
    "[": {
      "ha": 375,
      "x_min": 117,
      "x_max": 311,
      "o": "m 117 -56 l 117 1028 l 311 1028 l 311 928 l 231 928 l 231 44 l 311 44 l 311 -56 l 117 -56 z "
    },
    "]": {
      "ha": 375,
      "x_min": 64,
      "x_max": 258,
      "o": "m 64 -56 l 64 44 l 144 44 l 144 928 l 64 928 l 64 1028 l 258 1028 l 258 -56 l 64 -56 z "
    },
    "¦": {
      "ha": 336,
      "x_min": 115,
      "x_max": 221,
      "o": "m 221 379 l 221 -181 l 115 -181 l 115 379 l 221 379 m 221 1076 l 221 517 l 115 517 l 115 1076 l 221 1076 z "
    },
    "•": {
      "ha": 494,
      "x_min": 117,
      "x_max": 378,
      "o": "m 378 482 q 367 431 378 454 q 340 390 357 407 q 298 362 322 372 q 247 351 274 351 q 197 362 221 351 q 156 390 174 372 q 127 431 138 407 q 117 482 117 454 q 127 532 117 508 q 156 574 138 556 q 197 602 174 592 q 247 613 221 613 q 298 602 274 613 q 340 574 322 592 q 367 532 357 556 q 378 482 378 508 z "
    },
    "c": {
      "ha": 769,
      "x_min": 50,
      "x_max": 729,
      "o": "m 50 364 q 76 508 50 440 q 151 627 103 576 q 267 708 200 678 q 418 738 335 738 q 605 690 526 738 q 724 561 683 642 l 604 524 q 526 603 576 575 q 415 632 476 632 q 321 612 365 632 q 244 556 276 592 q 194 471 213 519 q 175 364 175 422 q 194 257 175 307 q 247 170 214 207 q 323 113 279 133 q 417 92 367 92 q 480 101 449 92 q 537 125 511 110 q 582 160 563 140 q 610 204 601 181 l 729 168 q 683 94 713 128 q 613 38 653 61 q 523 0 572 14 q 419 -14 474 -14 q 269 17 338 -14 q 153 99 201 47 q 77 219 104 150 q 50 364 50 288 z "
    },
    "ć": {
      "ha": 769,
      "x_min": 50,
      "x_max": 729,
      "o": "m 438 846 l 357 874 l 438 1014 l 560 1014 l 438 846 m 50 364 q 76 508 50 440 q 151 627 103 576 q 267 708 200 678 q 418 738 335 738 q 605 690 526 738 q 724 561 683 642 l 604 524 q 526 603 576 575 q 415 632 476 632 q 321 612 365 632 q 244 556 276 592 q 194 471 213 519 q 175 364 175 422 q 194 257 175 307 q 247 170 214 207 q 323 113 279 133 q 417 92 367 92 q 480 101 449 92 q 537 125 511 110 q 582 160 563 140 q 610 204 601 181 l 729 168 q 683 94 713 128 q 613 38 653 61 q 523 0 572 14 q 419 -14 474 -14 q 269 17 338 -14 q 153 99 201 47 q 77 219 104 150 q 50 364 50 288 z "
    },
    "č": {
      "ha": 769,
      "x_min": 50,
      "x_max": 729,
      "o": "m 299 1014 l 417 926 l 535 1014 l 601 981 l 461 856 l 372 856 l 232 981 l 299 1014 m 50 364 q 76 508 50 440 q 151 627 103 576 q 267 708 200 678 q 418 738 335 738 q 605 690 526 738 q 724 561 683 642 l 604 524 q 526 603 576 575 q 415 632 476 632 q 321 612 365 632 q 244 556 276 592 q 194 471 213 519 q 175 364 175 422 q 194 257 175 307 q 247 170 214 207 q 323 113 279 133 q 417 92 367 92 q 480 101 449 92 q 537 125 511 110 q 582 160 563 140 q 610 204 601 181 l 729 168 q 683 94 713 128 q 613 38 653 61 q 523 0 572 14 q 419 -14 474 -14 q 269 17 338 -14 q 153 99 201 47 q 77 219 104 150 q 50 364 50 288 z "
    },
    "ç": {
      "ha": 769,
      "x_min": 50,
      "x_max": 729,
      "o": "m 311 -175 q 363 -193 329 -185 q 433 -201 397 -201 q 492 -190 471 -201 q 513 -153 513 -179 q 493 -115 513 -125 q 442 -104 474 -104 q 381 -110 413 -104 q 331 -122 349 -117 l 389 -12 q 251 25 314 -7 q 144 108 189 57 q 74 225 99 160 q 50 364 50 290 q 76 508 50 440 q 151 627 103 576 q 267 708 200 678 q 418 738 335 738 q 605 690 526 738 q 724 561 683 642 l 604 524 q 526 603 576 575 q 415 632 476 632 q 321 612 365 632 q 244 556 276 592 q 194 471 213 519 q 175 364 175 422 q 194 257 175 307 q 247 170 214 207 q 323 113 279 133 q 417 92 367 92 q 480 101 449 92 q 537 125 511 110 q 582 160 563 140 q 610 204 601 181 l 729 168 q 624 44 699 93 q 451 -12 550 -4 l 417 -67 q 442 -61 428 -62 q 467 -60 456 -60 q 546 -82 515 -60 q 576 -149 576 -104 q 538 -225 576 -197 q 424 -253 499 -253 q 347 -245 382 -253 q 283 -226 311 -237 l 311 -175 z "
    },
    "ĉ": {
      "ha": 769,
      "x_min": 50,
      "x_max": 729,
      "o": "m 232 889 l 372 1014 l 461 1014 l 601 889 l 535 856 l 417 943 l 299 856 l 232 889 m 50 364 q 76 508 50 440 q 151 627 103 576 q 267 708 200 678 q 418 738 335 738 q 605 690 526 738 q 724 561 683 642 l 604 524 q 526 603 576 575 q 415 632 476 632 q 321 612 365 632 q 244 556 276 592 q 194 471 213 519 q 175 364 175 422 q 194 257 175 307 q 247 170 214 207 q 323 113 279 133 q 417 92 367 92 q 480 101 449 92 q 537 125 511 110 q 582 160 563 140 q 610 204 601 181 l 729 168 q 683 94 713 128 q 613 38 653 61 q 523 0 572 14 q 419 -14 474 -14 q 269 17 338 -14 q 153 99 201 47 q 77 219 104 150 q 50 364 50 288 z "
    },
    "ċ": {
      "ha": 769,
      "x_min": 50,
      "x_max": 729,
      "o": "m 50 364 q 76 508 50 440 q 151 627 103 576 q 267 708 200 678 q 418 738 335 738 q 605 690 526 738 q 724 561 683 642 l 604 524 q 526 603 576 575 q 415 632 476 632 q 321 612 365 632 q 244 556 276 592 q 194 471 213 519 q 175 364 175 422 q 194 257 175 307 q 247 170 214 207 q 323 113 279 133 q 417 92 367 92 q 480 101 449 92 q 537 125 511 110 q 582 160 563 140 q 610 204 601 181 l 729 168 q 683 94 713 128 q 613 38 653 61 q 523 0 572 14 q 419 -14 474 -14 q 269 17 338 -14 q 153 99 201 47 q 77 219 104 150 q 50 364 50 288 m 361 867 l 361 1014 l 472 1014 l 472 867 l 361 867 z "
    },
    "¢": {
      "ha": 792,
      "x_min": 58,
      "x_max": 739,
      "o": "m 383 -167 l 383 -12 q 253 27 313 -7 q 150 113 193 61 q 83 228 107 164 q 58 358 58 292 q 81 494 58 429 q 144 609 103 558 q 247 694 186 660 q 383 736 307 728 l 383 896 l 444 896 l 444 736 q 619 688 546 733 q 732 561 692 642 l 614 524 q 542 599 586 574 q 444 628 497 625 l 444 94 q 497 105 469 96 q 549 128 524 114 q 593 161 574 142 q 619 204 613 181 l 739 168 q 687 88 721 122 q 611 31 653 54 q 526 -3 569 8 q 444 -14 482 -14 l 444 -167 l 383 -167 m 183 358 q 198 269 183 313 q 240 192 213 226 q 303 133 267 157 q 383 100 339 108 l 383 624 q 299 593 336 618 q 235 531 261 568 q 197 449 210 494 q 183 358 183 404 z "
    },
    ":": {
      "ha": 279,
      "x_min": 89,
      "x_max": 190,
      "o": "m 89 564 l 89 719 l 190 719 l 190 564 l 89 564 m 89 0 l 89 156 l 190 156 l 190 0 l 89 0 z "
    },
    ",": {
      "ha": 293,
      "x_min": 89,
      "x_max": 204,
      "o": "m 103 -112 l 131 11 l 89 11 l 89 156 l 204 156 l 204 11 l 163 -112 l 103 -112 z "
    },
    "©": {
      "ha": 1161,
      "x_min": 65,
      "x_max": 1096,
      "o": "m 578 -10 q 373 28 467 -10 q 211 134 279 67 q 104 293 143 201 q 65 493 65 385 q 104 692 65 600 q 211 850 143 783 q 373 955 279 917 q 578 993 467 993 q 784 955 689 993 q 949 850 879 917 q 1057 692 1018 783 q 1096 493 1096 600 q 1057 293 1096 385 q 949 134 1018 201 q 784 28 879 67 q 578 -10 689 -10 m 578 43 q 759 76 675 43 q 906 167 843 108 q 1003 308 968 226 q 1039 490 1039 390 q 1004 669 1039 586 q 908 812 969 751 q 762 906 846 872 q 578 940 678 940 q 396 906 479 940 q 251 812 313 872 q 156 669 190 751 q 121 492 121 588 q 156 314 121 396 q 251 172 190 232 q 396 77 313 111 q 578 43 479 43 m 589 168 q 460 192 521 168 q 355 258 400 215 q 283 361 310 301 q 257 493 257 421 q 277 611 257 553 q 338 716 297 669 q 439 791 378 763 q 582 819 500 819 q 753 778 679 819 q 861 658 828 736 l 743 621 q 710 667 731 649 q 669 695 690 685 q 624 710 647 706 q 582 714 601 714 q 494 695 532 714 q 432 645 457 676 q 394 574 407 614 q 382 493 382 535 q 401 399 382 440 q 449 331 419 358 q 514 288 478 303 q 585 274 550 274 q 681 299 633 274 q 751 371 729 325 l 869 335 q 833 277 858 307 q 772 223 808 247 q 690 183 736 199 q 589 168 643 168 z "
    },
    "d": {
      "ha": 874,
      "x_min": 51,
      "x_max": 807,
      "o": "m 397 -14 q 258 17 322 -14 q 149 99 194 47 q 77 218 103 150 q 51 361 51 286 q 76 506 51 438 q 144 626 100 575 q 248 708 188 678 q 381 738 308 738 q 537 692 468 738 q 646 581 606 646 l 646 1014 l 768 1014 l 768 150 q 807 106 768 107 l 807 0 q 776 -4 788 -3 q 753 -6 764 -6 q 690 19 717 -6 q 663 75 663 43 l 663 136 q 548 26 619 65 q 397 -14 476 -14 m 426 92 q 495 104 460 92 q 562 139 531 117 q 616 191 593 161 q 646 254 639 221 l 646 463 q 608 528 633 497 q 552 583 583 560 q 485 619 521 606 q 415 632 450 632 q 317 609 361 632 q 242 548 274 586 q 194 460 211 510 q 178 360 178 411 q 197 256 178 306 q 250 171 217 207 q 328 113 283 135 q 426 92 374 92 z "
    },
    "†": {
      "ha": 585,
      "x_min": 51,
      "x_max": 533,
      "o": "m 235 -181 l 235 321 l 51 321 l 51 432 l 235 432 l 235 1076 l 351 1076 l 351 432 l 533 432 l 533 321 l 351 321 l 351 -181 l 235 -181 z "
    },
    "‡": {
      "ha": 588,
      "x_min": 53,
      "x_max": 535,
      "o": "m 236 -181 l 236 197 l 53 197 l 53 308 l 236 308 l 236 463 l 53 463 l 53 574 l 236 574 l 236 1076 l 353 1076 l 353 574 l 535 574 l 535 463 l 353 463 l 353 308 l 535 308 l 535 197 l 353 197 l 353 -181 l 236 -181 z "
    },
    "ď": {
      "ha": 874,
      "x_min": 51,
      "x_max": 1017,
      "o": "m 894 846 l 814 874 l 894 1014 l 1017 1014 l 894 846 m 397 -14 q 258 17 322 -14 q 149 99 194 47 q 77 218 103 150 q 51 361 51 286 q 76 506 51 438 q 144 626 100 575 q 248 708 188 678 q 381 738 308 738 q 537 692 468 738 q 646 581 606 646 l 646 1014 l 768 1014 l 768 150 q 807 106 768 107 l 807 0 q 776 -4 788 -3 q 753 -6 764 -6 q 690 19 717 -6 q 663 75 663 43 l 663 136 q 548 26 619 65 q 397 -14 476 -14 m 426 92 q 495 104 460 92 q 562 139 531 117 q 616 191 593 161 q 646 254 639 221 l 646 463 q 608 528 633 497 q 552 583 583 560 q 485 619 521 606 q 415 632 450 632 q 317 609 361 632 q 242 548 274 586 q 194 460 211 510 q 178 360 178 411 q 197 256 178 306 q 250 171 217 207 q 328 113 283 135 q 426 92 374 92 z "
    },
    "đ": {
      "ha": 874,
      "x_min": 51,
      "x_max": 863,
      "o": "m 397 -14 q 258 17 322 -14 q 149 99 194 47 q 77 218 103 150 q 51 361 51 286 q 76 506 51 438 q 144 626 100 575 q 248 708 188 678 q 381 738 308 738 q 537 692 468 738 q 646 581 606 646 l 646 849 l 493 849 l 493 926 l 646 926 l 646 1014 l 768 1014 l 768 926 l 863 926 l 863 849 l 768 849 l 768 150 q 807 106 768 107 l 807 0 q 776 -4 788 -3 q 753 -6 764 -6 q 690 19 717 -6 q 663 75 663 43 l 663 136 q 548 26 619 65 q 397 -14 476 -14 m 426 92 q 495 104 460 92 q 562 139 531 117 q 616 191 593 161 q 646 254 639 221 l 646 463 q 608 528 633 497 q 552 583 583 560 q 485 619 521 606 q 415 632 450 632 q 317 609 361 632 q 242 548 274 586 q 194 460 211 510 q 178 360 178 411 q 197 256 178 306 q 250 171 217 207 q 328 113 283 135 q 426 92 374 92 z "
    },
    "°": {
      "ha": 378,
      "x_min": 65,
      "x_max": 313,
      "o": "m 65 885 q 101 971 65 936 q 189 1006 136 1006 q 277 971 242 1006 q 313 885 313 936 q 277 794 313 829 q 189 758 242 758 q 101 794 136 758 q 65 885 65 831 m 147 924 q 131 882 131 904 q 147 842 131 858 q 189 824 165 824 q 231 842 215 824 q 247 882 247 858 q 231 924 247 904 q 189 940 215 940 q 147 924 164 940 z "
    },
    "÷": {
      "ha": 740,
      "x_min": 90,
      "x_max": 650,
      "o": "m 318 563 l 318 704 l 422 704 l 422 563 l 318 563 m 318 92 l 318 233 l 422 233 l 422 92 l 318 92 m 90 349 l 90 449 l 650 449 l 650 349 l 90 349 z "
    },
    "$": {
      "ha": 864,
      "x_min": 49,
      "x_max": 808,
      "o": "m 706 779 q 664 815 689 797 q 606 847 639 832 q 536 870 574 861 q 457 881 499 879 l 457 551 l 475 547 q 613 509 551 531 q 719 456 675 488 q 785 378 763 424 q 808 265 808 332 q 782 144 808 196 q 710 60 756 93 q 601 9 664 26 q 465 -10 538 -8 l 465 -149 l 404 -149 l 404 -8 q 49 129 201 4 l 108 235 q 160 192 129 214 q 230 153 190 171 q 315 122 269 135 q 411 104 361 108 l 411 436 l 390 442 q 258 481 315 460 q 163 531 201 501 q 106 601 125 560 q 86 701 86 643 q 110 820 86 768 q 176 909 133 872 q 276 967 218 946 q 404 992 335 988 l 404 1132 l 465 1132 l 465 992 q 631 958 557 988 q 764 881 706 929 l 706 779 m 675 253 q 660 315 675 289 q 618 360 646 340 q 550 396 590 381 q 457 425 510 411 l 457 103 q 618 140 561 103 q 675 253 675 178 m 215 721 q 227 661 215 686 q 263 618 239 636 q 324 587 286 600 q 411 561 361 574 l 411 881 q 263 833 310 875 q 215 721 215 792 z "
    },
    "ı": {
      "ha": 319,
      "x_min": 99,
      "x_max": 221,
      "o": "m 99 0 l 99 725 l 221 725 l 221 0 l 99 0 z "
    },
    "ȷ": {
      "ha": 319,
      "x_min": -171,
      "x_max": 221,
      "o": "m -4 -258 q -95 -244 -53 -258 q -171 -200 -137 -231 l -114 -118 q -69 -143 -94 -136 q -18 -150 -43 -150 q 25 -141 4 -150 q 63 -117 46 -132 q 89 -79 79 -101 q 99 -32 99 -57 l 99 725 l 221 725 l 221 -24 q 202 -118 221 -75 q 152 -192 183 -161 q 81 -241 121 -224 q -4 -258 40 -258 z "
    },
    "e": {
      "ha": 821,
      "x_min": 50,
      "x_max": 783,
      "o": "m 419 -14 q 269 16 338 -14 q 153 97 201 46 q 77 217 104 149 q 50 363 50 286 q 77 507 50 439 q 153 626 104 575 q 271 708 203 678 q 421 738 339 738 q 570 707 503 738 q 685 626 638 676 q 758 508 732 575 q 783 368 783 440 q 783 340 783 353 q 781 321 782 328 l 179 321 q 204 222 183 267 q 258 146 225 178 q 334 96 292 114 q 424 78 376 78 q 489 87 457 78 q 549 111 521 96 q 598 149 576 126 q 631 199 619 171 l 736 169 q 687 96 718 129 q 615 38 656 63 q 524 0 574 14 q 419 -14 474 -14 m 668 411 q 642 506 664 463 q 588 581 621 550 q 513 628 556 611 q 421 646 469 646 q 329 628 372 646 q 253 580 286 611 q 201 506 221 549 q 176 411 181 463 l 668 411 z "
    },
    "é": {
      "ha": 821,
      "x_min": 50,
      "x_max": 783,
      "o": "m 436 846 l 356 874 l 436 1014 l 558 1014 l 436 846 m 419 -14 q 269 16 338 -14 q 153 97 201 46 q 77 217 104 149 q 50 363 50 286 q 77 507 50 439 q 153 626 104 575 q 271 708 203 678 q 421 738 339 738 q 570 707 503 738 q 685 626 638 676 q 758 508 732 575 q 783 368 783 440 q 783 340 783 353 q 781 321 782 328 l 179 321 q 204 222 183 267 q 258 146 225 178 q 334 96 292 114 q 424 78 376 78 q 489 87 457 78 q 549 111 521 96 q 598 149 576 126 q 631 199 619 171 l 736 169 q 687 96 718 129 q 615 38 656 63 q 524 0 574 14 q 419 -14 474 -14 m 668 411 q 642 506 664 463 q 588 581 621 550 q 513 628 556 611 q 421 646 469 646 q 329 628 372 646 q 253 580 286 611 q 201 506 221 549 q 176 411 181 463 l 668 411 z "
    },
    "ĕ": {
      "ha": 821,
      "x_min": 50,
      "x_max": 783,
      "o": "m 419 -14 q 269 16 338 -14 q 153 97 201 46 q 77 217 104 149 q 50 363 50 286 q 77 507 50 439 q 153 626 104 575 q 271 708 203 678 q 421 738 339 738 q 570 707 503 738 q 685 626 638 676 q 758 508 732 575 q 783 368 783 440 q 783 340 783 353 q 781 321 782 328 l 179 321 q 204 222 183 267 q 258 146 225 178 q 334 96 292 114 q 424 78 376 78 q 489 87 457 78 q 549 111 521 96 q 598 149 576 126 q 631 199 619 171 l 736 169 q 687 96 718 129 q 615 38 656 63 q 524 0 574 14 q 419 -14 474 -14 m 668 411 q 642 506 664 463 q 588 581 621 550 q 513 628 556 611 q 421 646 469 646 q 329 628 372 646 q 253 580 286 611 q 201 506 221 549 q 176 411 181 463 l 668 411 m 415 919 q 469 947 446 919 q 496 1014 492 974 l 565 1014 q 553 953 565 981 q 522 904 542 925 q 474 872 501 883 q 415 860 447 860 q 356 872 383 860 q 309 904 329 883 q 277 953 289 925 q 265 1014 265 981 l 336 1014 q 360 948 336 976 q 415 919 383 919 z "
    },
    "ě": {
      "ha": 821,
      "x_min": 50,
      "x_max": 783,
      "o": "m 297 1014 l 415 926 l 533 1014 l 600 981 l 460 856 l 371 856 l 231 981 l 297 1014 m 419 -14 q 269 16 338 -14 q 153 97 201 46 q 77 217 104 149 q 50 363 50 286 q 77 507 50 439 q 153 626 104 575 q 271 708 203 678 q 421 738 339 738 q 570 707 503 738 q 685 626 638 676 q 758 508 732 575 q 783 368 783 440 q 783 340 783 353 q 781 321 782 328 l 179 321 q 204 222 183 267 q 258 146 225 178 q 334 96 292 114 q 424 78 376 78 q 489 87 457 78 q 549 111 521 96 q 598 149 576 126 q 631 199 619 171 l 736 169 q 687 96 718 129 q 615 38 656 63 q 524 0 574 14 q 419 -14 474 -14 m 668 411 q 642 506 664 463 q 588 581 621 550 q 513 628 556 611 q 421 646 469 646 q 329 628 372 646 q 253 580 286 611 q 201 506 221 549 q 176 411 181 463 l 668 411 z "
    },
    "ê": {
      "ha": 821,
      "x_min": 50,
      "x_max": 783,
      "o": "m 231 889 l 371 1014 l 460 1014 l 600 889 l 533 856 l 415 943 l 297 856 l 231 889 m 419 -14 q 269 16 338 -14 q 153 97 201 46 q 77 217 104 149 q 50 363 50 286 q 77 507 50 439 q 153 626 104 575 q 271 708 203 678 q 421 738 339 738 q 570 707 503 738 q 685 626 638 676 q 758 508 732 575 q 783 368 783 440 q 783 340 783 353 q 781 321 782 328 l 179 321 q 204 222 183 267 q 258 146 225 178 q 334 96 292 114 q 424 78 376 78 q 489 87 457 78 q 549 111 521 96 q 598 149 576 126 q 631 199 619 171 l 736 169 q 687 96 718 129 q 615 38 656 63 q 524 0 574 14 q 419 -14 474 -14 m 668 411 q 642 506 664 463 q 588 581 621 550 q 513 628 556 611 q 421 646 469 646 q 329 628 372 646 q 253 580 286 611 q 201 506 221 549 q 176 411 181 463 l 668 411 z "
    },
    "ë": {
      "ha": 821,
      "x_min": 50,
      "x_max": 783,
      "o": "m 251 867 l 251 1008 l 354 1008 l 354 867 l 251 867 m 476 867 l 476 1008 l 579 1008 l 579 867 l 476 867 m 419 -14 q 269 16 338 -14 q 153 97 201 46 q 77 217 104 149 q 50 363 50 286 q 77 507 50 439 q 153 626 104 575 q 271 708 203 678 q 421 738 339 738 q 570 707 503 738 q 685 626 638 676 q 758 508 732 575 q 783 368 783 440 q 783 340 783 353 q 781 321 782 328 l 179 321 q 204 222 183 267 q 258 146 225 178 q 334 96 292 114 q 424 78 376 78 q 489 87 457 78 q 549 111 521 96 q 598 149 576 126 q 631 199 619 171 l 736 169 q 687 96 718 129 q 615 38 656 63 q 524 0 574 14 q 419 -14 474 -14 m 668 411 q 642 506 664 463 q 588 581 621 550 q 513 628 556 611 q 421 646 469 646 q 329 628 372 646 q 253 580 286 611 q 201 506 221 549 q 176 411 181 463 l 668 411 z "
    },
    "ė": {
      "ha": 821,
      "x_min": 50,
      "x_max": 783,
      "o": "m 419 -14 q 269 16 338 -14 q 153 97 201 46 q 77 217 104 149 q 50 363 50 286 q 77 507 50 439 q 153 626 104 575 q 271 708 203 678 q 421 738 339 738 q 570 707 503 738 q 685 626 638 676 q 758 508 732 575 q 783 368 783 440 q 783 340 783 353 q 781 321 782 328 l 179 321 q 204 222 183 267 q 258 146 225 178 q 334 96 292 114 q 424 78 376 78 q 489 87 457 78 q 549 111 521 96 q 598 149 576 126 q 631 199 619 171 l 736 169 q 687 96 718 129 q 615 38 656 63 q 524 0 574 14 q 419 -14 474 -14 m 668 411 q 642 506 664 463 q 588 581 621 550 q 513 628 556 611 q 421 646 469 646 q 329 628 372 646 q 253 580 286 611 q 201 506 221 549 q 176 411 181 463 l 668 411 m 360 867 l 360 1014 l 471 1014 l 471 867 l 360 867 z "
    },
    "è": {
      "ha": 821,
      "x_min": 50,
      "x_max": 783,
      "o": "m 419 -14 q 269 16 338 -14 q 153 97 201 46 q 77 217 104 149 q 50 363 50 286 q 77 507 50 439 q 153 626 104 575 q 271 708 203 678 q 421 738 339 738 q 570 707 503 738 q 685 626 638 676 q 758 508 732 575 q 783 368 783 440 q 783 340 783 353 q 781 321 782 328 l 179 321 q 204 222 183 267 q 258 146 225 178 q 334 96 292 114 q 424 78 376 78 q 489 87 457 78 q 549 111 521 96 q 598 149 576 126 q 631 199 619 171 l 736 169 q 687 96 718 129 q 615 38 656 63 q 524 0 574 14 q 419 -14 474 -14 m 668 411 q 642 506 664 463 q 588 581 621 550 q 513 628 556 611 q 421 646 469 646 q 329 628 372 646 q 253 580 286 611 q 201 506 221 549 q 176 411 181 463 l 668 411 m 271 1014 l 392 1014 l 474 874 l 394 846 l 271 1014 z "
    },
    "₈": {
      "ha": 563,
      "x_min": 50,
      "x_max": 511,
      "o": "m 511 49 q 492 -19 511 11 q 442 -72 474 -50 q 368 -106 410 -93 q 279 -118 326 -118 q 188 -105 229 -118 q 115 -69 146 -92 q 67 -15 85 -46 q 50 51 50 17 q 60 100 50 78 q 88 140 71 122 q 128 170 106 157 q 175 192 151 183 q 103 235 135 207 q 72 306 72 263 q 91 367 72 339 q 139 413 110 394 q 206 442 168 432 q 281 453 243 453 q 356 442 318 453 q 422 413 393 432 q 470 367 451 394 q 489 307 489 340 q 459 236 489 265 q 385 192 429 207 q 475 137 439 172 q 511 49 511 101 m 433 57 q 419 99 433 81 q 384 131 406 118 q 335 150 363 143 q 281 157 307 157 q 224 150 251 157 q 175 129 196 143 q 141 97 154 115 q 128 56 128 78 q 142 14 128 32 q 178 -17 156 -4 q 227 -35 200 -29 q 282 -42 254 -42 q 337 -35 310 -42 q 385 -15 364 -28 q 420 17 407 -1 q 433 57 433 35 m 150 299 q 162 265 150 279 q 192 240 174 250 q 234 225 211 231 q 281 219 257 219 q 326 225 303 219 q 369 241 350 231 q 401 266 389 251 q 413 300 413 281 q 401 333 413 318 q 372 358 390 347 q 329 374 353 368 q 281 379 306 379 q 189 358 228 379 q 150 299 150 336 z "
    },
    "⁸": {
      "ha": 563,
      "x_min": 50,
      "x_max": 511,
      "o": "m 511 721 q 492 653 511 683 q 442 601 474 622 q 368 567 410 579 q 279 554 326 554 q 188 567 229 554 q 115 603 146 581 q 67 658 85 626 q 50 724 50 689 q 60 772 50 750 q 88 812 71 794 q 128 842 106 829 q 175 864 151 856 q 103 907 135 879 q 72 978 72 935 q 91 1039 72 1011 q 139 1085 110 1067 q 206 1115 168 1104 q 281 1125 243 1125 q 356 1115 318 1125 q 422 1085 393 1104 q 470 1040 451 1067 q 489 979 489 1013 q 459 908 489 938 q 385 864 429 879 q 475 809 439 844 q 511 721 511 774 m 433 729 q 419 772 433 753 q 384 803 406 790 q 335 822 363 815 q 281 829 307 829 q 224 822 251 829 q 175 802 196 815 q 141 770 154 789 q 128 729 128 751 q 142 688 128 706 q 178 657 156 669 q 227 638 200 644 q 282 631 254 631 q 337 638 310 631 q 385 658 364 644 q 420 689 407 671 q 433 729 433 707 m 150 972 q 162 938 150 953 q 192 913 174 924 q 234 898 211 903 q 281 893 257 893 q 326 899 303 893 q 369 914 350 904 q 401 938 389 924 q 413 972 413 953 q 401 1006 413 990 q 372 1031 390 1021 q 329 1046 353 1040 q 281 1051 306 1051 q 189 1030 228 1051 q 150 972 150 1008 z "
    },
    "…": {
      "ha": 699,
      "x_min": 89,
      "x_max": 610,
      "o": "m 89 0 l 89 156 l 192 156 l 192 0 l 89 0 m 299 0 l 299 156 l 400 156 l 400 0 l 299 0 m 507 0 l 507 156 l 610 156 l 610 0 l 507 0 z "
    },
    "ē": {
      "ha": 821,
      "x_min": 50,
      "x_max": 783,
      "o": "m 419 -14 q 269 16 338 -14 q 153 97 201 46 q 77 217 104 149 q 50 363 50 286 q 77 507 50 439 q 153 626 104 575 q 271 708 203 678 q 421 738 339 738 q 570 707 503 738 q 685 626 638 676 q 758 508 732 575 q 783 368 783 440 q 783 340 783 353 q 781 321 782 328 l 179 321 q 204 222 183 267 q 258 146 225 178 q 334 96 292 114 q 424 78 376 78 q 489 87 457 78 q 549 111 521 96 q 598 149 576 126 q 631 199 619 171 l 736 169 q 687 96 718 129 q 615 38 656 63 q 524 0 574 14 q 419 -14 474 -14 m 668 411 q 642 506 664 463 q 588 581 621 550 q 513 628 556 611 q 421 646 469 646 q 329 628 372 646 q 253 580 286 611 q 201 506 221 549 q 176 411 181 463 l 668 411 m 213 908 l 213 989 l 618 989 l 618 908 l 213 908 z "
    },
    "—": {
      "ha": 1265,
      "x_min": 89,
      "x_max": 1176,
      "o": "m 89 324 l 89 435 l 1176 435 l 1176 324 l 89 324 z "
    },
    "–": {
      "ha": 808,
      "x_min": 89,
      "x_max": 719,
      "o": "m 89 324 l 89 435 l 719 435 l 719 324 l 89 324 z "
    },
    "ŋ": {
      "ha": 819,
      "x_min": 99,
      "x_max": 728,
      "o": "m 503 -258 q 412 -244 454 -258 q 336 -200 369 -231 l 393 -118 q 438 -143 413 -136 q 489 -150 464 -150 q 532 -141 511 -150 q 569 -117 553 -132 q 596 -79 586 -101 q 606 -32 606 -57 l 606 406 q 570 575 606 522 q 463 628 535 628 q 388 613 425 628 q 317 574 350 599 q 258 514 283 549 q 221 438 233 479 l 221 0 l 99 0 l 99 725 l 210 725 l 210 569 q 334 692 253 646 q 511 738 415 738 q 615 715 574 738 q 682 651 657 692 q 717 554 707 610 q 728 433 728 499 l 728 -24 q 709 -118 728 -75 q 659 -192 690 -161 q 588 -241 628 -224 q 503 -258 547 -258 z "
    },
    "ę": {
      "ha": 821,
      "x_min": 50,
      "x_max": 783,
      "o": "m 418 -258 q 331 -219 360 -247 q 301 -151 301 -190 q 399 -12 301 -82 q 257 22 321 -8 q 147 104 193 53 q 76 222 101 156 q 50 363 50 288 q 77 507 50 439 q 153 626 104 575 q 271 708 203 678 q 421 738 339 738 q 570 707 503 738 q 685 626 638 676 q 758 508 732 575 q 783 368 783 440 q 783 340 783 353 q 781 321 782 328 l 179 321 q 204 222 183 267 q 258 146 225 178 q 334 96 292 114 q 424 78 376 78 q 489 87 457 78 q 549 111 521 96 q 598 149 576 126 q 631 199 619 171 l 736 169 q 638 52 706 100 q 482 -8 571 4 q 398 -74 424 -44 q 372 -135 372 -104 q 449 -194 372 -186 l 418 -258 m 668 411 q 642 506 664 463 q 588 581 621 550 q 513 628 556 611 q 421 646 469 646 q 329 628 372 646 q 253 580 286 611 q 201 506 221 549 q 176 411 181 463 l 668 411 z "
    },
    "=": {
      "ha": 610,
      "x_min": 93,
      "x_max": 517,
      "o": "m 93 249 l 93 332 l 517 332 l 517 249 l 93 249 m 93 435 l 93 518 l 517 518 l 517 435 l 93 435 z "
    },
    "ð": {
      "ha": 842,
      "x_min": 54,
      "x_max": 786,
      "o": "m 701 939 l 593 875 q 684 756 647 818 q 744 633 721 694 q 776 513 767 572 q 786 403 786 454 q 756 228 786 306 q 675 97 726 151 q 556 15 624 43 q 413 -14 488 -14 q 274 13 339 -14 q 160 84 208 39 q 83 191 111 129 q 54 324 54 253 q 81 452 54 392 q 153 558 107 513 q 260 631 199 604 q 393 657 322 657 q 552 617 481 657 q 661 511 624 578 q 611 672 647 594 q 500 828 575 750 l 351 739 l 314 790 l 451 872 q 246 1014 369 944 l 418 1014 q 547 919 489 972 l 664 990 l 701 939 m 179 324 q 198 233 179 275 q 249 159 217 190 q 324 110 281 128 q 417 92 367 92 q 513 111 468 92 q 590 163 557 131 q 642 240 624 196 q 661 332 661 283 q 642 421 661 379 q 591 492 624 463 q 515 540 558 522 q 422 557 472 557 q 326 539 371 557 q 249 489 282 521 q 198 415 217 457 q 179 324 179 372 z "
    },
    "ẽ": {
      "ha": 821,
      "x_min": 50,
      "x_max": 783,
      "o": "m 419 -14 q 269 16 338 -14 q 153 97 201 46 q 77 217 104 149 q 50 363 50 286 q 77 507 50 439 q 153 626 104 575 q 271 708 203 678 q 421 738 339 738 q 570 707 503 738 q 685 626 638 676 q 758 508 732 575 q 783 368 783 440 q 783 340 783 353 q 781 321 782 328 l 179 321 q 204 222 183 267 q 258 146 225 178 q 334 96 292 114 q 424 78 376 78 q 489 87 457 78 q 549 111 521 96 q 598 149 576 126 q 631 199 619 171 l 736 169 q 687 96 718 129 q 615 38 656 63 q 524 0 574 14 q 419 -14 474 -14 m 668 411 q 642 506 664 463 q 588 581 621 550 q 513 628 556 611 q 421 646 469 646 q 329 628 372 646 q 253 580 286 611 q 201 506 221 549 q 176 411 181 463 l 668 411 m 501 871 q 447 880 469 871 q 403 900 424 889 q 364 920 383 911 q 322 929 344 929 q 285 919 299 929 q 265 898 272 910 q 256 875 258 886 q 254 863 254 864 l 182 863 q 188 894 182 871 q 210 943 194 918 q 251 987 225 968 q 319 1006 278 1006 q 371 997 349 1006 q 413 976 393 988 q 453 955 433 964 q 499 946 474 946 q 540 956 525 946 q 564 978 556 965 q 574 1001 572 990 q 576 1014 576 1011 l 649 1014 q 642 983 649 1006 q 619 935 636 960 q 574 890 603 910 q 501 871 546 871 z "
    },
    "!": {
      "ha": 364,
      "x_min": 121,
      "x_max": 243,
      "o": "m 121 333 l 121 996 l 243 996 l 243 333 l 121 333 m 121 0 l 121 172 l 243 172 l 243 0 l 121 0 z "
    },
    "¡": {
      "ha": 361,
      "x_min": 119,
      "x_max": 242,
      "o": "m 242 658 l 242 -4 l 119 -4 l 119 658 l 242 658 m 242 992 l 242 819 l 119 819 l 119 992 l 242 992 z "
    },
    "f": {
      "ha": 476,
      "x_min": 39,
      "x_max": 519,
      "o": "m 138 0 l 138 629 l 39 629 l 39 725 l 138 725 l 138 740 q 197 951 138 875 q 360 1028 257 1028 q 444 1016 403 1028 q 519 983 486 1004 l 489 893 q 441 915 469 907 q 385 924 413 924 q 292 878 324 924 q 260 744 260 832 l 260 725 l 453 725 l 453 629 l 260 629 l 260 0 l 138 0 z "
    },
    "ﬀ": {
      "ha": 835,
      "x_min": 39,
      "x_max": 869,
      "o": "m 738 922 q 672 906 699 922 q 627 865 644 890 q 601 808 610 840 q 593 744 593 776 l 593 725 l 811 725 l 811 629 l 593 629 l 593 0 l 471 0 l 471 629 l 260 629 l 260 0 l 138 0 l 138 629 l 39 629 l 39 725 l 138 725 l 138 731 q 153 822 139 778 q 197 901 168 867 q 267 955 225 935 q 365 975 310 975 q 456 964 415 975 q 529 938 497 953 q 605 1003 560 978 q 715 1028 650 1028 q 812 1010 776 1028 q 869 983 847 993 l 839 893 q 800 913 822 904 q 738 922 778 922 m 471 725 q 476 787 471 751 q 493 844 482 822 q 441 865 471 860 q 388 869 411 869 q 290 828 318 869 q 260 732 261 788 l 260 725 l 471 725 z "
    },
    "ﬃ": {
      "ha": 1063,
      "x_min": 39,
      "x_max": 967,
      "o": "m 138 629 l 39 629 l 39 725 l 138 725 l 138 731 q 152 819 138 775 q 196 897 167 863 q 267 953 225 932 q 365 975 310 975 q 456 964 415 975 q 529 938 497 953 q 615 1003 563 978 q 738 1028 667 1028 q 870 1003 811 1028 q 967 956 929 979 l 914 865 q 842 906 888 889 q 749 922 797 922 q 677 906 707 922 q 628 865 647 890 q 601 808 610 840 q 593 744 593 776 l 593 725 l 964 725 l 964 0 l 842 0 l 842 629 l 593 629 l 593 0 l 471 0 l 471 629 l 260 629 l 260 0 l 138 0 l 138 629 m 471 725 q 476 787 471 751 q 493 844 482 822 q 441 865 471 860 q 388 869 411 869 q 328 858 353 869 q 289 826 304 846 q 267 782 274 807 q 260 732 260 757 l 260 725 l 471 725 z "
    },
    "ﬄ": {
      "ha": 1179,
      "x_min": 39,
      "x_max": 1182,
      "o": "m 1039 -10 q 924 31 965 -10 q 883 129 883 72 l 883 768 q 876 822 883 794 q 853 872 869 850 q 810 908 838 894 q 743 922 783 922 q 676 907 703 922 q 631 865 649 892 q 605 804 613 839 q 597 731 597 769 l 597 725 l 739 725 l 739 629 l 597 629 l 597 0 l 475 0 l 475 629 l 260 629 l 260 0 l 138 0 l 138 629 l 39 629 l 39 725 l 138 725 l 138 731 q 153 822 138 778 q 200 901 169 867 q 274 955 231 935 q 372 975 318 975 q 460 964 424 975 q 529 938 497 953 q 742 1028 599 1028 q 858 1010 808 1028 q 940 962 907 993 q 989 888 972 931 q 1006 794 1006 846 l 1006 185 q 1010 156 1006 171 q 1024 128 1014 140 q 1047 108 1033 115 q 1079 100 1060 100 q 1133 108 1106 100 q 1163 117 1160 117 l 1182 17 q 1169 11 1182 15 q 1135 2 1156 7 q 1090 -6 1115 -3 q 1039 -10 1064 -10 m 475 725 q 478 790 475 754 q 492 846 482 826 q 444 865 469 861 q 396 869 419 869 q 337 858 363 869 q 294 826 311 846 q 268 783 276 807 q 260 735 260 758 l 260 725 l 475 725 z "
    },
    "ﬁ": {
      "ha": 729,
      "x_min": 39,
      "x_max": 633,
      "o": "m 138 629 l 39 629 l 39 725 l 138 725 l 138 740 q 154 846 138 794 q 204 938 171 897 q 288 1003 238 978 q 406 1028 338 1028 q 541 1003 483 1028 q 633 956 599 979 l 581 865 q 508 906 553 889 q 413 922 464 922 q 344 906 372 922 q 297 865 315 890 q 269 808 278 840 q 260 744 260 776 l 260 725 l 631 725 l 631 0 l 508 0 l 508 629 l 260 629 l 260 0 l 138 0 l 138 629 z "
    },
    "ﬂ": {
      "ha": 842,
      "x_min": 39,
      "x_max": 846,
      "o": "m 846 17 q 832 11 844 15 q 799 2 819 7 q 753 -6 778 -3 q 701 -10 728 -10 q 588 31 628 -10 q 547 129 547 72 l 547 768 q 540 822 547 794 q 517 872 533 850 q 474 908 501 894 q 406 922 447 922 q 296 871 329 922 q 260 738 263 819 l 260 725 l 403 725 l 403 629 l 260 629 l 260 0 l 138 0 l 138 629 l 39 629 l 39 725 l 138 725 l 138 750 q 205 952 138 876 q 404 1028 272 1028 q 521 1010 471 1028 q 603 962 571 993 q 653 888 636 931 q 669 794 669 846 l 669 185 q 674 156 669 171 q 688 128 678 140 q 710 108 697 115 q 743 100 724 100 q 797 108 769 100 q 825 117 824 117 l 846 17 z "
    },
    "⅝": {
      "ha": 1249,
      "x_min": 49,
      "x_max": 1200,
      "o": "m 1200 160 q 1181 92 1200 122 q 1131 40 1163 61 q 1057 6 1099 18 q 968 -7 1015 -7 q 876 6 918 -7 q 804 42 835 19 q 756 97 774 65 q 739 163 739 128 q 749 211 739 189 q 777 251 760 233 q 817 281 794 268 q 864 303 840 294 q 792 346 824 318 q 761 417 761 374 q 780 478 761 450 q 828 524 799 506 q 894 553 857 543 q 969 564 932 564 q 1044 553 1007 564 q 1111 524 1082 543 q 1159 478 1140 506 q 1178 418 1178 451 q 1148 347 1178 376 q 1074 303 1118 318 q 1164 248 1128 283 q 1200 160 1200 213 m 1122 168 q 1108 210 1122 192 q 1073 242 1094 229 q 1024 261 1051 254 q 969 268 996 268 q 913 261 940 268 q 864 240 885 254 q 830 208 843 226 q 817 167 817 189 q 831 125 817 143 q 867 94 844 107 q 916 76 889 82 q 971 69 943 69 q 1026 76 999 69 q 1074 97 1053 83 q 1109 128 1096 110 q 1122 168 1122 146 m 839 410 q 851 376 839 390 q 881 351 863 361 q 923 336 900 342 q 969 331 946 331 q 1015 336 992 331 q 1058 352 1039 342 q 1090 377 1078 363 q 1101 411 1101 392 q 1090 444 1101 429 q 1060 469 1079 458 q 1018 485 1042 479 q 969 490 994 490 q 878 469 917 490 q 839 410 839 447 m 276 811 q 362 798 322 811 q 431 761 401 785 q 476 704 460 738 q 493 632 493 671 q 475 556 493 590 q 426 496 457 521 q 351 457 394 471 q 260 443 308 443 q 133 471 189 443 q 49 546 76 499 l 97 593 q 167 537 124 557 q 264 517 210 517 q 371 548 328 517 q 414 633 414 579 q 401 685 414 663 q 368 722 389 707 q 322 744 347 736 q 269 751 296 751 q 191 733 229 751 q 132 686 153 715 l 63 686 q 79 762 68 715 q 102 857 90 808 q 124 949 114 906 q 138 1014 133 992 l 456 1014 l 456 938 l 194 938 l 153 775 q 206 801 175 792 q 276 811 238 811 m 203 46 l 592 514 l 964 993 l 1024 942 l 639 476 l 261 -7 l 203 46 z "
    },
    "⁵": {
      "ha": 528,
      "x_min": 40,
      "x_max": 485,
      "o": "m 268 922 q 353 909 314 922 q 422 872 393 896 q 468 815 451 849 q 485 743 485 782 q 467 667 485 701 q 417 607 449 632 q 343 568 386 582 q 251 554 300 554 q 124 582 181 554 q 40 657 68 610 l 89 704 q 158 648 115 668 q 256 628 201 628 q 363 659 319 628 q 406 744 406 690 q 393 796 406 774 q 360 833 381 818 q 313 855 339 847 q 261 863 288 863 q 183 844 221 863 q 124 797 144 826 l 54 797 q 71 873 60 826 q 94 968 82 919 q 115 1060 106 1017 q 129 1125 125 1103 l 447 1125 l 447 1049 l 186 1049 l 144 886 q 198 913 167 903 q 268 922 229 922 z "
    },
    "⁄": {
      "ha": 233,
      "x_min": -294,
      "x_max": 526,
      "o": "m -294 46 l 94 514 l 467 993 l 526 942 l 142 476 l -236 -7 l -294 46 z "
    },
    "₅": {
      "ha": 528,
      "x_min": 40,
      "x_max": 485,
      "o": "m 268 250 q 353 237 314 250 q 422 200 393 224 q 468 143 451 176 q 485 69 485 110 q 467 -7 485 28 q 417 -66 449 -42 q 343 -104 386 -90 q 251 -118 300 -118 q 124 -90 181 -118 q 40 -17 68 -62 l 89 31 q 158 -25 115 -4 q 256 -46 201 -46 q 363 -14 319 -46 q 406 72 406 18 q 393 124 406 101 q 360 160 381 146 q 313 183 339 175 q 261 190 288 190 q 183 172 221 190 q 124 125 144 154 l 54 125 q 71 201 60 154 q 94 296 82 247 q 115 388 106 344 q 129 453 125 431 l 447 453 l 447 376 l 186 376 l 144 214 q 198 240 167 231 q 268 250 229 250 z "
    },
    "ƒ": {
      "ha": 742,
      "x_min": 42,
      "x_max": 693,
      "o": "m 208 -258 q 118 -244 161 -258 q 42 -200 75 -231 l 99 -118 q 144 -143 118 -136 q 194 -150 169 -150 q 238 -141 217 -150 q 275 -117 258 -132 q 301 -79 292 -101 q 311 -32 311 -57 l 311 544 l 213 544 l 213 640 l 311 640 l 311 740 q 371 951 311 875 q 533 1028 431 1028 q 617 1016 575 1028 q 693 983 660 1004 l 663 893 q 614 915 643 907 q 557 924 585 924 q 465 878 496 924 q 433 744 433 832 l 433 640 l 626 640 l 626 544 l 433 544 l 433 -29 q 415 -122 433 -79 q 365 -194 396 -164 q 292 -242 333 -225 q 208 -258 251 -258 z "
    },
    "₄": {
      "ha": 543,
      "x_min": 32,
      "x_max": 504,
      "o": "m 346 -111 l 346 28 l 32 28 l 32 101 l 369 453 l 422 453 l 422 103 l 504 103 l 504 28 l 422 28 l 422 -111 l 346 -111 m 111 103 l 349 103 l 349 353 l 111 103 z "
    },
    "⁴": {
      "ha": 544,
      "x_min": 32,
      "x_max": 504,
      "o": "m 346 563 l 346 700 l 32 700 l 32 774 l 369 1125 l 422 1125 l 422 775 l 504 775 l 504 700 l 422 700 l 422 563 l 346 563 m 111 775 l 349 775 l 349 1025 l 111 775 z "
    },
    "g": {
      "ha": 867,
      "x_min": 53,
      "x_max": 768,
      "o": "m 388 -8 q 252 22 314 -8 q 146 104 190 53 q 77 222 101 156 q 53 361 53 289 q 77 506 53 438 q 146 626 101 575 q 252 708 190 678 q 389 738 314 738 q 547 693 481 738 q 660 581 614 649 l 660 725 l 768 725 l 768 8 q 739 -128 768 -69 q 660 -228 710 -187 q 542 -289 610 -268 q 399 -310 475 -310 q 198 -267 275 -310 q 69 -150 121 -225 l 140 -87 q 251 -183 183 -151 q 399 -215 319 -215 q 494 -201 449 -215 q 572 -160 539 -187 q 626 -90 606 -132 q 646 8 646 -49 l 646 136 q 597 76 625 103 q 535 30 568 49 q 464 1 501 11 q 388 -8 426 -8 m 425 92 q 500 106 464 92 q 567 142 536 119 q 618 194 597 165 q 646 254 639 224 l 646 463 q 606 531 631 500 q 551 584 582 561 q 485 619 521 607 q 414 632 450 632 q 315 608 358 632 q 240 546 271 585 q 193 458 210 507 q 176 358 176 408 q 196 256 176 304 q 249 171 215 207 q 327 113 282 135 q 425 92 372 92 z "
    },
    "ğ": {
      "ha": 865,
      "x_min": 51,
      "x_max": 767,
      "o": "m 386 -8 q 251 22 313 -8 q 144 104 189 53 q 76 222 100 156 q 51 361 51 289 q 76 506 51 438 q 144 626 100 575 q 251 708 189 678 q 388 738 313 738 q 546 693 479 738 q 658 581 613 649 l 658 725 l 767 725 l 767 8 q 738 -128 767 -69 q 658 -228 708 -187 q 541 -289 608 -268 q 397 -310 474 -310 q 197 -267 274 -310 q 68 -150 119 -225 l 139 -87 q 250 -183 182 -151 q 397 -215 318 -215 q 492 -201 447 -215 q 571 -160 538 -187 q 624 -90 604 -132 q 644 8 644 -49 l 644 136 q 595 76 624 103 q 533 30 567 49 q 463 1 500 11 q 386 -8 425 -8 m 424 92 q 499 106 463 92 q 565 142 535 119 q 617 194 596 165 q 644 254 638 224 l 644 463 q 605 531 629 500 q 550 584 581 561 q 484 619 519 607 q 413 632 449 632 q 313 608 357 632 q 239 546 269 585 q 192 458 208 507 q 175 358 175 408 q 194 256 175 304 q 247 171 214 207 q 326 113 281 135 q 424 92 371 92 m 458 919 q 512 947 489 919 q 539 1014 535 974 l 608 1014 q 597 953 608 981 q 565 904 585 925 q 517 872 544 883 q 458 860 490 860 q 399 872 426 860 q 352 904 372 883 q 320 953 332 925 q 308 1014 308 981 l 379 1014 q 403 948 379 976 q 458 919 426 919 z "
    },
    "ĝ": {
      "ha": 865,
      "x_min": 51,
      "x_max": 767,
      "o": "m 274 889 l 414 1014 l 503 1014 l 643 889 l 576 856 l 458 943 l 340 856 l 274 889 m 386 -8 q 251 22 313 -8 q 144 104 189 53 q 76 222 100 156 q 51 361 51 289 q 76 506 51 438 q 144 626 100 575 q 251 708 189 678 q 388 738 313 738 q 546 693 479 738 q 658 581 613 649 l 658 725 l 767 725 l 767 8 q 738 -128 767 -69 q 658 -228 708 -187 q 541 -289 608 -268 q 397 -310 474 -310 q 197 -267 274 -310 q 68 -150 119 -225 l 139 -87 q 250 -183 182 -151 q 397 -215 318 -215 q 492 -201 447 -215 q 571 -160 538 -187 q 624 -90 604 -132 q 644 8 644 -49 l 644 136 q 595 76 624 103 q 533 30 567 49 q 463 1 500 11 q 386 -8 425 -8 m 424 92 q 499 106 463 92 q 565 142 535 119 q 617 194 596 165 q 644 254 638 224 l 644 463 q 605 531 629 500 q 550 584 581 561 q 484 619 519 607 q 413 632 449 632 q 313 608 357 632 q 239 546 269 585 q 192 458 208 507 q 175 358 175 408 q 194 256 175 304 q 247 171 214 207 q 326 113 281 135 q 424 92 371 92 z "
    },
    "ģ": {
      "ha": 865,
      "x_min": 51,
      "x_max": 767,
      "o": "m 386 -8 q 251 22 313 -8 q 144 104 189 53 q 76 222 100 156 q 51 361 51 289 q 76 506 51 438 q 144 626 100 575 q 251 708 189 678 q 388 738 313 738 q 546 693 479 738 q 658 581 613 649 l 658 725 l 767 725 l 767 8 q 738 -128 767 -69 q 658 -228 708 -187 q 541 -289 608 -268 q 397 -310 474 -310 q 197 -267 274 -310 q 68 -150 119 -225 l 139 -87 q 250 -183 182 -151 q 397 -215 318 -215 q 492 -201 447 -215 q 571 -160 538 -187 q 624 -90 604 -132 q 644 8 644 -49 l 644 136 q 595 76 624 103 q 533 30 567 49 q 463 1 500 11 q 386 -8 425 -8 m 424 92 q 499 106 463 92 q 565 142 535 119 q 617 194 596 165 q 644 254 638 224 l 644 463 q 605 531 629 500 q 550 584 581 561 q 484 619 519 607 q 413 632 449 632 q 313 608 357 632 q 239 546 269 585 q 192 458 208 507 q 175 358 175 408 q 194 256 175 304 q 247 171 214 207 q 326 113 281 135 q 424 92 371 92 m 482 1035 l 454 922 l 489 922 l 489 806 l 381 806 l 381 922 l 422 1035 l 482 1035 z "
    },
    "ġ": {
      "ha": 865,
      "x_min": 51,
      "x_max": 767,
      "o": "m 386 -8 q 251 22 313 -8 q 144 104 189 53 q 76 222 100 156 q 51 361 51 289 q 76 506 51 438 q 144 626 100 575 q 251 708 189 678 q 388 738 313 738 q 546 693 479 738 q 658 581 613 649 l 658 725 l 767 725 l 767 8 q 738 -128 767 -69 q 658 -228 708 -187 q 541 -289 608 -268 q 397 -310 474 -310 q 197 -267 274 -310 q 68 -150 119 -225 l 139 -87 q 250 -183 182 -151 q 397 -215 318 -215 q 492 -201 447 -215 q 571 -160 538 -187 q 624 -90 604 -132 q 644 8 644 -49 l 644 136 q 595 76 624 103 q 533 30 567 49 q 463 1 500 11 q 386 -8 425 -8 m 424 92 q 499 106 463 92 q 565 142 535 119 q 617 194 596 165 q 644 254 638 224 l 644 463 q 605 531 629 500 q 550 584 581 561 q 484 619 519 607 q 413 632 449 632 q 313 608 357 632 q 239 546 269 585 q 192 458 208 507 q 175 358 175 408 q 194 256 175 304 q 247 171 214 207 q 326 113 281 135 q 424 92 371 92 m 403 867 l 403 1014 l 514 1014 l 514 867 l 403 867 z "
    },
    "ß": {
      "ha": 768,
      "x_min": 99,
      "x_max": 719,
      "o": "m 335 104 q 439 117 392 106 q 521 151 486 128 q 574 212 556 175 q 593 299 593 249 q 535 442 593 389 q 383 496 478 496 l 357 496 l 357 607 l 382 607 q 490 646 449 607 q 532 750 532 685 q 519 810 532 785 q 486 853 507 836 q 438 878 465 869 q 382 886 411 886 q 308 871 339 886 q 256 829 276 856 q 225 769 235 803 q 215 699 215 736 l 215 0 l 99 0 l 99 718 q 120 828 99 778 q 180 915 142 879 q 271 972 218 951 q 386 992 324 992 q 490 976 442 992 q 573 930 538 960 q 628 859 608 900 q 649 768 649 818 q 638 697 649 731 q 608 634 626 663 q 564 586 589 606 q 510 558 539 567 q 599 523 560 547 q 665 463 638 499 q 706 383 692 428 q 719 289 719 339 q 691 163 719 218 q 611 72 663 108 q 489 15 560 35 q 335 -8 418 -6 l 335 104 z "
    },
    ">": {
      "ha": 708,
      "x_min": 79,
      "x_max": 663,
      "o": "m 663 325 l 79 -22 l 79 114 l 485 360 l 79 610 l 79 740 l 663 389 l 663 325 z "
    },
    "«": {
      "ha": 828,
      "x_min": 56,
      "x_max": 743,
      "o": "m 56 389 l 407 640 l 407 538 l 154 360 l 407 186 l 407 83 l 56 325 l 56 389 m 392 389 l 743 640 l 743 538 l 490 360 l 743 186 l 743 83 l 392 325 l 392 389 z "
    },
    "»": {
      "ha": 828,
      "x_min": 85,
      "x_max": 772,
      "o": "m 772 325 l 421 83 l 421 186 l 674 360 l 421 538 l 421 640 l 772 389 l 772 325 m 436 325 l 85 83 l 85 186 l 338 360 l 85 538 l 85 640 l 436 389 l 436 325 z "
    },
    "‹": {
      "ha": 492,
      "x_min": 56,
      "x_max": 407,
      "o": "m 56 389 l 407 640 l 407 538 l 154 360 l 407 186 l 407 83 l 56 325 l 56 389 z "
    },
    "›": {
      "ha": 492,
      "x_min": 85,
      "x_max": 436,
      "o": "m 436 325 l 85 83 l 85 186 l 338 360 l 85 538 l 85 640 l 436 389 l 436 325 z "
    },
    "h": {
      "ha": 819,
      "x_min": 99,
      "x_max": 728,
      "o": "m 728 0 l 606 0 l 606 406 q 567 573 606 518 q 453 628 528 628 q 381 613 417 628 q 313 574 344 599 q 258 514 282 549 q 221 438 233 479 l 221 0 l 99 0 l 99 1014 l 221 1014 l 221 569 q 338 693 264 649 q 499 738 411 738 q 607 714 563 738 q 678 650 651 690 q 716 553 704 610 q 728 433 728 497 l 728 0 z "
    },
    "ħ": {
      "ha": 819,
      "x_min": 21,
      "x_max": 728,
      "o": "m 728 0 l 606 0 l 606 406 q 567 573 606 518 q 453 628 528 628 q 381 613 417 628 q 313 574 344 599 q 258 514 282 549 q 221 438 233 479 l 221 0 l 99 0 l 99 849 l 21 849 l 21 926 l 99 926 l 99 1014 l 221 1014 l 221 926 l 390 926 l 390 849 l 221 849 l 221 569 q 338 693 264 649 q 499 738 411 738 q 607 714 563 738 q 678 650 651 690 q 716 553 704 610 q 728 433 728 497 l 728 0 z "
    },
    "ĥ": {
      "ha": 819,
      "x_min": 99,
      "x_max": 728,
      "o": "m 315 889 l 446 1013 l 528 1013 l 658 889 l 596 856 l 488 942 l 378 856 l 315 889 m 728 0 l 606 0 l 606 406 q 567 573 606 518 q 453 628 528 628 q 381 613 417 628 q 313 574 344 599 q 258 514 282 549 q 221 438 233 479 l 221 0 l 99 0 l 99 1014 l 221 1014 l 221 569 q 338 693 264 649 q 499 738 411 738 q 607 714 563 738 q 678 650 651 690 q 716 553 704 610 q 728 433 728 497 l 728 0 z "
    },
    "-": {
      "ha": 588,
      "x_min": 89,
      "x_max": 499,
      "o": "m 89 324 l 89 435 l 499 435 l 499 324 l 89 324 z "
    },
    "i": {
      "ha": 319,
      "x_min": 99,
      "x_max": 221,
      "o": "m 99 0 l 99 725 l 221 725 l 221 0 l 99 0 m 99 861 l 99 1014 l 221 1014 l 221 861 l 99 861 z "
    },
    "í": {
      "ha": 319,
      "x_min": 99,
      "x_max": 303,
      "o": "m 181 846 l 100 874 l 181 1014 l 303 1014 l 181 846 m 99 0 l 99 725 l 221 725 l 221 0 l 99 0 z "
    },
    "ĭ": {
      "ha": 319,
      "x_min": 10,
      "x_max": 310,
      "o": "m 99 0 l 99 725 l 221 725 l 221 0 l 99 0 m 160 919 q 213 947 190 919 q 240 1014 236 974 l 310 1014 q 298 953 310 981 q 266 904 286 925 q 219 872 246 883 q 160 860 192 860 q 101 872 128 860 q 53 904 74 883 q 22 953 33 925 q 10 1014 10 981 l 81 1014 q 104 948 81 976 q 160 919 128 919 z "
    },
    "î": {
      "ha": 319,
      "x_min": -25,
      "x_max": 344,
      "o": "m -25 889 l 115 1014 l 204 1014 l 344 889 l 278 856 l 160 943 l 42 856 l -25 889 m 99 0 l 99 725 l 221 725 l 221 0 l 99 0 z "
    },
    "ï": {
      "ha": 319,
      "x_min": -4,
      "x_max": 324,
      "o": "m -4 867 l -4 1008 l 99 1008 l 99 867 l -4 867 m 221 867 l 221 1008 l 324 1008 l 324 867 l 221 867 m 99 0 l 99 725 l 221 725 l 221 0 l 99 0 z "
    },
    "ì": {
      "ha": 319,
      "x_min": 15,
      "x_max": 221,
      "o": "m 99 0 l 99 725 l 221 725 l 221 0 l 99 0 m 15 1014 l 136 1014 l 218 874 l 139 846 l 15 1014 z "
    },
    "ĳ": {
      "ha": 649,
      "x_min": 99,
      "x_max": 550,
      "o": "m 99 0 l 99 725 l 221 725 l 221 0 l 99 0 m 99 861 l 99 1014 l 221 1014 l 221 861 l 99 861 m 325 -258 q 234 -244 276 -258 q 158 -200 192 -231 l 215 -118 q 260 -143 235 -136 q 311 -150 286 -150 q 354 -141 333 -150 q 392 -117 375 -132 q 418 -79 408 -101 q 428 -32 428 -57 l 428 725 l 550 725 l 550 -24 q 531 -118 550 -75 q 481 -192 513 -161 q 410 -241 450 -224 q 325 -258 369 -258 m 428 861 l 428 1014 l 550 1014 l 550 861 l 428 861 z "
    },
    "j": {
      "ha": 329,
      "x_min": -161,
      "x_max": 231,
      "o": "m 6 -258 q -85 -244 -43 -258 q -161 -200 -128 -231 l -104 -118 q -59 -143 -85 -136 q -8 -150 -33 -150 q 35 -141 14 -150 q 72 -117 56 -132 q 99 -79 89 -101 q 108 -32 108 -57 l 108 725 l 231 725 l 231 -24 q 212 -118 231 -75 q 162 -192 193 -161 q 90 -241 131 -224 q 6 -258 50 -258 m 108 861 l 108 1014 l 231 1014 l 231 861 l 108 861 z "
    },
    "ī": {
      "ha": 319,
      "x_min": -42,
      "x_max": 364,
      "o": "m 99 0 l 99 725 l 221 725 l 221 0 l 99 0 m -42 908 l -42 989 l 364 989 l 364 908 l -42 908 z "
    },
    "į": {
      "ha": 319,
      "x_min": 36,
      "x_max": 221,
      "o": "m 153 -251 q 65 -212 94 -240 q 36 -144 36 -183 q 62 -72 36 -108 q 143 0 88 -36 l 99 0 l 99 725 l 221 725 l 221 0 q 133 -67 160 -37 q 107 -128 107 -97 q 183 -187 107 -179 l 153 -251 m 99 861 l 99 1014 l 221 1014 l 221 861 l 99 861 z "
    },
    "ĩ": {
      "ha": 319,
      "x_min": -74,
      "x_max": 393,
      "o": "m 99 0 l 99 725 l 221 725 l 221 0 l 99 0 m 246 871 q 191 880 214 871 q 148 900 168 889 q 108 920 128 911 q 67 929 89 929 q 30 919 43 929 q 10 898 17 910 q 1 875 3 886 q -1 863 -1 864 l -74 863 q -67 894 -74 871 q -46 943 -61 918 q -4 987 -31 968 q 64 1006 22 1006 q 115 997 93 1006 q 158 976 138 988 q 198 955 178 964 q 243 946 218 946 q 285 956 269 946 q 308 978 300 965 q 319 1001 317 990 q 321 1014 321 1011 l 393 1014 q 387 983 393 1006 q 364 935 381 960 q 319 890 347 910 q 246 871 290 871 z "
    },
    "ĵ": {
      "ha": 319,
      "x_min": -171,
      "x_max": 344,
      "o": "m -4 -258 q -95 -244 -53 -258 q -171 -200 -137 -231 l -114 -118 q -69 -143 -94 -136 q -18 -150 -43 -150 q 25 -141 4 -150 q 63 -117 46 -132 q 89 -79 79 -101 q 99 -32 99 -57 l 99 725 l 221 725 l 221 -24 q 202 -118 221 -75 q 152 -192 183 -161 q 81 -241 121 -224 q -4 -258 40 -258 m -25 889 l 115 1014 l 204 1014 l 344 889 l 278 856 l 160 943 l 42 856 l -25 889 z "
    },
    "k": {
      "ha": 749,
      "x_min": 99,
      "x_max": 742,
      "o": "m 610 0 l 360 354 l 221 224 l 221 0 l 99 0 l 99 1014 l 221 1014 l 221 347 l 593 724 l 728 724 l 439 424 l 742 0 l 610 0 z "
    },
    "ķ": {
      "ha": 749,
      "x_min": 99,
      "x_max": 742,
      "o": "m 338 -296 l 365 -183 l 331 -183 l 331 -67 l 439 -67 l 439 -183 l 397 -296 l 338 -296 m 610 0 l 360 354 l 221 224 l 221 0 l 99 0 l 99 1014 l 221 1014 l 221 347 l 593 724 l 728 724 l 439 424 l 742 0 l 610 0 z "
    },
    "ĸ": {
      "ha": 749,
      "x_min": 99,
      "x_max": 742,
      "o": "m 610 0 l 360 354 l 221 224 l 221 0 l 99 0 l 99 725 l 221 725 l 221 347 l 593 724 l 728 724 l 439 424 l 742 0 l 610 0 z "
    },
    "l": {
      "ha": 397,
      "x_min": 101,
      "x_max": 400,
      "o": "m 101 1014 l 224 1014 l 224 188 q 245 124 224 147 q 306 101 267 101 q 342 106 321 101 q 381 118 363 111 l 400 19 q 328 -1 369 7 q 254 -10 286 -10 q 142 31 183 -10 q 101 143 101 71 l 101 1014 z "
    },
    "ĺ": {
      "ha": 397,
      "x_min": 94,
      "x_max": 400,
      "o": "m 175 1069 l 94 1097 l 175 1238 l 297 1238 l 175 1069 m 101 1014 l 224 1014 l 224 188 q 245 124 224 147 q 306 101 267 101 q 342 106 321 101 q 381 118 363 111 l 400 19 q 328 -1 369 7 q 254 -10 286 -10 q 142 31 183 -10 q 101 143 101 71 l 101 1014 z "
    },
    "ľ": {
      "ha": 397,
      "x_min": 101,
      "x_max": 488,
      "o": "m 365 846 l 285 874 l 365 1014 l 488 1014 l 365 846 m 101 1014 l 224 1014 l 224 188 q 245 124 224 147 q 306 101 267 101 q 342 106 321 101 q 381 118 363 111 l 400 19 q 328 -1 369 7 q 254 -10 286 -10 q 142 31 183 -10 q 101 143 101 71 l 101 1014 z "
    },
    "ļ": {
      "ha": 397,
      "x_min": 101,
      "x_max": 400,
      "o": "m 197 -296 l 225 -183 l 190 -183 l 190 -67 l 299 -67 l 299 -183 l 257 -296 l 197 -296 m 101 1014 l 224 1014 l 224 188 q 245 124 224 147 q 306 101 267 101 q 342 106 321 101 q 381 118 363 111 l 400 19 q 328 -1 369 7 q 254 -10 286 -10 q 142 31 183 -10 q 101 143 101 71 l 101 1014 z "
    },
    "ŀ": {
      "ha": 471,
      "x_min": 101,
      "x_max": 449,
      "o": "m 101 1014 l 224 1014 l 224 188 q 245 124 224 147 q 306 101 267 101 q 342 106 321 101 q 381 118 363 111 l 400 19 q 328 -1 369 7 q 254 -10 286 -10 q 142 31 183 -10 q 101 143 101 71 l 101 1014 m 346 374 l 346 546 l 449 546 l 449 374 l 346 374 z "
    },
    "<": {
      "ha": 708,
      "x_min": 46,
      "x_max": 629,
      "o": "m 46 389 l 629 740 l 629 610 l 224 360 l 629 114 l 629 -22 l 46 325 l 46 389 z "
    },
    "¬": {
      "ha": 821,
      "x_min": 93,
      "x_max": 724,
      "o": "m 724 521 l 724 167 l 618 167 l 618 410 l 93 410 l 93 521 l 724 521 z "
    },
    "ł": {
      "ha": 428,
      "x_min": 11,
      "x_max": 429,
      "o": "m 131 453 l 47 393 l 11 461 l 131 547 l 131 1014 l 253 1014 l 253 636 l 375 725 l 413 657 l 253 542 l 253 188 q 274 124 253 147 q 335 101 296 101 q 371 106 350 101 q 410 118 392 111 l 429 19 q 357 -1 399 7 q 283 -10 315 -10 q 172 31 213 -10 q 131 143 131 71 l 131 453 z "
    },
    "m": {
      "ha": 1283,
      "x_min": 99,
      "x_max": 1192,
      "o": "m 1192 0 l 1069 0 l 1069 406 q 1033 574 1069 519 q 924 628 996 628 q 790 574 849 628 q 706 436 731 521 l 706 0 l 583 0 l 583 406 q 547 575 583 522 q 439 628 511 628 q 306 576 365 628 q 221 438 246 524 l 221 0 l 99 0 l 99 725 l 210 725 l 210 569 q 325 694 254 650 q 485 738 396 738 q 630 688 576 738 q 696 561 683 639 q 972 738 793 738 q 1077 715 1035 738 q 1144 651 1119 692 q 1181 554 1169 610 q 1192 433 1192 499 l 1192 0 z "
    },
    "−": {
      "ha": 746,
      "x_min": 93,
      "x_max": 653,
      "o": "m 93 374 l 93 474 l 653 474 l 653 374 l 93 374 z "
    },
    "µ": {
      "ha": 872,
      "x_min": 108,
      "x_max": 786,
      "o": "m 108 725 l 231 725 l 231 314 q 388 92 231 92 q 460 104 424 92 q 527 140 496 117 q 583 196 558 163 q 625 271 608 229 l 625 725 l 747 725 l 747 150 q 786 106 747 107 l 786 0 q 753 -3 765 -3 q 729 -4 740 -4 q 666 22 690 -4 q 642 79 642 47 l 642 156 q 597 92 625 122 q 535 38 569 61 q 462 0 501 14 q 381 -14 422 -14 q 278 17 317 -14 q 224 93 239 49 l 224 -294 l 108 -294 l 108 725 z "
    },
    "×": {
      "ha": 644,
      "x_min": 85,
      "x_max": 561,
      "o": "m 561 218 l 483 142 l 322 303 l 161 142 l 85 219 l 244 379 l 88 538 l 165 614 l 322 457 l 481 615 l 557 538 l 400 379 l 561 218 z "
    },
    "n": {
      "ha": 819,
      "x_min": 99,
      "x_max": 728,
      "o": "m 728 0 l 606 0 l 606 406 q 570 575 606 522 q 463 628 535 628 q 388 613 425 628 q 317 574 350 599 q 258 514 283 549 q 221 438 233 479 l 221 0 l 99 0 l 99 725 l 210 725 l 210 569 q 334 692 253 646 q 511 738 415 738 q 615 715 574 738 q 682 651 657 692 q 717 554 707 610 q 728 433 728 499 l 728 0 z "
    },
    "ń": {
      "ha": 819,
      "x_min": 99,
      "x_max": 728,
      "o": "m 442 846 l 361 874 l 442 1014 l 564 1014 l 442 846 m 728 0 l 606 0 l 606 406 q 570 575 606 522 q 463 628 535 628 q 388 613 425 628 q 317 574 350 599 q 258 514 283 549 q 221 438 233 479 l 221 0 l 99 0 l 99 725 l 210 725 l 210 569 q 334 692 253 646 q 511 738 415 738 q 615 715 574 738 q 682 651 657 692 q 717 554 707 610 q 728 433 728 499 l 728 0 z "
    },
    "ŉ": {
      "ha": 819,
      "x_min": -12,
      "x_max": 728,
      "o": "m 67 846 l -12 874 l 39 961 l 35 1014 l 190 1014 l 67 846 m 728 0 l 606 0 l 606 406 q 570 575 606 522 q 463 628 535 628 q 388 613 425 628 q 317 574 350 599 q 258 514 283 549 q 221 438 233 479 l 221 0 l 99 0 l 99 725 l 210 725 l 210 569 q 334 692 253 646 q 511 738 415 738 q 615 715 574 738 q 682 651 657 692 q 717 554 707 610 q 728 433 728 499 l 728 0 z "
    },
    "ň": {
      "ha": 819,
      "x_min": 99,
      "x_max": 728,
      "o": "m 303 1014 l 421 926 l 539 1014 l 606 981 l 465 856 l 376 856 l 236 981 l 303 1014 m 728 0 l 606 0 l 606 406 q 570 575 606 522 q 463 628 535 628 q 388 613 425 628 q 317 574 350 599 q 258 514 283 549 q 221 438 233 479 l 221 0 l 99 0 l 99 725 l 210 725 l 210 569 q 334 692 253 646 q 511 738 415 738 q 615 715 574 738 q 682 651 657 692 q 717 554 707 610 q 728 433 728 499 l 728 0 z "
    },
    "ņ": {
      "ha": 819,
      "x_min": 99,
      "x_max": 728,
      "o": "m 356 -296 l 383 -183 l 349 -183 l 349 -67 l 457 -67 l 457 -183 l 415 -296 l 356 -296 m 728 0 l 606 0 l 606 406 q 570 575 606 522 q 463 628 535 628 q 388 613 425 628 q 317 574 350 599 q 258 514 283 549 q 221 438 233 479 l 221 0 l 99 0 l 99 725 l 210 725 l 210 569 q 334 692 253 646 q 511 738 415 738 q 615 715 574 738 q 682 651 657 692 q 717 554 707 610 q 728 433 728 499 l 728 0 z "
    },
    "ṅ": {
      "ha": 819,
      "x_min": 99,
      "x_max": 728,
      "o": "m 365 867 l 365 1014 l 476 1014 l 476 867 l 365 867 m 728 0 l 606 0 l 606 406 q 570 575 606 522 q 463 628 535 628 q 388 613 425 628 q 317 574 350 599 q 258 514 283 549 q 221 438 233 479 l 221 0 l 99 0 l 99 725 l 210 725 l 210 569 q 334 692 253 646 q 511 738 415 738 q 615 715 574 738 q 682 651 657 692 q 717 554 707 610 q 728 433 728 499 l 728 0 z "
    },
    "₉": {
      "ha": 571,
      "x_min": 44,
      "x_max": 517,
      "o": "m 44 263 q 63 338 44 303 q 113 400 81 374 q 187 442 144 426 q 279 457 229 457 q 451 392 385 457 q 517 208 517 326 q 449 -37 517 44 q 269 -118 382 -118 q 154 -93 207 -118 q 74 -22 101 -68 l 121 29 q 181 -26 140 -6 q 272 -46 222 -46 q 396 6 349 -46 q 444 153 443 57 q 375 94 424 117 q 274 72 326 72 q 183 87 225 72 q 110 127 140 101 q 62 188 79 153 q 44 263 44 222 m 278 386 q 216 376 244 386 q 165 349 188 367 q 131 310 143 332 q 118 263 118 288 q 131 215 118 238 q 166 176 144 193 q 217 150 188 160 q 279 140 246 140 q 341 150 313 140 q 392 176 369 160 q 426 215 414 193 q 439 263 439 238 q 426 310 439 288 q 391 349 413 332 q 340 376 369 367 q 278 386 311 386 z "
    },
    "⁹": {
      "ha": 568,
      "x_min": 43,
      "x_max": 515,
      "o": "m 43 929 q 61 1006 43 971 q 111 1068 79 1042 q 185 1110 143 1094 q 278 1125 228 1125 q 449 1060 383 1125 q 515 876 515 994 q 448 631 515 713 q 268 549 381 549 q 153 574 206 549 q 72 646 100 600 l 119 696 q 180 641 139 661 q 271 621 221 621 q 394 673 347 621 q 443 821 442 725 q 374 763 422 785 q 272 740 325 740 q 181 755 224 740 q 108 795 139 769 q 60 855 78 821 q 43 929 43 889 m 276 1054 q 215 1044 243 1054 q 164 1017 186 1035 q 129 978 142 1000 q 117 931 117 956 q 130 883 117 906 q 165 844 143 861 q 215 818 186 828 q 278 808 244 808 q 340 818 311 808 q 390 844 368 828 q 425 883 413 861 q 438 929 438 904 q 424 977 438 954 q 390 1017 411 1000 q 339 1044 368 1035 q 276 1054 310 1054 z "
    },
    "ñ": {
      "ha": 819,
      "x_min": 99,
      "x_max": 728,
      "o": "m 728 0 l 606 0 l 606 406 q 570 575 606 522 q 463 628 535 628 q 388 613 425 628 q 317 574 350 599 q 258 514 283 549 q 221 438 233 479 l 221 0 l 99 0 l 99 725 l 210 725 l 210 569 q 334 692 253 646 q 511 738 415 738 q 615 715 574 738 q 682 651 657 692 q 717 554 707 610 q 728 433 728 499 l 728 0 m 507 871 q 452 880 475 871 q 409 900 429 889 q 369 920 389 911 q 328 929 350 929 q 291 919 304 929 q 271 898 278 910 q 262 875 264 886 q 260 863 260 864 l 188 863 q 194 894 188 871 q 215 943 200 918 q 257 987 231 968 q 325 1006 283 1006 q 376 997 354 1006 q 419 976 399 988 q 459 955 439 964 q 504 946 479 946 q 546 956 531 946 q 569 978 561 965 q 580 1001 578 990 q 582 1014 582 1011 l 654 1014 q 648 983 654 1006 q 625 935 642 960 q 580 890 608 910 q 507 871 551 871 z "
    },
    "#": {
      "ha": 961,
      "x_min": 51,
      "x_max": 910,
      "o": "m 910 621 l 724 621 l 664 374 l 849 374 l 849 279 l 642 279 l 574 0 l 472 0 l 542 279 l 308 279 l 240 0 l 139 0 l 208 279 l 51 279 l 51 374 l 231 374 l 290 621 l 113 621 l 113 710 l 313 710 l 379 986 l 481 986 l 413 710 l 646 710 l 713 986 l 814 986 l 746 710 l 910 710 l 910 621 m 564 374 l 624 621 l 390 621 l 331 374 l 564 374 z "
    },
    "o": {
      "ha": 832,
      "x_min": 50,
      "x_max": 782,
      "o": "m 415 -14 q 266 17 333 -14 q 151 99 199 47 q 76 218 103 150 q 50 361 50 286 q 77 506 50 438 q 152 625 104 574 q 267 707 200 676 q 415 738 335 738 q 564 707 496 738 q 680 625 632 676 q 755 506 728 574 q 782 361 782 438 q 756 218 782 286 q 681 99 729 150 q 565 17 632 47 q 415 -14 497 -14 m 175 360 q 194 254 175 303 q 245 169 213 206 q 322 113 278 133 q 415 92 365 92 q 509 113 465 92 q 586 170 553 133 q 638 256 619 207 q 657 363 657 306 q 638 467 657 418 q 586 553 619 517 q 509 611 553 590 q 415 632 465 632 q 322 610 365 632 q 245 552 278 589 q 194 466 213 515 q 175 360 175 417 z "
    },
    "ó": {
      "ha": 832,
      "x_min": 50,
      "x_max": 782,
      "o": "m 436 846 l 356 874 l 436 1014 l 558 1014 l 436 846 m 415 -14 q 266 17 333 -14 q 151 99 199 47 q 76 218 103 150 q 50 361 50 286 q 77 506 50 438 q 152 625 104 574 q 267 707 200 676 q 415 738 335 738 q 564 707 496 738 q 680 625 632 676 q 755 506 728 574 q 782 361 782 438 q 756 218 782 286 q 681 99 729 150 q 565 17 632 47 q 415 -14 497 -14 m 175 360 q 194 254 175 303 q 245 169 213 206 q 322 113 278 133 q 415 92 365 92 q 509 113 465 92 q 586 170 553 133 q 638 256 619 207 q 657 363 657 306 q 638 467 657 418 q 586 553 619 517 q 509 611 553 590 q 415 632 465 632 q 322 610 365 632 q 245 552 278 589 q 194 466 213 515 q 175 360 175 417 z "
    },
    "ŏ": {
      "ha": 832,
      "x_min": 50,
      "x_max": 782,
      "o": "m 415 -14 q 266 17 333 -14 q 151 99 199 47 q 76 218 103 150 q 50 361 50 286 q 77 506 50 438 q 152 625 104 574 q 267 707 200 676 q 415 738 335 738 q 564 707 496 738 q 680 625 632 676 q 755 506 728 574 q 782 361 782 438 q 756 218 782 286 q 681 99 729 150 q 565 17 632 47 q 415 -14 497 -14 m 175 360 q 194 254 175 303 q 245 169 213 206 q 322 113 278 133 q 415 92 365 92 q 509 113 465 92 q 586 170 553 133 q 638 256 619 207 q 657 363 657 306 q 638 467 657 418 q 586 553 619 517 q 509 611 553 590 q 415 632 465 632 q 322 610 365 632 q 245 552 278 589 q 194 466 213 515 q 175 360 175 417 m 415 919 q 469 947 446 919 q 496 1014 492 974 l 565 1014 q 553 953 565 981 q 522 904 542 925 q 474 872 501 883 q 415 860 447 860 q 356 872 383 860 q 309 904 329 883 q 277 953 289 925 q 265 1014 265 981 l 336 1014 q 360 948 336 976 q 415 919 383 919 z "
    },
    "ô": {
      "ha": 832,
      "x_min": 50,
      "x_max": 782,
      "o": "m 231 889 l 371 1014 l 460 1014 l 600 889 l 533 856 l 415 943 l 297 856 l 231 889 m 415 -14 q 266 17 333 -14 q 151 99 199 47 q 76 218 103 150 q 50 361 50 286 q 77 506 50 438 q 152 625 104 574 q 267 707 200 676 q 415 738 335 738 q 564 707 496 738 q 680 625 632 676 q 755 506 728 574 q 782 361 782 438 q 756 218 782 286 q 681 99 729 150 q 565 17 632 47 q 415 -14 497 -14 m 175 360 q 194 254 175 303 q 245 169 213 206 q 322 113 278 133 q 415 92 365 92 q 509 113 465 92 q 586 170 553 133 q 638 256 619 207 q 657 363 657 306 q 638 467 657 418 q 586 553 619 517 q 509 611 553 590 q 415 632 465 632 q 322 610 365 632 q 245 552 278 589 q 194 466 213 515 q 175 360 175 417 z "
    },
    "ö": {
      "ha": 832,
      "x_min": 50,
      "x_max": 782,
      "o": "m 251 867 l 251 1008 l 354 1008 l 354 867 l 251 867 m 476 867 l 476 1008 l 579 1008 l 579 867 l 476 867 m 415 -14 q 266 17 333 -14 q 151 99 199 47 q 76 218 103 150 q 50 361 50 286 q 77 506 50 438 q 152 625 104 574 q 267 707 200 676 q 415 738 335 738 q 564 707 496 738 q 680 625 632 676 q 755 506 728 574 q 782 361 782 438 q 756 218 782 286 q 681 99 729 150 q 565 17 632 47 q 415 -14 497 -14 m 175 360 q 194 254 175 303 q 245 169 213 206 q 322 113 278 133 q 415 92 365 92 q 509 113 465 92 q 586 170 553 133 q 638 256 619 207 q 657 363 657 306 q 638 467 657 418 q 586 553 619 517 q 509 611 553 590 q 415 632 465 632 q 322 610 365 632 q 245 552 278 589 q 194 466 213 515 q 175 360 175 417 z "
    },
    "œ": {
      "ha": 1428,
      "x_min": 50,
      "x_max": 1389,
      "o": "m 414 -14 q 269 15 336 -14 q 154 94 203 43 q 78 213 106 144 q 50 360 50 281 q 78 509 50 440 q 155 628 106 578 q 271 708 204 679 q 415 738 338 738 q 598 681 518 738 q 718 526 678 625 q 840 683 761 628 q 1025 738 918 738 q 1167 710 1103 738 q 1280 634 1232 683 q 1356 516 1328 585 q 1389 363 1385 447 q 1389 341 1389 354 q 1388 321 1389 328 l 786 321 q 812 225 790 269 q 867 147 833 181 q 946 95 901 114 q 1040 76 990 76 q 1108 85 1075 76 q 1169 110 1142 94 q 1217 149 1197 126 q 1249 199 1238 171 l 1351 169 q 1300 94 1332 128 q 1226 37 1268 61 q 1135 -1 1185 13 q 1035 -14 1086 -14 q 853 42 935 -14 q 719 193 771 97 q 590 40 668 94 q 414 -14 513 -14 m 415 92 q 510 113 467 92 q 587 169 554 133 q 638 255 619 206 q 657 361 657 304 q 638 467 657 418 q 588 553 619 517 q 511 611 556 590 q 417 632 467 632 q 322 610 367 632 q 245 552 278 589 q 194 465 213 515 q 175 358 175 415 q 194 253 175 301 q 244 168 213 204 q 321 112 276 132 q 415 92 365 92 m 1271 400 q 1246 499 1267 454 q 1192 577 1225 544 q 1115 628 1158 610 q 1022 646 1071 646 q 931 628 974 646 q 857 577 889 610 q 806 499 825 544 q 783 400 786 454 l 1271 400 z "
    },
    "ò": {
      "ha": 832,
      "x_min": 50,
      "x_max": 782,
      "o": "m 415 -14 q 266 17 333 -14 q 151 99 199 47 q 76 218 103 150 q 50 361 50 286 q 77 506 50 438 q 152 625 104 574 q 267 707 200 676 q 415 738 335 738 q 564 707 496 738 q 680 625 632 676 q 755 506 728 574 q 782 361 782 438 q 756 218 782 286 q 681 99 729 150 q 565 17 632 47 q 415 -14 497 -14 m 175 360 q 194 254 175 303 q 245 169 213 206 q 322 113 278 133 q 415 92 365 92 q 509 113 465 92 q 586 170 553 133 q 638 256 619 207 q 657 363 657 306 q 638 467 657 418 q 586 553 619 517 q 509 611 553 590 q 415 632 465 632 q 322 610 365 632 q 245 552 278 589 q 194 466 213 515 q 175 360 175 417 m 272 1014 l 393 1014 l 475 874 l 396 846 l 272 1014 z "
    },
    "ő": {
      "ha": 832,
      "x_min": 50,
      "x_max": 782,
      "o": "m 328 846 l 264 874 l 339 1014 l 444 1014 l 328 846 m 517 846 l 453 874 l 528 1014 l 633 1014 l 517 846 m 415 -14 q 266 17 333 -14 q 151 99 199 47 q 76 218 103 150 q 50 361 50 286 q 77 506 50 438 q 152 625 104 574 q 267 707 200 676 q 415 738 335 738 q 564 707 496 738 q 680 625 632 676 q 755 506 728 574 q 782 361 782 438 q 756 218 782 286 q 681 99 729 150 q 565 17 632 47 q 415 -14 497 -14 m 175 360 q 194 254 175 303 q 245 169 213 206 q 322 113 278 133 q 415 92 365 92 q 509 113 465 92 q 586 170 553 133 q 638 256 619 207 q 657 363 657 306 q 638 467 657 418 q 586 553 619 517 q 509 611 553 590 q 415 632 465 632 q 322 610 365 632 q 245 552 278 589 q 194 466 213 515 q 175 360 175 417 z "
    },
    "ō": {
      "ha": 832,
      "x_min": 50,
      "x_max": 782,
      "o": "m 214 908 l 214 989 l 619 989 l 619 908 l 214 908 m 415 -14 q 266 17 333 -14 q 151 99 199 47 q 76 218 103 150 q 50 361 50 286 q 77 506 50 438 q 152 625 104 574 q 267 707 200 676 q 415 738 335 738 q 564 707 496 738 q 680 625 632 676 q 755 506 728 574 q 782 361 782 438 q 756 218 782 286 q 681 99 729 150 q 565 17 632 47 q 415 -14 497 -14 m 175 360 q 194 254 175 303 q 245 169 213 206 q 322 113 278 133 q 415 92 365 92 q 509 113 465 92 q 586 170 553 133 q 638 256 619 207 q 657 363 657 306 q 638 467 657 418 q 586 553 619 517 q 509 611 553 590 q 415 632 465 632 q 322 610 365 632 q 245 552 278 589 q 194 466 213 515 q 175 360 175 417 z "
    },
    "⅛": {
      "ha": 1232,
      "x_min": 63,
      "x_max": 1183,
      "o": "m 1183 160 q 1165 92 1183 122 q 1114 40 1146 61 q 1040 6 1082 18 q 951 -7 999 -7 q 860 6 901 -7 q 788 42 818 19 q 740 97 757 65 q 722 163 722 128 q 733 211 722 189 q 760 251 743 233 q 801 281 778 268 q 847 303 824 294 q 776 346 807 318 q 744 417 744 374 q 763 478 744 450 q 811 524 782 506 q 878 553 840 543 q 953 564 915 564 q 1028 553 990 564 q 1094 524 1065 543 q 1142 478 1124 506 q 1161 418 1161 451 q 1131 347 1161 376 q 1057 303 1101 318 q 1147 248 1111 283 q 1183 160 1183 213 m 1106 168 q 1092 210 1106 192 q 1056 242 1078 229 q 1007 261 1035 254 q 953 268 979 268 q 896 261 924 268 q 847 240 868 254 q 813 208 826 226 q 800 167 800 189 q 814 125 800 143 q 850 94 828 107 q 899 76 872 82 q 954 69 926 69 q 1009 76 982 69 q 1058 97 1036 83 q 1092 128 1079 110 q 1106 168 1106 146 m 822 410 q 834 376 822 390 q 865 351 846 361 q 906 336 883 342 q 953 331 929 331 q 999 336 975 331 q 1042 352 1022 342 q 1073 377 1061 363 q 1085 411 1085 392 q 1074 444 1085 429 q 1044 469 1063 458 q 1001 485 1025 479 q 953 490 978 490 q 861 469 900 490 q 822 410 822 447 m 375 521 l 375 444 l 83 444 l 83 521 l 194 521 l 194 929 q 172 909 188 921 q 138 887 157 897 q 99 869 119 876 q 63 861 79 861 l 63 938 q 108 949 85 938 q 150 975 131 961 q 182 1001 169 989 q 194 1015 194 1014 l 272 1015 l 272 521 l 375 521 m 172 46 l 561 514 l 933 993 l 993 942 l 608 476 l 231 -7 l 172 46 z "
    },
    "¹": {
      "ha": 389,
      "x_min": 47,
      "x_max": 360,
      "o": "m 360 632 l 360 556 l 68 556 l 68 632 l 179 632 l 179 1040 q 157 1020 172 1032 q 123 998 142 1008 q 84 980 104 988 q 47 972 64 972 l 47 1049 q 92 1060 69 1049 q 135 1086 115 1072 q 167 1113 154 1100 q 179 1126 179 1125 l 257 1126 l 257 632 l 360 632 z "
    },
    "½": {
      "ha": 1239,
      "x_min": 61,
      "x_max": 1182,
      "o": "m 746 0 q 756 95 746 54 q 786 167 765 136 q 840 220 807 197 q 917 261 872 243 q 979 285 947 274 q 1038 313 1011 297 q 1081 349 1064 328 q 1097 400 1097 369 q 1065 469 1097 442 q 968 496 1032 496 q 910 489 936 496 q 863 471 883 482 q 826 447 842 460 q 799 421 810 433 l 751 476 q 776 502 758 486 q 822 533 793 518 q 890 560 850 549 q 979 571 929 571 q 1130 523 1079 571 q 1181 399 1181 475 q 1162 325 1181 354 q 1116 276 1143 296 q 1056 243 1089 256 q 997 222 1024 231 q 929 190 956 208 q 888 153 903 172 q 869 113 874 133 q 864 75 864 93 l 1182 75 l 1182 0 l 746 0 m 374 521 l 374 444 l 82 444 l 82 521 l 193 521 l 193 929 q 171 909 186 921 q 137 887 156 897 q 98 869 118 876 q 61 861 78 861 l 61 938 q 106 949 83 938 q 149 975 129 961 q 181 1001 168 989 q 193 1015 193 1014 l 271 1015 l 271 521 l 374 521 m 153 46 l 542 514 l 914 993 l 974 942 l 589 476 l 211 -7 l 153 46 z "
    },
    "₂": {
      "ha": 556,
      "x_min": 47,
      "x_max": 500,
      "o": "m 47 -111 q 58 -16 47 -57 q 90 56 68 25 q 145 109 111 86 q 225 150 179 132 q 290 174 257 163 q 351 201 324 186 q 395 238 378 217 q 413 289 413 258 q 378 358 413 331 q 278 385 344 385 q 217 378 244 385 q 168 360 190 371 q 130 335 146 349 q 103 310 114 322 l 53 365 q 78 391 60 375 q 126 422 97 407 q 197 449 156 438 q 289 460 238 460 q 446 412 393 460 q 499 288 499 364 q 479 214 499 243 q 431 165 460 185 q 369 132 403 144 q 308 111 336 119 q 238 79 265 97 q 196 42 211 61 q 175 2 181 22 q 169 -36 169 -18 l 500 -36 l 500 -111 l 47 -111 z "
    },
    "₁": {
      "ha": 418,
      "x_min": 47,
      "x_max": 390,
      "o": "m 390 -36 l 390 -111 l 68 -111 l 68 -36 l 194 -36 l 194 374 q 169 352 186 364 q 132 330 153 340 q 88 313 111 319 q 47 306 65 306 l 47 382 q 98 394 72 382 q 145 419 124 406 q 181 446 167 433 q 194 460 194 458 l 272 460 l 272 -36 l 390 -36 z "
    },
    "¼": {
      "ha": 1192,
      "x_min": 61,
      "x_max": 1143,
      "o": "m 985 0 l 985 139 l 671 139 l 671 213 l 1008 564 l 1061 564 l 1061 214 l 1143 214 l 1143 139 l 1061 139 l 1061 0 l 985 0 m 750 214 l 988 214 l 988 464 l 750 214 m 374 521 l 374 444 l 82 444 l 82 521 l 193 521 l 193 929 q 171 909 186 921 q 137 887 156 897 q 98 869 118 876 q 61 861 78 861 l 61 938 q 106 949 83 938 q 149 975 129 961 q 181 1001 168 989 q 193 1015 193 1014 l 271 1015 l 271 521 l 374 521 m 204 46 l 593 514 l 965 993 l 1025 942 l 640 476 l 263 -7 l 204 46 z "
    },
    "⅓": {
      "ha": 1235,
      "x_min": 64,
      "x_max": 1185,
      "o": "m 953 -7 q 806 24 865 -7 q 733 113 747 56 l 778 164 q 792 133 779 149 q 828 102 806 117 q 883 78 851 88 q 951 69 914 69 q 1062 94 1017 69 q 1107 160 1107 118 q 1051 231 1107 206 q 900 256 996 256 l 868 256 l 868 325 l 900 325 q 1038 346 988 325 q 1088 411 1088 367 q 1045 476 1088 453 q 949 500 1003 500 q 851 479 892 500 q 789 425 811 458 l 738 485 q 824 548 765 525 q 949 571 882 571 q 1036 559 996 571 q 1106 526 1076 547 q 1153 478 1136 506 q 1169 417 1169 450 q 1137 337 1169 368 q 1042 293 1104 306 q 1147 243 1108 283 q 1185 149 1185 203 q 1166 82 1185 111 q 1115 33 1147 53 q 1040 3 1082 13 q 953 -7 999 -7 m 376 521 l 376 444 l 85 444 l 85 521 l 196 521 l 196 929 q 174 909 189 921 q 140 887 158 897 q 101 869 121 876 q 64 861 81 861 l 64 938 q 109 949 86 938 q 151 975 132 961 q 183 1001 171 989 q 196 1015 196 1014 l 274 1015 l 274 521 l 376 521 m 156 46 l 544 514 l 917 993 l 976 942 l 592 476 l 214 -7 l 156 46 z "
    },
    "₃": {
      "ha": 549,
      "x_min": 44,
      "x_max": 496,
      "o": "m 264 -118 q 117 -87 176 -118 q 44 1 58 -56 l 89 53 q 103 22 90 38 q 140 -9 117 6 q 194 -33 163 -24 q 263 -42 225 -42 q 373 -17 328 -42 q 418 49 418 7 q 363 119 418 94 q 211 144 307 144 l 179 144 l 179 214 l 211 214 q 349 235 299 214 q 399 300 399 256 q 356 365 399 342 q 260 389 314 389 q 163 368 203 389 q 100 314 122 347 l 49 374 q 135 437 76 414 q 260 460 193 460 q 347 448 307 460 q 417 415 388 436 q 464 367 447 394 q 481 306 481 339 q 448 226 481 257 q 353 182 415 194 q 458 132 419 172 q 496 38 496 92 q 477 -29 496 0 q 426 -78 458 -58 q 351 -108 393 -99 q 264 -118 310 -118 z "
    },
    "ǫ": {
      "ha": 832,
      "x_min": 50,
      "x_max": 782,
      "o": "m 413 -258 q 325 -219 354 -247 q 296 -151 296 -190 q 393 -12 296 -82 q 252 23 315 -8 q 144 106 189 54 q 75 222 100 157 q 50 361 50 288 q 77 506 50 438 q 152 625 104 574 q 267 707 200 676 q 415 738 335 738 q 564 707 496 738 q 680 625 632 676 q 755 506 728 574 q 782 361 782 438 q 760 231 782 293 q 698 119 738 168 q 601 35 658 69 q 476 -8 544 1 q 392 -74 418 -44 q 367 -135 367 -104 q 443 -194 367 -186 l 413 -258 m 175 360 q 194 254 175 303 q 245 169 213 206 q 322 113 278 133 q 415 92 365 92 q 509 113 465 92 q 586 170 553 133 q 638 256 619 207 q 657 363 657 306 q 638 467 657 418 q 586 553 619 517 q 509 611 553 590 q 415 632 465 632 q 322 610 365 632 q 245 552 278 589 q 194 466 213 515 q 175 360 175 417 z "
    },
    "ª": {
      "ha": 608,
      "x_min": 64,
      "x_max": 532,
      "o": "m 229 478 q 164 490 194 478 q 111 522 133 501 q 76 571 89 543 q 64 632 64 599 q 122 744 64 701 q 271 788 179 788 q 342 781 307 788 q 404 764 376 775 l 404 799 q 372 886 404 854 q 281 918 340 918 q 203 903 242 918 q 124 861 165 889 l 92 924 q 289 988 189 988 q 446 936 389 988 q 503 788 503 885 l 503 606 q 532 572 503 574 l 532 486 q 509 483 518 483 q 489 482 500 482 q 441 497 458 482 q 421 536 424 513 l 419 568 q 335 501 385 524 q 229 478 286 478 m 257 551 q 332 566 297 551 q 386 604 367 581 q 404 640 404 621 l 404 707 q 347 723 378 718 q 288 728 317 728 q 193 704 229 728 q 157 640 157 681 q 185 577 157 603 q 257 551 214 551 z "
    },
    "º": {
      "ha": 622,
      "x_min": 58,
      "x_max": 564,
      "o": "m 311 478 q 208 499 254 478 q 128 554 161 519 q 76 635 94 589 q 58 732 58 682 q 76 830 58 783 q 128 912 94 876 q 208 967 161 947 q 311 988 254 988 q 415 967 368 988 q 494 912 461 947 q 546 830 528 876 q 564 732 564 783 q 546 635 564 682 q 494 554 528 589 q 415 499 461 519 q 311 478 368 478 m 158 731 q 170 664 158 694 q 203 611 182 633 q 251 576 224 589 q 311 563 279 563 q 371 576 343 563 q 419 612 399 589 q 452 666 440 635 q 464 733 464 697 q 452 800 464 769 q 419 853 440 831 q 371 889 399 876 q 311 901 343 901 q 251 888 279 901 q 203 852 224 875 q 170 798 182 829 q 158 731 158 767 z "
    },
    "ø": {
      "ha": 832,
      "x_min": 50,
      "x_max": 782,
      "o": "m 111 -3 l 174 75 q 83 202 115 128 q 50 361 50 276 q 77 506 50 438 q 152 625 104 574 q 267 707 200 676 q 415 738 335 738 q 518 724 469 738 q 607 685 567 710 l 640 728 l 718 728 l 656 649 q 749 521 715 596 q 782 361 782 446 q 756 218 782 286 q 681 99 729 150 q 565 17 632 47 q 415 -14 497 -14 q 221 40 307 -14 l 188 -3 l 111 -3 m 415 92 q 509 113 465 92 q 586 170 553 133 q 638 256 619 207 q 657 363 657 306 q 637 470 657 421 q 583 556 617 519 l 289 131 q 415 92 344 92 m 175 360 q 194 252 175 301 q 247 167 214 203 l 540 593 q 481 622 513 611 q 415 632 450 632 q 322 610 365 632 q 245 552 278 589 q 194 466 213 515 q 175 360 175 417 z "
    },
    "ǿ": {
      "ha": 832,
      "x_min": 50,
      "x_max": 782,
      "o": "m 436 846 l 356 874 l 436 1014 l 558 1014 l 436 846 m 111 -3 l 174 75 q 83 202 115 128 q 50 361 50 276 q 77 506 50 438 q 152 625 104 574 q 267 707 200 676 q 415 738 335 738 q 518 724 469 738 q 607 685 567 710 l 640 728 l 718 728 l 656 649 q 749 521 715 596 q 782 361 782 446 q 756 218 782 286 q 681 99 729 150 q 565 17 632 47 q 415 -14 497 -14 q 221 40 307 -14 l 188 -3 l 111 -3 m 415 92 q 509 113 465 92 q 586 170 553 133 q 638 256 619 207 q 657 363 657 306 q 637 470 657 421 q 583 556 617 519 l 289 131 q 415 92 344 92 m 175 360 q 194 252 175 301 q 247 167 214 203 l 540 593 q 481 622 513 611 q 415 632 450 632 q 322 610 365 632 q 245 552 278 589 q 194 466 213 515 q 175 360 175 417 z "
    },
    "õ": {
      "ha": 832,
      "x_min": 50,
      "x_max": 782,
      "o": "m 415 -14 q 266 17 333 -14 q 151 99 199 47 q 76 218 103 150 q 50 361 50 286 q 77 506 50 438 q 152 625 104 574 q 267 707 200 676 q 415 738 335 738 q 564 707 496 738 q 680 625 632 676 q 755 506 728 574 q 782 361 782 438 q 756 218 782 286 q 681 99 729 150 q 565 17 632 47 q 415 -14 497 -14 m 175 360 q 194 254 175 303 q 245 169 213 206 q 322 113 278 133 q 415 92 365 92 q 509 113 465 92 q 586 170 553 133 q 638 256 619 207 q 657 363 657 306 q 638 467 657 418 q 586 553 619 517 q 509 611 553 590 q 415 632 465 632 q 322 610 365 632 q 245 552 278 589 q 194 466 213 515 q 175 360 175 417 m 503 871 q 448 880 471 871 q 405 900 425 889 q 365 920 385 911 q 324 929 346 929 q 287 919 300 929 q 267 898 274 910 q 258 875 260 886 q 256 863 256 864 l 183 863 q 190 894 183 871 q 211 943 196 918 q 253 987 226 968 q 321 1006 279 1006 q 372 997 350 1006 q 415 976 394 988 q 455 955 435 964 q 500 946 475 946 q 542 956 526 946 q 565 978 557 965 q 576 1001 574 990 q 578 1014 578 1011 l 650 1014 q 644 983 650 1006 q 621 935 638 960 q 576 890 604 910 q 503 871 547 871 z "
    },
    "p": {
      "ha": 865,
      "x_min": 99,
      "x_max": 814,
      "o": "m 489 -14 q 330 31 399 -14 q 221 143 261 75 l 221 -296 l 99 -296 l 99 725 l 207 725 l 207 589 q 319 697 250 656 q 471 738 388 738 q 608 707 546 738 q 717 624 671 676 q 788 504 763 572 q 814 363 814 436 q 790 216 814 285 q 724 97 767 147 q 621 16 681 46 q 489 -14 561 -14 m 451 92 q 549 115 506 92 q 624 176 593 138 q 672 263 656 214 q 689 363 689 311 q 669 466 689 417 q 617 552 650 515 q 538 610 583 589 q 440 632 493 632 q 372 619 407 632 q 305 584 336 606 q 251 533 274 563 q 221 469 228 503 l 221 263 q 260 195 236 226 q 314 141 283 164 q 379 105 344 118 q 451 92 414 92 z "
    },
    "¶": {
      "ha": 858,
      "x_min": 49,
      "x_max": 797,
      "o": "m 49 646 q 151 897 49 807 q 440 986 254 986 l 797 986 l 797 892 l 700 892 l 700 -111 l 594 -111 l 594 311 l 501 311 l 501 -111 l 396 -111 l 396 311 q 252 336 317 313 q 142 403 188 360 q 73 508 97 446 q 49 646 49 569 m 153 649 q 172 545 153 589 q 225 471 192 501 q 302 424 258 440 q 396 406 346 408 l 396 892 q 215 824 278 889 q 153 649 153 760 m 594 892 l 501 892 l 501 406 l 594 406 l 594 892 z "
    },
    "(": {
      "ha": 393,
      "x_min": 58,
      "x_max": 350,
      "o": "m 58 481 q 74 621 58 551 q 116 759 89 690 q 178 896 143 828 q 256 1033 214 964 l 350 992 q 292 892 324 951 q 235 763 261 832 q 190 619 208 693 q 172 476 172 544 q 219 241 172 367 q 347 -11 267 115 l 257 -58 q 114 209 169 72 q 58 481 58 346 z "
    },
    ")": {
      "ha": 393,
      "x_min": 43,
      "x_max": 335,
      "o": "m 335 481 q 279 209 335 346 q 136 -58 224 72 l 46 -11 q 174 241 126 115 q 221 476 221 367 q 203 619 221 544 q 158 763 185 693 q 101 892 132 832 q 43 992 69 951 l 138 1033 q 215 896 179 964 q 277 759 250 828 q 319 621 304 690 q 335 481 335 551 z "
    },
    "%": {
      "ha": 1018,
      "x_min": 51,
      "x_max": 967,
      "o": "m 265 594 q 182 610 221 594 q 114 653 143 626 q 68 718 85 681 q 51 797 51 756 q 68 876 51 839 q 114 941 85 914 q 182 984 143 968 q 265 1000 221 1000 q 349 984 310 1000 q 417 941 388 968 q 463 876 446 914 q 479 797 479 839 q 463 718 479 756 q 417 653 446 681 q 349 610 388 626 q 265 594 310 594 m 265 661 q 315 672 292 661 q 354 702 338 683 q 381 745 371 721 q 390 797 390 769 q 380 850 390 825 q 353 894 369 875 q 313 923 336 913 q 265 933 290 933 q 216 922 239 933 q 176 892 193 911 q 150 849 160 874 q 140 797 140 824 q 150 744 140 769 q 177 701 160 719 q 217 672 194 682 q 265 661 240 661 m 753 -14 q 669 2 708 -14 q 601 45 631 18 q 556 110 572 72 q 539 189 539 147 q 556 268 539 231 q 601 333 572 306 q 669 376 631 360 q 753 392 708 392 q 836 376 797 392 q 904 333 875 360 q 950 268 933 306 q 967 189 967 231 q 950 110 967 147 q 904 45 933 72 q 836 2 875 18 q 753 -14 797 -14 m 753 53 q 802 64 779 53 q 842 94 825 75 q 868 137 858 113 q 878 189 878 161 q 867 242 878 217 q 840 285 857 267 q 801 315 824 304 q 753 325 778 325 q 703 314 726 325 q 664 284 681 303 q 638 240 647 265 q 628 189 628 215 q 638 136 628 161 q 665 92 647 111 q 705 63 682 74 q 753 53 728 53 m 99 46 l 488 514 l 860 993 l 919 942 l 535 476 l 157 -7 l 99 46 z "
    },
    ".": {
      "ha": 281,
      "x_min": 89,
      "x_max": 192,
      "o": "m 89 0 l 89 156 l 192 156 l 192 0 l 89 0 z "
    },
    "‰": {
      "ha": 1522,
      "x_min": 60,
      "x_max": 1476,
      "o": "m 274 594 q 190 610 229 594 q 122 653 151 626 q 76 718 93 681 q 60 797 60 756 q 76 876 60 839 q 122 941 93 914 q 190 984 151 968 q 274 1000 229 1000 q 357 984 318 1000 q 425 941 396 968 q 471 876 454 914 q 488 797 488 839 q 471 718 488 756 q 425 653 454 681 q 357 610 396 626 q 274 594 318 594 m 274 661 q 323 672 300 661 q 363 702 346 683 q 389 745 379 721 q 399 797 399 769 q 388 850 399 825 q 361 894 378 875 q 322 923 344 913 q 274 933 299 933 q 224 922 247 933 q 185 892 201 911 q 158 849 168 874 q 149 797 149 824 q 159 744 149 769 q 186 701 169 719 q 226 672 203 682 q 274 661 249 661 m 761 -14 q 678 2 717 -14 q 610 45 639 18 q 564 110 581 72 q 547 189 547 147 q 564 268 547 231 q 610 333 581 306 q 678 376 639 360 q 761 392 717 392 q 844 376 806 392 q 913 333 883 360 q 958 268 942 306 q 975 189 975 231 q 958 110 975 147 q 913 45 942 72 q 844 2 883 18 q 761 -14 806 -14 m 761 53 q 810 64 788 53 q 850 94 833 75 q 876 137 867 113 q 886 189 886 161 q 876 242 886 217 q 849 285 865 267 q 809 315 832 304 q 761 325 786 325 q 712 314 735 325 q 672 284 689 303 q 646 240 656 265 q 636 189 636 215 q 646 136 636 161 q 673 92 656 111 q 713 63 690 74 q 761 53 736 53 m 1263 -14 q 1179 2 1218 -14 q 1111 45 1140 18 q 1065 110 1082 72 q 1049 189 1049 147 q 1065 268 1049 231 q 1111 333 1082 306 q 1179 376 1140 360 q 1263 392 1218 392 q 1346 376 1307 392 q 1414 333 1385 360 q 1460 268 1443 306 q 1476 189 1476 231 q 1460 110 1476 147 q 1414 45 1443 72 q 1346 2 1385 18 q 1263 -14 1307 -14 m 1263 53 q 1312 64 1289 53 q 1351 94 1335 75 q 1378 137 1368 113 q 1388 189 1388 161 q 1377 242 1388 217 q 1350 285 1367 267 q 1310 315 1333 304 q 1263 325 1288 325 q 1213 314 1236 325 q 1174 284 1190 303 q 1147 240 1157 265 q 1138 189 1138 215 q 1147 136 1138 161 q 1174 92 1157 111 q 1215 63 1192 74 q 1263 53 1238 53 m 107 46 l 496 514 l 868 993 l 928 942 l 543 476 l 165 -7 l 107 46 z "
    },
    "+": {
      "ha": 578,
      "x_min": 69,
      "x_max": 508,
      "o": "m 508 543 l 508 443 l 344 443 l 344 265 l 233 265 l 233 443 l 69 443 l 69 543 l 233 543 l 233 721 l 344 721 l 344 543 l 508 543 z "
    },
    "±": {
      "ha": 647,
      "x_min": 93,
      "x_max": 554,
      "o": "m 93 71 l 93 171 l 554 171 l 554 71 l 93 71 m 554 561 l 554 461 l 379 461 l 379 272 l 268 272 l 268 461 l 93 461 l 93 561 l 268 561 l 268 750 l 379 750 l 379 561 l 554 561 z "
    },
    "q": {
      "ha": 865,
      "x_min": 51,
      "x_max": 806,
      "o": "m 376 -14 q 244 17 304 -14 q 142 99 185 47 q 75 219 99 151 q 51 363 51 288 q 78 507 51 439 q 151 626 104 575 q 260 708 197 678 q 394 738 322 738 q 549 696 479 738 q 658 588 618 654 l 658 725 l 767 725 l 767 -140 q 806 -185 767 -183 l 806 -290 q 740 -294 772 -294 q 673 -266 701 -294 q 644 -197 644 -237 l 644 143 q 376 -14 544 -14 m 418 92 q 552 137 496 92 q 644 247 608 182 l 644 456 q 615 523 638 490 q 562 579 593 556 q 494 617 531 603 q 421 632 457 632 q 322 609 367 632 q 245 548 278 586 q 194 460 213 510 q 176 360 176 411 q 194 256 176 306 q 244 171 213 207 q 321 113 276 135 q 418 92 365 92 z "
    },
    "?": {
      "ha": 665,
      "x_min": 47,
      "x_max": 614,
      "o": "m 200 293 q 226 424 200 368 q 317 521 253 481 q 374 556 342 538 q 436 598 407 574 q 485 656 465 622 q 506 738 506 690 q 491 806 506 776 q 453 856 476 836 q 399 887 429 876 q 335 897 368 897 q 269 887 300 897 q 211 858 238 876 q 164 816 185 840 q 129 765 143 792 l 47 819 q 96 896 65 863 q 165 952 126 929 q 248 987 204 975 q 338 999 292 999 q 439 983 389 999 q 528 933 489 967 q 590 850 567 900 q 614 732 614 800 q 599 642 614 679 q 561 576 585 604 q 506 528 538 549 q 439 488 474 507 q 389 458 414 474 q 345 422 364 443 q 315 369 326 400 q 303 293 303 339 l 200 293 m 203 0 l 203 161 l 306 161 l 306 0 l 203 0 z "
    },
    "¿": {
      "ha": 657,
      "x_min": 46,
      "x_max": 613,
      "o": "m 460 410 q 433 278 460 335 q 343 182 407 222 q 285 147 318 165 q 224 105 253 129 q 174 47 194 81 q 154 -35 154 13 q 169 -103 154 -74 q 207 -153 183 -133 q 261 -184 231 -174 q 325 -194 292 -194 q 391 -184 360 -194 q 449 -156 422 -174 q 496 -113 475 -137 q 531 -62 517 -89 l 613 -117 q 563 -193 593 -160 q 494 -249 533 -226 q 412 -284 456 -272 q 322 -296 368 -296 q 221 -280 271 -296 q 132 -231 171 -264 q 69 -147 93 -197 q 46 -29 46 -97 q 60 61 46 24 q 99 126 75 99 q 154 175 122 154 q 221 215 186 196 q 271 244 246 229 q 315 281 296 260 q 345 333 333 303 q 357 410 357 364 l 460 410 m 457 703 l 457 542 l 354 542 l 354 703 l 457 703 z "
    },
    "\"": {
      "ha": 450,
      "x_min": 93,
      "x_max": 357,
      "o": "m 93 697 l 93 997 l 199 997 l 199 697 l 93 697 m 251 697 l 251 997 l 357 997 l 357 697 l 251 697 z "
    },
    "„": {
      "ha": 485,
      "x_min": 89,
      "x_max": 396,
      "o": "m 103 -160 l 131 0 l 89 0 l 89 158 l 204 158 l 204 0 l 163 -160 l 103 -160 m 294 -160 l 322 0 l 281 0 l 281 158 l 396 158 l 396 0 l 354 -160 l 294 -160 z "
    },
    "‚": {
      "ha": 293,
      "x_min": 89,
      "x_max": 204,
      "o": "m 103 -160 l 131 0 l 89 0 l 89 158 l 204 158 l 204 0 l 163 -160 l 103 -160 z "
    },
    "“": {
      "ha": 479,
      "x_min": 86,
      "x_max": 393,
      "o": "m 188 1014 l 160 854 l 201 854 l 201 696 l 86 696 l 86 854 l 128 1014 l 188 1014 m 379 1014 l 351 854 l 393 854 l 393 696 l 278 696 l 278 854 l 319 1014 l 379 1014 z "
    },
    "‘": {
      "ha": 288,
      "x_min": 86,
      "x_max": 201,
      "o": "m 188 1014 l 160 854 l 201 854 l 201 696 l 86 696 l 86 854 l 128 1014 l 188 1014 z "
    },
    "”": {
      "ha": 469,
      "x_min": 85,
      "x_max": 392,
      "o": "m 99 696 l 126 856 l 85 856 l 85 1014 l 200 1014 l 200 856 l 158 696 l 99 696 m 290 696 l 318 856 l 276 856 l 276 1014 l 392 1014 l 392 856 l 350 696 l 290 696 z "
    },
    "’": {
      "ha": 278,
      "x_min": 85,
      "x_max": 200,
      "o": "m 99 696 l 126 856 l 85 856 l 85 1014 l 200 1014 l 200 856 l 158 696 l 99 696 z "
    },
    "'": {
      "ha": 292,
      "x_min": 93,
      "x_max": 199,
      "o": "m 93 696 l 93 997 l 199 997 l 199 696 l 93 696 z "
    },
    "r": {
      "ha": 504,
      "x_min": 99,
      "x_max": 482,
      "o": "m 482 618 q 320 571 390 615 q 221 447 250 526 l 221 0 l 99 0 l 99 725 l 213 725 l 213 557 q 311 678 250 632 q 442 731 372 725 q 465 731 456 731 q 482 729 475 731 l 482 618 z "
    },
    "ŕ": {
      "ha": 504,
      "x_min": 99,
      "x_max": 482,
      "o": "m 314 846 l 233 874 l 314 1014 l 436 1014 l 314 846 m 482 618 q 320 571 390 615 q 221 447 250 526 l 221 0 l 99 0 l 99 725 l 213 725 l 213 557 q 311 678 250 632 q 442 731 372 725 q 465 731 456 731 q 482 729 475 731 l 482 618 z "
    },
    "ř": {
      "ha": 504,
      "x_min": 99,
      "x_max": 482,
      "o": "m 175 1014 l 293 926 l 411 1014 l 478 981 l 338 856 l 249 856 l 108 981 l 175 1014 m 482 618 q 320 571 390 615 q 221 447 250 526 l 221 0 l 99 0 l 99 725 l 213 725 l 213 557 q 311 678 250 632 q 442 731 372 725 q 465 731 456 731 q 482 729 475 731 l 482 618 z "
    },
    "ŗ": {
      "ha": 504,
      "x_min": 97,
      "x_max": 482,
      "o": "m 104 -296 l 132 -183 l 97 -183 l 97 -67 l 206 -67 l 206 -183 l 164 -296 l 104 -296 m 482 618 q 320 571 390 615 q 221 447 250 526 l 221 0 l 99 0 l 99 725 l 213 725 l 213 557 q 311 678 250 632 q 442 731 372 725 q 465 731 456 731 q 482 729 475 731 l 482 618 z "
    },
    "®": {
      "ha": 1161,
      "x_min": 65,
      "x_max": 1096,
      "o": "m 579 -10 q 374 28 468 -10 q 212 134 281 67 q 104 293 143 201 q 65 493 65 385 q 104 692 65 600 q 212 850 143 783 q 374 955 281 917 q 579 993 468 993 q 785 955 690 993 q 949 850 879 917 q 1057 692 1018 783 q 1096 493 1096 600 q 1057 293 1096 385 q 949 134 1018 201 q 785 28 879 67 q 579 -10 690 -10 m 579 42 q 760 74 676 42 q 905 167 843 107 q 1002 309 967 226 q 1038 492 1038 392 q 1003 669 1038 588 q 907 812 968 751 q 762 906 846 872 q 579 940 678 940 q 397 906 481 940 q 252 812 313 872 q 158 669 192 751 q 124 493 124 588 q 158 315 124 397 q 252 172 192 232 q 397 76 313 111 q 579 42 481 42 m 364 804 l 631 804 q 707 787 672 804 q 767 741 742 769 q 806 676 792 713 q 819 604 819 640 q 783 487 819 539 q 686 419 746 435 l 838 181 l 736 181 l 594 406 l 454 406 l 454 181 l 364 181 l 364 804 m 626 485 q 703 518 676 485 q 731 604 731 551 q 699 690 731 657 q 622 722 668 722 l 454 722 l 454 485 l 626 485 z "
    },
    "s": {
      "ha": 686,
      "x_min": 35,
      "x_max": 640,
      "o": "m 353 -14 q 181 13 265 -14 q 35 92 96 40 l 88 174 q 215 101 151 125 q 350 76 279 76 q 476 108 429 76 q 522 196 522 139 q 510 241 522 222 q 472 274 497 260 q 408 299 447 288 q 318 322 369 310 q 206 354 253 339 q 128 390 158 369 q 83 440 97 411 q 69 513 69 469 q 91 609 69 567 q 150 680 113 651 q 238 723 188 708 q 347 738 289 738 q 500 711 429 738 q 619 642 571 685 l 564 568 q 461 628 518 608 q 344 649 404 649 q 231 620 278 649 q 185 529 185 592 q 194 488 185 504 q 224 458 203 471 q 277 436 244 446 q 356 415 310 426 q 481 381 428 399 q 570 340 535 364 q 623 285 606 317 q 640 207 640 253 q 563 46 640 106 q 353 -14 485 -14 z "
    },
    "ﬆ": {
      "ha": 1150,
      "x_min": 43,
      "x_max": 1135,
      "o": "m 1135 36 q 1105 23 1124 31 q 1063 8 1086 15 q 1014 -5 1040 0 q 961 -10 988 -10 q 844 27 892 -10 q 796 142 796 64 l 796 629 l 697 629 l 697 725 l 796 725 q 792 845 796 797 q 774 921 788 893 q 735 960 760 949 q 672 972 711 972 q 602 962 631 972 q 556 933 574 951 q 531 891 539 915 q 522 839 522 867 q 532 770 522 803 q 554 711 542 738 q 578 667 567 685 q 594 643 590 649 l 540 569 q 439 632 492 615 q 338 649 386 649 q 276 642 306 649 q 224 623 247 636 q 186 587 200 610 q 172 531 172 564 q 190 472 172 494 q 234 438 207 450 q 294 419 261 425 q 357 408 326 413 q 463 388 413 400 q 552 354 514 376 q 613 297 590 332 q 635 207 635 261 q 611 107 635 149 q 548 38 588 65 q 457 -1 508 11 q 351 -14 406 -14 q 180 16 263 -14 q 43 89 97 46 l 93 172 q 350 76 221 76 q 412 83 381 76 q 467 103 443 89 q 507 140 492 117 q 522 194 522 163 q 503 253 522 232 q 456 286 485 274 q 391 304 426 299 q 322 315 356 310 q 218 338 265 325 q 136 372 171 350 q 82 428 101 394 q 63 513 63 461 q 86 614 63 571 q 148 684 110 657 q 234 724 186 711 q 331 738 282 738 q 422 728 374 738 q 506 694 469 718 q 476 763 488 731 q 464 840 464 794 q 476 915 464 879 q 517 976 489 950 q 589 1018 544 1003 q 699 1033 633 1033 q 820 1014 776 1033 q 886 956 864 994 q 913 859 908 917 q 918 725 918 801 l 1079 725 l 1079 629 l 918 629 l 918 179 q 942 121 918 139 q 1001 103 967 103 q 1065 115 1035 103 q 1107 133 1096 126 l 1135 36 z "
    },
    "ś": {
      "ha": 686,
      "x_min": 35,
      "x_max": 640,
      "o": "m 365 846 l 285 874 l 365 1014 l 488 1014 l 365 846 m 353 -14 q 181 13 265 -14 q 35 92 96 40 l 88 174 q 215 101 151 125 q 350 76 279 76 q 476 108 429 76 q 522 196 522 139 q 510 241 522 222 q 472 274 497 260 q 408 299 447 288 q 318 322 369 310 q 206 354 253 339 q 128 390 158 369 q 83 440 97 411 q 69 513 69 469 q 91 609 69 567 q 150 680 113 651 q 238 723 188 708 q 347 738 289 738 q 500 711 429 738 q 619 642 571 685 l 564 568 q 461 628 518 608 q 344 649 404 649 q 231 620 278 649 q 185 529 185 592 q 194 488 185 504 q 224 458 203 471 q 277 436 244 446 q 356 415 310 426 q 481 381 428 399 q 570 340 535 364 q 623 285 606 317 q 640 207 640 253 q 563 46 640 106 q 353 -14 485 -14 z "
    },
    "š": {
      "ha": 686,
      "x_min": 35,
      "x_max": 640,
      "o": "m 226 1014 l 344 926 l 463 1014 l 529 981 l 389 856 l 300 856 l 160 981 l 226 1014 m 353 -14 q 181 13 265 -14 q 35 92 96 40 l 88 174 q 215 101 151 125 q 350 76 279 76 q 476 108 429 76 q 522 196 522 139 q 510 241 522 222 q 472 274 497 260 q 408 299 447 288 q 318 322 369 310 q 206 354 253 339 q 128 390 158 369 q 83 440 97 411 q 69 513 69 469 q 91 609 69 567 q 150 680 113 651 q 238 723 188 708 q 347 738 289 738 q 500 711 429 738 q 619 642 571 685 l 564 568 q 461 628 518 608 q 344 649 404 649 q 231 620 278 649 q 185 529 185 592 q 194 488 185 504 q 224 458 203 471 q 277 436 244 446 q 356 415 310 426 q 481 381 428 399 q 570 340 535 364 q 623 285 606 317 q 640 207 640 253 q 563 46 640 106 q 353 -14 485 -14 z "
    },
    "ə": {
      "ha": 821,
      "x_min": 38,
      "x_max": 771,
      "o": "m 406 -14 q 256 16 324 -14 q 140 97 189 46 q 65 217 92 149 q 38 361 38 285 q 38 383 38 369 q 40 403 39 396 l 642 403 q 617 501 638 457 q 563 578 596 546 q 487 627 529 610 q 397 644 444 644 q 332 635 364 644 q 272 611 300 626 q 223 574 244 596 q 190 525 201 551 l 85 554 q 134 627 103 593 q 206 685 165 661 q 297 724 247 710 q 403 738 347 738 q 551 708 483 738 q 668 626 619 678 q 744 505 717 574 q 771 358 771 436 q 744 215 771 282 q 670 97 718 147 q 555 16 622 46 q 406 -14 488 -14 m 407 78 q 497 96 456 78 q 570 147 539 114 q 621 224 601 179 q 644 322 640 269 l 156 322 q 181 223 160 268 q 237 146 203 178 q 315 96 271 114 q 407 78 358 78 z "
    },
    "ŝ": {
      "ha": 686,
      "x_min": 35,
      "x_max": 640,
      "o": "m 160 889 l 300 1014 l 389 1014 l 529 889 l 463 856 l 344 943 l 226 856 l 160 889 m 353 -14 q 181 13 265 -14 q 35 92 96 40 l 88 174 q 215 101 151 125 q 350 76 279 76 q 476 108 429 76 q 522 196 522 139 q 510 241 522 222 q 472 274 497 260 q 408 299 447 288 q 318 322 369 310 q 206 354 253 339 q 128 390 158 369 q 83 440 97 411 q 69 513 69 469 q 91 609 69 567 q 150 680 113 651 q 238 723 188 708 q 347 738 289 738 q 500 711 429 738 q 619 642 571 685 l 564 568 q 461 628 518 608 q 344 649 404 649 q 231 620 278 649 q 185 529 185 592 q 194 488 185 504 q 224 458 203 471 q 277 436 244 446 q 356 415 310 426 q 481 381 428 399 q 570 340 535 364 q 623 285 606 317 q 640 207 640 253 q 563 46 640 106 q 353 -14 485 -14 z "
    },
    "§": {
      "ha": 718,
      "x_min": 65,
      "x_max": 657,
      "o": "m 597 279 q 657 135 657 239 q 629 19 657 68 q 559 -60 601 -29 q 466 -107 517 -92 q 368 -122 415 -122 q 274 -110 318 -122 q 195 -78 231 -97 q 132 -35 160 -58 q 85 10 104 -11 l 164 85 q 260 16 213 38 q 364 -6 308 -6 q 424 3 394 -6 q 478 30 454 13 q 516 73 501 47 q 531 131 531 99 q 517 187 531 165 q 480 219 503 208 q 429 235 457 231 q 375 242 401 240 q 262 262 313 246 q 175 307 211 278 q 119 378 139 336 q 99 474 99 419 q 109 542 99 513 q 132 588 119 571 q 85 650 106 608 q 65 747 65 692 q 89 845 65 800 q 151 923 113 890 q 239 974 189 956 q 343 993 289 993 q 440 980 397 993 q 515 946 482 967 q 571 899 547 925 q 611 849 594 874 l 517 804 q 446 865 493 847 q 350 883 399 883 q 290 874 318 883 q 238 847 261 865 q 202 804 215 829 q 189 749 189 779 q 201 689 189 713 q 235 651 214 665 q 287 630 257 636 q 351 624 317 624 q 453 612 401 624 q 544 574 504 600 q 610 506 585 547 q 636 403 636 464 q 624 330 636 363 q 597 279 613 297 m 218 458 q 248 375 218 400 q 320 340 278 350 q 408 327 363 329 q 483 313 453 325 q 510 351 500 326 q 519 400 519 375 q 503 459 519 435 q 464 497 488 483 q 411 517 440 511 q 356 524 382 524 q 249 542 292 524 q 226 505 235 528 q 218 458 218 482 z "
    },
    ";": {
      "ha": 307,
      "x_min": 96,
      "x_max": 211,
      "o": "m 96 564 l 96 719 l 197 719 l 197 564 l 96 564 m 110 -112 l 138 11 l 96 11 l 96 156 l 211 156 l 211 11 l 169 -112 l 110 -112 z "
    },
    "⅞": {
      "ha": 1214,
      "x_min": 57,
      "x_max": 1164,
      "o": "m 1164 160 q 1145 92 1164 122 q 1094 40 1126 61 q 1021 6 1063 18 q 932 -7 979 -7 q 840 6 882 -7 q 768 42 799 19 q 720 97 738 65 q 703 163 703 128 q 713 211 703 189 q 741 251 724 233 q 781 281 758 268 q 828 303 804 294 q 756 346 788 318 q 725 417 725 374 q 744 478 725 450 q 792 524 763 506 q 858 553 821 543 q 933 564 896 564 q 1008 553 971 564 q 1075 524 1046 543 q 1123 478 1104 506 q 1142 418 1142 451 q 1112 347 1142 376 q 1038 303 1082 318 q 1128 248 1092 283 q 1164 160 1164 213 m 1086 168 q 1072 210 1086 192 q 1037 242 1058 229 q 988 261 1015 254 q 933 268 960 268 q 876 261 904 268 q 828 240 849 254 q 794 208 807 226 q 781 167 781 189 q 794 125 781 143 q 831 94 808 107 q 880 76 853 82 q 935 69 907 69 q 990 76 963 69 q 1038 97 1017 83 q 1073 128 1060 110 q 1086 168 1086 146 m 803 410 q 815 376 803 390 q 845 351 826 361 q 887 336 864 342 q 933 331 910 331 q 979 336 956 331 q 1022 352 1003 342 q 1053 377 1042 363 q 1065 411 1065 392 q 1054 444 1065 429 q 1024 469 1043 458 q 982 485 1006 479 q 933 490 958 490 q 842 469 881 490 q 803 410 803 447 m 106 46 l 494 514 l 867 993 l 926 942 l 542 476 l 164 -7 l 106 46 m 399 938 l 57 938 l 57 1014 l 521 1014 l 189 451 l 101 451 l 399 938 z "
    },
    "⁷": {
      "ha": 507,
      "x_min": 35,
      "x_max": 499,
      "o": "m 376 1049 l 35 1049 l 35 1125 l 499 1125 l 167 563 l 79 563 l 376 1049 z "
    },
    "₇": {
      "ha": 507,
      "x_min": 35,
      "x_max": 499,
      "o": "m 378 376 l 35 376 l 35 453 l 499 453 l 167 -111 l 79 -111 l 378 376 z "
    },
    "₆": {
      "ha": 569,
      "x_min": 54,
      "x_max": 526,
      "o": "m 526 76 q 508 1 526 36 q 458 -61 490 -35 q 383 -103 426 -87 q 290 -118 340 -118 q 119 -53 185 -118 q 54 131 54 13 q 122 375 54 293 q 301 457 189 457 q 416 432 364 457 q 496 361 468 407 l 450 310 q 389 365 431 344 q 299 385 347 385 q 174 333 221 385 q 126 185 128 281 q 195 244 147 222 q 296 265 243 265 q 388 251 346 265 q 460 210 429 236 q 509 150 492 185 q 526 76 526 115 m 293 -49 q 355 -39 326 -49 q 406 -12 383 -29 q 440 28 428 6 q 453 75 453 50 q 440 123 453 100 q 406 163 428 146 q 354 189 383 179 q 292 199 325 199 q 229 189 258 199 q 178 163 200 179 q 143 124 156 146 q 131 76 131 101 q 144 28 131 51 q 179 -12 157 6 q 231 -39 201 -29 q 293 -49 260 -49 z "
    },
    "⁶": {
      "ha": 568,
      "x_min": 53,
      "x_max": 525,
      "o": "m 525 744 q 507 667 525 703 q 457 606 489 632 q 382 564 425 579 q 289 549 339 549 q 118 614 183 549 q 53 797 53 679 q 120 1043 53 961 q 300 1125 188 1125 q 415 1100 363 1125 q 494 1029 467 1075 l 449 978 q 388 1032 429 1011 q 297 1053 346 1053 q 173 1001 219 1053 q 125 853 126 949 q 194 912 146 890 q 294 933 242 933 q 386 919 344 933 q 459 878 428 904 q 508 818 490 853 q 525 744 525 783 m 292 619 q 353 629 325 619 q 404 656 382 639 q 439 696 426 674 q 451 743 451 718 q 439 791 451 768 q 404 831 426 814 q 353 857 382 847 q 290 867 324 867 q 228 857 257 867 q 176 831 199 847 q 142 792 154 814 q 129 744 129 769 q 142 697 129 719 q 178 656 156 674 q 229 629 200 639 q 292 619 258 619 z "
    },
    "Æ": {
      "ha": 1335,
      "x_min": -35,
      "x_max": 1285,
      "o": "m 594 986 l 1272 986 l 1272 875 l 751 875 l 751 558 l 1197 558 l 1197 447 l 751 447 l 751 111 l 1285 111 l 1285 0 l 628 0 l 628 289 l 282 289 l 101 0 l -35 0 l 594 986 m 619 400 l 619 840 l 338 400 l 619 400 z "
    },
    "£": {
      "ha": 711,
      "x_min": 74,
      "x_max": 656,
      "o": "m 74 521 l 194 521 q 165 578 181 550 q 137 633 150 606 q 115 691 124 661 q 107 753 107 721 q 128 847 107 803 q 184 923 149 890 q 267 974 219 956 q 369 993 315 993 q 518 954 449 993 q 632 847 588 915 l 564 772 q 476 859 531 826 q 367 892 422 892 q 308 880 335 892 q 262 849 282 868 q 231 801 242 829 q 219 743 219 774 q 228 688 219 715 q 251 634 238 661 q 280 579 264 607 q 310 521 296 551 l 558 521 l 558 426 l 340 426 q 344 397 343 411 q 346 367 346 382 q 315 238 346 299 q 210 96 285 176 q 313 110 261 110 q 413 97 368 110 q 507 85 458 85 q 562 91 535 85 q 625 110 589 97 l 656 17 q 580 -11 619 -1 q 501 -21 540 -21 q 441 -15 469 -21 q 383 -3 413 -10 q 324 8 354 3 q 263 14 294 14 q 185 7 228 14 q 104 -11 142 0 l 74 78 q 201 228 163 163 q 239 361 239 293 q 231 426 239 394 l 74 426 l 74 521 z "
    },
    "t": {
      "ha": 489,
      "x_min": 35,
      "x_max": 474,
      "o": "m 474 36 q 444 23 463 31 q 403 8 426 15 q 353 -5 381 0 q 297 -10 326 -10 q 182 27 231 -10 q 133 142 133 64 l 133 629 l 35 629 l 35 725 l 133 725 l 133 967 l 256 967 l 256 725 l 418 725 l 418 629 l 256 629 l 256 179 q 282 121 258 139 q 338 103 306 103 q 403 115 374 103 q 444 133 433 126 l 474 36 z "
    },
    "ŧ": {
      "ha": 490,
      "x_min": 36,
      "x_max": 475,
      "o": "m 475 36 q 446 23 464 31 q 405 8 428 15 q 355 -5 382 0 q 299 -10 328 -10 q 183 27 232 -10 q 135 142 135 64 l 135 408 l 36 408 l 36 486 l 135 486 l 135 629 l 36 629 l 36 725 l 135 725 l 135 967 l 257 967 l 257 725 l 419 725 l 419 629 l 257 629 l 257 486 l 419 486 l 419 408 l 257 408 l 257 179 q 283 121 260 139 q 339 103 307 103 q 405 115 375 103 q 446 133 435 126 l 475 36 z "
    },
    "ť": {
      "ha": 489,
      "x_min": 35,
      "x_max": 542,
      "o": "m 419 846 l 339 874 l 419 1014 l 542 1014 l 419 846 m 474 36 q 444 23 463 31 q 403 8 426 15 q 353 -5 381 0 q 297 -10 326 -10 q 182 27 231 -10 q 133 142 133 64 l 133 629 l 35 629 l 35 725 l 133 725 l 133 967 l 256 967 l 256 725 l 418 725 l 418 629 l 256 629 l 256 179 q 282 121 258 139 q 338 103 306 103 q 403 115 374 103 q 444 133 433 126 l 474 36 z "
    },
    "þ": {
      "ha": 838,
      "x_min": 99,
      "x_max": 789,
      "o": "m 789 357 q 760 213 788 282 q 683 90 732 143 q 570 6 635 38 q 431 -25 506 -25 q 304 8 358 -25 q 224 83 250 40 l 224 -296 l 99 -296 l 99 986 l 224 986 l 224 624 q 309 706 257 671 q 443 742 361 742 q 588 708 524 742 q 696 618 651 674 q 765 494 740 563 q 789 357 789 425 m 664 358 q 648 462 664 413 q 602 549 632 511 q 530 608 572 586 q 436 631 488 631 q 367 618 399 631 q 308 585 335 606 q 260 536 282 564 q 224 478 239 508 l 224 240 q 243 183 224 211 q 293 134 263 156 q 359 99 324 113 q 428 86 394 86 q 523 109 479 86 q 598 169 567 132 q 647 256 629 207 q 664 358 664 306 z "
    },
    "⅜": {
      "ha": 1239,
      "x_min": 57,
      "x_max": 1190,
      "o": "m 276 436 q 130 468 189 436 q 57 556 71 500 l 101 608 q 116 577 103 593 q 152 547 129 561 q 206 523 175 532 q 275 514 238 514 q 385 538 340 514 q 431 604 431 563 q 375 674 431 650 q 224 699 319 699 l 192 699 l 192 769 l 224 769 q 361 790 311 769 q 411 856 411 811 q 369 921 411 897 q 272 944 326 944 q 175 924 215 944 q 113 869 135 903 l 61 929 q 147 992 89 969 q 272 1015 206 1015 q 360 1003 319 1015 q 430 971 400 992 q 476 922 460 950 q 493 860 493 893 q 460 781 493 811 q 365 738 428 750 q 470 688 432 728 q 508 593 508 647 q 490 526 508 556 q 438 476 471 496 q 364 447 406 457 q 276 436 322 436 m 1190 160 q 1172 92 1190 122 q 1121 40 1153 61 q 1047 6 1089 18 q 958 -7 1006 -7 q 867 6 908 -7 q 794 42 825 19 q 747 97 764 65 q 729 163 729 128 q 740 211 729 189 q 767 251 750 233 q 808 281 785 268 q 854 303 831 294 q 783 346 814 318 q 751 417 751 374 q 770 478 751 450 q 818 524 789 506 q 885 553 847 543 q 960 564 922 564 q 1035 553 997 564 q 1101 524 1072 543 q 1149 478 1131 506 q 1168 418 1168 451 q 1138 347 1168 376 q 1064 303 1108 318 q 1154 248 1118 283 q 1190 160 1190 213 m 1113 168 q 1099 210 1113 192 q 1063 242 1085 229 q 1014 261 1042 254 q 960 268 986 268 q 903 261 931 268 q 854 240 875 254 q 820 208 833 226 q 807 167 807 189 q 821 125 807 143 q 857 94 835 107 q 906 76 879 82 q 961 69 933 69 q 1016 76 989 69 q 1065 97 1043 83 q 1099 128 1086 110 q 1113 168 1113 146 m 829 410 q 841 376 829 390 q 872 351 853 361 q 913 336 890 342 q 960 331 936 331 q 1006 336 982 331 q 1049 352 1029 342 q 1080 377 1068 363 q 1092 411 1092 392 q 1081 444 1092 429 q 1051 469 1069 458 q 1008 485 1032 479 q 960 490 985 490 q 868 469 907 490 q 829 410 829 447 m 208 46 l 597 514 l 969 993 l 1029 942 l 644 476 l 267 -7 l 208 46 z "
    },
    "³": {
      "ha": 547,
      "x_min": 44,
      "x_max": 496,
      "o": "m 264 547 q 117 579 176 547 q 44 667 58 611 l 89 719 q 103 688 90 704 q 140 658 117 672 q 194 634 163 643 q 263 625 225 625 q 373 649 328 625 q 418 715 418 674 q 363 785 418 761 q 211 810 307 810 l 179 810 l 179 881 l 211 881 q 349 901 299 881 q 399 967 399 922 q 356 1032 399 1008 q 260 1056 314 1056 q 163 1035 203 1056 q 100 981 122 1014 l 49 1040 q 135 1103 76 1081 q 260 1126 193 1126 q 347 1115 307 1126 q 417 1082 388 1103 q 464 1033 447 1061 q 481 971 481 1004 q 448 892 481 922 q 353 849 415 861 q 458 799 419 839 q 496 704 496 758 q 477 637 496 667 q 426 588 458 607 q 351 558 393 568 q 264 547 310 547 z "
    },
    "¾": {
      "ha": 1203,
      "x_min": 56,
      "x_max": 1153,
      "o": "m 275 436 q 128 468 188 436 q 56 556 69 500 l 100 608 q 115 577 101 593 q 151 547 128 561 q 205 523 174 532 q 274 514 236 514 q 384 538 339 514 q 429 604 429 563 q 374 674 429 650 q 222 699 318 699 l 190 699 l 190 769 l 222 769 q 360 790 310 769 q 410 856 410 811 q 367 921 410 897 q 271 944 325 944 q 174 924 214 944 q 111 869 133 903 l 60 929 q 146 992 88 969 q 271 1015 204 1015 q 358 1003 318 1015 q 428 971 399 992 q 475 922 458 950 q 492 860 492 893 q 459 781 492 811 q 364 738 426 750 q 469 688 431 728 q 507 593 507 647 q 488 526 507 556 q 437 476 469 496 q 363 447 404 457 q 275 436 321 436 m 994 0 l 994 139 l 681 139 l 681 213 l 1018 564 l 1071 564 l 1071 214 l 1153 214 l 1153 139 l 1071 139 l 1071 0 l 994 0 m 760 214 l 997 214 l 997 464 l 760 214 m 247 46 l 636 514 l 1008 993 l 1068 942 l 683 476 l 306 -7 l 247 46 z "
    },
    "™": {
      "ha": 1056,
      "x_min": 88,
      "x_max": 950,
      "o": "m 435 906 l 303 906 l 303 583 l 219 583 l 219 906 l 88 906 l 88 989 l 435 989 l 435 906 m 831 986 l 950 986 l 950 583 l 867 583 l 867 872 l 758 642 l 690 642 l 582 872 l 582 583 l 499 583 l 499 986 l 617 986 l 724 739 l 831 986 z "
    },
    "²": {
      "ha": 550,
      "x_min": 47,
      "x_max": 499,
      "o": "m 47 556 q 58 651 47 610 q 90 722 68 692 q 144 776 111 753 q 224 817 178 799 q 290 841 256 829 q 351 869 324 853 q 395 906 378 885 q 413 957 413 926 q 378 1024 413 997 q 278 1051 344 1051 q 168 1026 211 1051 q 103 978 125 1001 l 53 1032 q 78 1058 60 1042 q 126 1089 96 1074 q 197 1115 156 1104 q 289 1126 238 1126 q 446 1078 393 1126 q 499 956 499 1031 q 479 881 499 911 q 431 831 460 851 q 368 799 401 811 q 307 778 335 786 q 237 746 264 764 q 194 708 210 728 q 174 669 179 689 q 168 631 168 649 l 489 631 l 489 556 l 47 556 z "
    },
    "⅔": {
      "ha": 1249,
      "x_min": 58,
      "x_max": 1200,
      "o": "m 968 -7 q 822 24 881 -7 q 749 113 763 56 l 793 164 q 808 133 794 149 q 844 102 821 117 q 898 78 867 88 q 967 69 929 69 q 1077 94 1032 69 q 1122 160 1122 118 q 1067 231 1122 206 q 915 256 1011 256 l 883 256 l 883 325 l 915 325 q 1053 346 1003 325 q 1103 411 1103 367 q 1060 476 1103 453 q 964 500 1018 500 q 867 479 907 500 q 804 425 826 458 l 753 485 q 839 548 781 525 q 964 571 897 571 q 1051 559 1011 571 q 1122 526 1092 547 q 1168 478 1151 506 q 1185 417 1185 450 q 1152 337 1185 368 q 1057 293 1119 306 q 1162 243 1124 283 q 1200 149 1200 203 q 1181 82 1200 111 q 1130 33 1163 53 q 1056 3 1097 13 q 968 -7 1014 -7 m 58 444 q 68 540 58 499 q 99 611 78 581 q 151 665 119 642 q 228 706 183 688 q 291 730 258 718 q 351 758 324 742 q 394 794 378 774 q 411 846 411 815 q 378 913 411 886 q 281 940 346 940 q 222 933 249 940 q 175 915 196 926 q 138 891 154 904 q 111 867 122 878 l 64 921 q 88 947 69 931 q 134 978 106 963 q 202 1004 163 993 q 292 1015 242 1015 q 442 967 392 1015 q 493 844 493 919 q 474 770 493 800 q 428 720 456 740 q 367 688 400 700 q 308 667 335 675 q 241 635 267 653 q 201 597 215 617 q 181 558 186 578 q 175 519 175 538 l 485 519 l 485 444 l 58 444 m 226 46 l 615 514 l 988 993 l 1047 942 l 663 476 l 285 -7 l 226 46 z "
    },
    "u": {
      "ha": 835,
      "x_min": 92,
      "x_max": 768,
      "o": "m 322 -14 q 150 63 208 -14 q 92 290 92 139 l 92 725 l 214 725 l 214 314 q 368 92 214 92 q 509 140 443 92 q 607 271 575 188 l 607 725 l 729 725 l 729 150 q 768 106 729 107 l 768 0 q 735 -3 747 -3 q 713 -4 724 -4 q 652 17 676 -4 q 626 71 628 39 l 624 156 q 496 30 575 74 q 322 -14 417 -14 z "
    },
    "ú": {
      "ha": 835,
      "x_min": 92,
      "x_max": 768,
      "o": "m 429 846 l 349 874 l 429 1014 l 551 1014 l 429 846 m 322 -14 q 150 63 208 -14 q 92 290 92 139 l 92 725 l 214 725 l 214 314 q 368 92 214 92 q 509 140 443 92 q 607 271 575 188 l 607 725 l 729 725 l 729 150 q 768 106 729 107 l 768 0 q 735 -3 747 -3 q 713 -4 724 -4 q 652 17 676 -4 q 626 71 628 39 l 624 156 q 496 30 575 74 q 322 -14 417 -14 z "
    },
    "ŭ": {
      "ha": 835,
      "x_min": 92,
      "x_max": 768,
      "o": "m 322 -14 q 150 63 208 -14 q 92 290 92 139 l 92 725 l 214 725 l 214 314 q 368 92 214 92 q 509 140 443 92 q 607 271 575 188 l 607 725 l 729 725 l 729 150 q 768 106 729 107 l 768 0 q 735 -3 747 -3 q 713 -4 724 -4 q 652 17 676 -4 q 626 71 628 39 l 624 156 q 496 30 575 74 q 322 -14 417 -14 m 408 919 q 462 947 439 919 q 489 1014 485 974 l 558 1014 q 547 953 558 981 q 515 904 535 925 q 467 872 494 883 q 408 860 440 860 q 349 872 376 860 q 302 904 322 883 q 270 953 282 925 q 258 1014 258 981 l 329 1014 q 353 948 329 976 q 408 919 376 919 z "
    },
    "û": {
      "ha": 835,
      "x_min": 92,
      "x_max": 768,
      "o": "m 224 889 l 364 1014 l 453 1014 l 593 889 l 526 856 l 408 943 l 290 856 l 224 889 m 322 -14 q 150 63 208 -14 q 92 290 92 139 l 92 725 l 214 725 l 214 314 q 368 92 214 92 q 509 140 443 92 q 607 271 575 188 l 607 725 l 729 725 l 729 150 q 768 106 729 107 l 768 0 q 735 -3 747 -3 q 713 -4 724 -4 q 652 17 676 -4 q 626 71 628 39 l 624 156 q 496 30 575 74 q 322 -14 417 -14 z "
    },
    "ü": {
      "ha": 835,
      "x_min": 92,
      "x_max": 768,
      "o": "m 244 867 l 244 1008 l 347 1008 l 347 867 l 244 867 m 469 867 l 469 1008 l 572 1008 l 572 867 l 469 867 m 322 -14 q 150 63 208 -14 q 92 290 92 139 l 92 725 l 214 725 l 214 314 q 368 92 214 92 q 509 140 443 92 q 607 271 575 188 l 607 725 l 729 725 l 729 150 q 768 106 729 107 l 768 0 q 735 -3 747 -3 q 713 -4 724 -4 q 652 17 676 -4 q 626 71 628 39 l 624 156 q 496 30 575 74 q 322 -14 417 -14 z "
    },
    "ù": {
      "ha": 835,
      "x_min": 92,
      "x_max": 768,
      "o": "m 322 -14 q 150 63 208 -14 q 92 290 92 139 l 92 725 l 214 725 l 214 314 q 368 92 214 92 q 509 140 443 92 q 607 271 575 188 l 607 725 l 729 725 l 729 150 q 768 106 729 107 l 768 0 q 735 -3 747 -3 q 713 -4 724 -4 q 652 17 676 -4 q 626 71 628 39 l 624 156 q 496 30 575 74 q 322 -14 417 -14 m 265 1014 l 386 1014 l 468 874 l 389 846 l 265 1014 z "
    },
    "ű": {
      "ha": 835,
      "x_min": 92,
      "x_max": 768,
      "o": "m 322 -14 q 150 63 208 -14 q 92 290 92 139 l 92 725 l 214 725 l 214 314 q 368 92 214 92 q 509 140 443 92 q 607 271 575 188 l 607 725 l 729 725 l 729 150 q 768 106 729 107 l 768 0 q 735 -3 747 -3 q 713 -4 724 -4 q 652 17 676 -4 q 626 71 628 39 l 624 156 q 496 30 575 74 q 322 -14 417 -14 m 321 846 l 257 874 l 332 1014 l 438 1014 l 321 846 m 510 846 l 446 874 l 521 1014 l 626 1014 l 510 846 z "
    },
    "ū": {
      "ha": 835,
      "x_min": 92,
      "x_max": 768,
      "o": "m 322 -14 q 150 63 208 -14 q 92 290 92 139 l 92 725 l 214 725 l 214 314 q 368 92 214 92 q 509 140 443 92 q 607 271 575 188 l 607 725 l 729 725 l 729 150 q 768 106 729 107 l 768 0 q 735 -3 747 -3 q 713 -4 724 -4 q 652 17 676 -4 q 626 71 628 39 l 624 156 q 496 30 575 74 q 322 -14 417 -14 m 207 908 l 207 989 l 613 989 l 613 908 l 207 908 z "
    },
    "_": {
      "ha": 699,
      "x_min": 88,
      "x_max": 611,
      "o": "m 88 -111 l 88 0 l 611 0 l 611 -111 l 88 -111 z "
    },
    " ": {
      "ha": 351,
      "x_min": 0,
      "x_max": 0,
      "o": ""
    },
    "­": {
      "ha": 808,
      "x_min": 89,
      "x_max": 719,
      "o": "m 89 324 l 89 435 l 719 435 l 719 324 l 89 324 z "
    },
    "Ş": {
      "ha": 846,
      "x_min": 40,
      "x_max": 800,
      "o": "m 338 -175 q 390 -193 356 -185 q 460 -201 424 -201 q 518 -190 497 -201 q 539 -153 539 -179 q 519 -115 539 -125 q 468 -104 500 -104 q 407 -110 439 -104 q 357 -122 375 -117 l 417 -8 q 215 29 310 -6 q 40 129 119 64 l 100 235 q 158 188 122 211 q 238 145 193 164 q 335 115 283 126 q 444 103 388 103 q 608 140 550 103 q 667 253 667 178 q 648 323 667 294 q 593 372 629 351 q 503 409 557 393 q 382 442 450 425 q 250 481 307 460 q 155 531 193 501 q 97 601 117 560 q 78 701 78 643 q 104 826 78 772 q 178 918 131 881 q 290 974 225 956 q 432 993 356 993 q 613 963 532 993 q 756 881 693 932 l 697 779 q 653 817 681 799 q 590 849 625 835 q 515 873 556 864 q 429 882 474 882 q 260 839 314 882 q 207 721 207 796 q 222 654 207 681 q 270 609 238 628 q 351 576 303 590 q 467 547 400 563 q 605 509 543 531 q 710 456 667 488 q 777 378 754 424 q 800 265 800 332 q 776 149 800 199 q 708 65 751 99 q 606 14 665 32 q 479 -8 547 -4 l 443 -67 q 468 -61 454 -62 q 493 -60 482 -60 q 572 -82 542 -60 q 603 -149 603 -104 q 564 -225 603 -197 q 450 -253 525 -253 q 373 -245 408 -253 q 310 -226 338 -237 l 338 -175 z "
    },
    "ş": {
      "ha": 686,
      "x_min": 35,
      "x_max": 640,
      "o": "m 244 -175 q 297 -193 263 -185 q 367 -201 331 -201 q 425 -190 404 -201 q 446 -153 446 -179 q 426 -115 446 -125 q 375 -104 407 -104 q 314 -110 346 -104 q 264 -122 282 -117 l 322 -12 q 166 19 242 -7 q 35 92 90 44 l 88 174 q 215 101 151 125 q 350 76 279 76 q 476 108 429 76 q 522 196 522 139 q 510 241 522 222 q 472 274 497 260 q 408 299 447 288 q 318 322 369 310 q 206 354 253 339 q 128 390 158 369 q 83 440 97 411 q 69 513 69 469 q 91 609 69 567 q 150 680 113 651 q 238 723 188 708 q 347 738 289 738 q 500 711 429 738 q 619 642 571 685 l 564 568 q 461 628 518 608 q 344 649 404 649 q 231 620 278 649 q 185 529 185 592 q 194 488 185 504 q 224 458 203 471 q 277 436 244 446 q 356 415 310 426 q 481 381 428 399 q 570 340 535 364 q 623 285 606 317 q 640 207 640 253 q 571 53 640 111 q 383 -12 501 -6 l 350 -67 q 375 -61 361 -62 q 400 -60 389 -60 q 479 -82 449 -60 q 510 -149 510 -104 q 471 -225 510 -197 q 357 -253 432 -253 q 280 -245 315 -253 q 217 -226 244 -237 l 244 -175 z "
    },
    "Ţ": {
      "ha": 851,
      "x_min": 22,
      "x_max": 828,
      "o": "m 319 -175 q 372 -193 338 -185 q 442 -201 406 -201 q 500 -190 479 -201 q 521 -153 521 -179 q 501 -115 521 -125 q 450 -104 482 -104 q 389 -110 421 -104 q 339 -122 357 -117 l 404 0 l 363 0 l 363 875 l 22 875 l 22 986 l 828 986 l 828 875 l 488 875 l 488 0 l 467 0 l 425 -67 q 450 -61 436 -62 q 475 -60 464 -60 q 554 -82 524 -60 q 585 -149 585 -104 q 546 -225 585 -197 q 432 -253 507 -253 q 355 -245 390 -253 q 292 -226 319 -237 l 319 -175 z "
    },
    "ţ": {
      "ha": 489,
      "x_min": 35,
      "x_max": 474,
      "o": "m 189 -175 q 241 -193 207 -185 q 311 -201 275 -201 q 369 -190 349 -201 q 390 -153 390 -179 q 371 -115 390 -125 q 319 -104 351 -104 q 258 -110 290 -104 q 208 -122 226 -117 l 268 -8 q 172 35 211 -1 q 133 142 133 71 l 133 629 l 35 629 l 35 725 l 133 725 l 133 967 l 256 967 l 256 725 l 418 725 l 418 629 l 256 629 l 256 179 q 282 121 258 139 q 338 103 306 103 q 403 115 374 103 q 444 133 433 126 l 474 36 q 417 13 454 26 q 332 -7 379 -1 l 294 -67 q 319 -61 306 -62 q 344 -60 333 -60 q 424 -82 393 -60 q 454 -149 454 -104 q 415 -225 454 -197 q 301 -253 376 -253 q 224 -245 260 -253 q 161 -226 189 -237 l 189 -175 z "
    },
    "Ș": {
      "ha": 846,
      "x_min": 40,
      "x_max": 800,
      "o": "m 393 -296 l 421 -183 l 386 -183 l 386 -67 l 494 -67 l 494 -183 l 453 -296 l 393 -296 m 697 779 q 653 817 681 799 q 590 849 625 835 q 515 873 556 864 q 429 882 474 882 q 260 839 314 882 q 207 721 207 796 q 222 654 207 681 q 270 609 238 628 q 351 576 303 590 q 467 547 400 563 q 605 509 543 531 q 710 456 667 488 q 777 378 754 424 q 800 265 800 332 q 772 142 800 194 q 697 56 744 90 q 583 6 649 22 q 442 -10 518 -10 q 226 26 328 -10 q 40 129 124 61 l 100 235 q 158 188 122 211 q 238 145 193 164 q 335 115 283 126 q 444 103 388 103 q 608 140 550 103 q 667 253 667 178 q 648 323 667 294 q 593 372 629 351 q 503 409 557 393 q 382 442 450 425 q 250 481 307 460 q 155 531 193 501 q 97 601 117 560 q 78 701 78 643 q 104 826 78 772 q 178 918 131 881 q 290 974 225 956 q 432 993 356 993 q 613 963 532 993 q 756 881 693 932 l 697 779 z "
    },
    "ș": {
      "ha": 686,
      "x_min": 35,
      "x_max": 640,
      "o": "m 300 -296 l 328 -183 l 293 -183 l 293 -67 l 401 -67 l 401 -183 l 360 -296 l 300 -296 m 353 -14 q 181 13 265 -14 q 35 92 96 40 l 88 174 q 215 101 151 125 q 350 76 279 76 q 476 108 429 76 q 522 196 522 139 q 510 241 522 222 q 472 274 497 260 q 408 299 447 288 q 318 322 369 310 q 206 354 253 339 q 128 390 158 369 q 83 440 97 411 q 69 513 69 469 q 91 609 69 567 q 150 680 113 651 q 238 723 188 708 q 347 738 289 738 q 500 711 429 738 q 619 642 571 685 l 564 568 q 461 628 518 608 q 344 649 404 649 q 231 620 278 649 q 185 529 185 592 q 194 488 185 504 q 224 458 203 471 q 277 436 244 446 q 356 415 310 426 q 481 381 428 399 q 570 340 535 364 q 623 285 606 317 q 640 207 640 253 q 563 46 640 106 q 353 -14 485 -14 z "
    },
    "Ț": {
      "ha": 853,
      "x_min": 24,
      "x_max": 829,
      "o": "m 379 -296 l 407 -183 l 372 -183 l 372 -67 l 481 -67 l 481 -183 l 439 -296 l 379 -296 m 829 875 l 489 875 l 489 0 l 364 0 l 364 875 l 24 875 l 24 986 l 829 986 l 829 875 z "
    },
    "ț": {
      "ha": 489,
      "x_min": 35,
      "x_max": 474,
      "o": "m 244 -296 l 272 -183 l 238 -183 l 238 -67 l 346 -67 l 346 -183 l 304 -296 l 244 -296 m 474 36 q 444 23 463 31 q 403 8 426 15 q 353 -5 381 0 q 297 -10 326 -10 q 182 27 231 -10 q 133 142 133 64 l 133 629 l 35 629 l 35 725 l 133 725 l 133 967 l 256 967 l 256 725 l 418 725 l 418 629 l 256 629 l 256 179 q 282 121 258 139 q 338 103 306 103 q 403 115 374 103 q 444 133 433 126 l 474 36 z "
    },
    "μ": {
      "ha": 843,
      "x_min": 99,
      "x_max": 776,
      "o": "m 99 725 l 221 725 l 221 314 q 378 92 221 92 q 450 104 414 92 q 517 140 486 117 q 574 196 549 163 q 615 271 599 229 l 615 725 l 738 725 l 738 150 q 776 106 738 107 l 776 0 q 743 -3 756 -3 q 719 -4 731 -4 q 656 22 681 -4 q 632 79 632 47 l 632 156 q 588 92 615 122 q 526 38 560 61 q 452 0 492 14 q 371 -14 413 -14 q 268 17 307 -14 q 214 93 229 49 l 214 -294 l 99 -294 l 99 725 z "
    },
    "∕": {
      "ha": 832,
      "x_min": -12,
      "x_max": 846,
      "o": "m -12 53 l 774 993 l 846 933 l 60 -7 l -12 53 z "
    },
    "∙": {
      "ha": 281,
      "x_min": 89,
      "x_max": 192,
      "o": "m 89 340 l 89 513 l 192 513 l 192 340 l 89 340 z "
    },
    "ų": {
      "ha": 835,
      "x_min": 92,
      "x_max": 768,
      "o": "m 322 -14 q 150 63 208 -14 q 92 290 92 139 l 92 725 l 214 725 l 214 314 q 368 92 214 92 q 509 140 443 92 q 607 271 575 188 l 607 725 l 729 725 l 729 150 q 768 106 729 107 l 768 0 q 681 -67 707 -37 q 654 -128 654 -97 q 731 -187 654 -179 l 700 -251 q 613 -212 642 -240 q 583 -144 583 -183 q 689 -1 583 -72 q 644 24 661 6 q 626 71 628 43 l 624 156 q 496 30 575 74 q 322 -14 417 -14 z "
    },
    "ů": {
      "ha": 835,
      "x_min": 92,
      "x_max": 768,
      "o": "m 296 918 q 328 988 296 963 q 408 1014 360 1014 q 490 988 458 1014 q 521 918 521 963 q 490 848 521 874 q 408 822 458 822 q 328 848 360 822 q 296 918 296 874 m 408 971 q 369 956 385 971 q 353 918 353 942 q 369 881 353 896 q 408 865 385 865 q 448 880 431 865 q 465 918 465 894 q 449 956 465 942 q 408 971 432 971 m 322 -14 q 150 63 208 -14 q 92 290 92 139 l 92 725 l 214 725 l 214 314 q 368 92 214 92 q 509 140 443 92 q 607 271 575 188 l 607 725 l 729 725 l 729 150 q 768 106 729 107 l 768 0 q 735 -3 747 -3 q 713 -4 724 -4 q 652 17 676 -4 q 626 71 628 39 l 624 156 q 496 30 575 74 q 322 -14 417 -14 z "
    },
    "ũ": {
      "ha": 835,
      "x_min": 92,
      "x_max": 768,
      "o": "m 322 -14 q 150 63 208 -14 q 92 290 92 139 l 92 725 l 214 725 l 214 314 q 368 92 214 92 q 509 140 443 92 q 607 271 575 188 l 607 725 l 729 725 l 729 150 q 768 106 729 107 l 768 0 q 735 -3 747 -3 q 713 -4 724 -4 q 652 17 676 -4 q 626 71 628 39 l 624 156 q 496 30 575 74 q 322 -14 417 -14 m 496 871 q 441 880 464 871 q 398 900 418 889 q 358 920 378 911 q 317 929 339 929 q 280 919 293 929 q 260 898 267 910 q 251 875 253 886 q 249 863 249 864 l 176 863 q 183 894 176 871 q 204 943 189 918 q 246 987 219 968 q 314 1006 272 1006 q 365 997 343 1006 q 408 976 388 988 q 448 955 428 964 q 493 946 468 946 q 535 956 519 946 q 558 978 550 965 q 569 1001 567 990 q 571 1014 571 1011 l 643 1014 q 637 983 643 1006 q 614 935 631 960 q 569 890 597 910 q 496 871 540 871 z "
    },
    "v": {
      "ha": 747,
      "x_min": 22,
      "x_max": 725,
      "o": "m 308 0 l 22 725 l 149 725 l 378 107 l 608 725 l 725 725 l 439 0 l 308 0 z "
    },
    "w": {
      "ha": 1140,
      "x_min": 15,
      "x_max": 1125,
      "o": "m 1007 725 l 1125 725 l 817 0 l 715 0 l 569 354 l 425 0 l 324 0 l 15 725 l 132 725 l 382 121 l 504 422 l 379 724 l 481 724 l 569 492 l 658 724 l 760 724 l 636 422 l 758 121 l 1007 725 z "
    },
    "ẃ": {
      "ha": 1140,
      "x_min": 15,
      "x_max": 1125,
      "o": "m 590 846 l 510 874 l 590 1014 l 713 1014 l 590 846 m 1007 725 l 1125 725 l 817 0 l 715 0 l 569 354 l 425 0 l 324 0 l 15 725 l 132 725 l 382 121 l 504 422 l 379 724 l 481 724 l 569 492 l 658 724 l 760 724 l 636 422 l 758 121 l 1007 725 z "
    },
    "ŵ": {
      "ha": 1140,
      "x_min": 15,
      "x_max": 1125,
      "o": "m 385 889 l 525 1014 l 614 1014 l 754 889 l 688 856 l 569 943 l 451 856 l 385 889 m 1007 725 l 1125 725 l 817 0 l 715 0 l 569 354 l 425 0 l 324 0 l 15 725 l 132 725 l 382 121 l 504 422 l 379 724 l 481 724 l 569 492 l 658 724 l 760 724 l 636 422 l 758 121 l 1007 725 z "
    },
    "ẅ": {
      "ha": 1140,
      "x_min": 15,
      "x_max": 1125,
      "o": "m 406 867 l 406 1008 l 508 1008 l 508 867 l 406 867 m 631 867 l 631 1008 l 733 1008 l 733 867 l 631 867 m 1007 725 l 1125 725 l 817 0 l 715 0 l 569 354 l 425 0 l 324 0 l 15 725 l 132 725 l 382 121 l 504 422 l 379 724 l 481 724 l 569 492 l 658 724 l 760 724 l 636 422 l 758 121 l 1007 725 z "
    },
    "ẁ": {
      "ha": 1140,
      "x_min": 15,
      "x_max": 1125,
      "o": "m 1007 725 l 1125 725 l 817 0 l 715 0 l 569 354 l 425 0 l 324 0 l 15 725 l 132 725 l 382 121 l 504 422 l 379 724 l 481 724 l 569 492 l 658 724 l 760 724 l 636 422 l 758 121 l 1007 725 m 426 1014 l 547 1014 l 629 874 l 550 846 l 426 1014 z "
    },
    "x": {
      "ha": 713,
      "x_min": 17,
      "x_max": 696,
      "o": "m 146 725 l 344 458 l 356 436 l 368 458 l 565 725 l 694 725 l 424 361 l 696 0 l 567 0 l 368 265 l 356 286 l 344 265 l 146 0 l 17 0 l 289 361 l 18 725 l 146 725 z "
    },
    "y": {
      "ha": 757,
      "x_min": 17,
      "x_max": 732,
      "o": "m 132 -197 q 168 -201 150 -200 q 196 -203 186 -203 q 226 -195 213 -203 q 252 -165 239 -187 q 282 -103 265 -143 q 324 0 299 -64 l 17 725 l 143 725 l 390 110 l 615 725 l 732 725 l 379 -190 q 315 -276 360 -239 q 190 -312 269 -312 q 165 -311 178 -312 q 132 -306 151 -310 l 132 -197 z "
    },
    "ý": {
      "ha": 757,
      "x_min": 17,
      "x_max": 732,
      "o": "m 132 -197 q 168 -201 150 -200 q 196 -203 186 -203 q 226 -195 213 -203 q 252 -165 239 -187 q 282 -103 265 -143 q 324 0 299 -64 l 17 725 l 143 725 l 390 110 l 615 725 l 732 725 l 379 -190 q 315 -276 360 -239 q 190 -312 269 -312 q 165 -311 178 -312 q 132 -306 151 -310 l 132 -197 m 411 846 l 331 874 l 411 1014 l 533 1014 l 411 846 z "
    },
    "ŷ": {
      "ha": 757,
      "x_min": 17,
      "x_max": 732,
      "o": "m 132 -197 q 168 -201 150 -200 q 196 -203 186 -203 q 226 -195 213 -203 q 252 -165 239 -187 q 282 -103 265 -143 q 324 0 299 -64 l 17 725 l 143 725 l 390 110 l 615 725 l 732 725 l 379 -190 q 315 -276 360 -239 q 190 -312 269 -312 q 165 -311 178 -312 q 132 -306 151 -310 l 132 -197 m 206 889 l 346 1014 l 435 1014 l 575 889 l 508 856 l 390 943 l 272 856 l 206 889 z "
    },
    "ÿ": {
      "ha": 757,
      "x_min": 17,
      "x_max": 732,
      "o": "m 132 -197 q 168 -201 150 -200 q 196 -203 186 -203 q 226 -195 213 -203 q 252 -165 239 -187 q 282 -103 265 -143 q 324 0 299 -64 l 17 725 l 143 725 l 390 110 l 615 725 l 732 725 l 379 -190 q 315 -276 360 -239 q 190 -312 269 -312 q 165 -311 178 -312 q 132 -306 151 -310 l 132 -197 m 226 867 l 226 1008 l 329 1008 l 329 867 l 226 867 m 451 867 l 451 1008 l 554 1008 l 554 867 l 451 867 z "
    },
    "¥": {
      "ha": 954,
      "x_min": 40,
      "x_max": 914,
      "o": "m 631 524 l 743 524 l 743 440 l 585 440 l 538 360 l 538 321 l 744 321 l 744 238 l 538 238 l 538 0 l 413 0 l 413 238 l 208 238 l 208 321 l 413 321 l 413 363 l 368 440 l 208 440 l 208 524 l 324 524 l 40 986 l 176 986 l 475 472 l 776 986 l 914 986 l 631 524 z "
    },
    "ỳ": {
      "ha": 757,
      "x_min": 17,
      "x_max": 732,
      "o": "m 132 -197 q 168 -201 150 -200 q 196 -203 186 -203 q 226 -195 213 -203 q 252 -165 239 -187 q 282 -103 265 -143 q 324 0 299 -64 l 17 725 l 143 725 l 390 110 l 615 725 l 732 725 l 379 -190 q 315 -276 360 -239 q 190 -312 269 -312 q 165 -311 178 -312 q 132 -306 151 -310 l 132 -197 m 246 1014 l 367 1014 l 449 874 l 369 846 l 246 1014 z "
    },
    "ỹ": {
      "ha": 757,
      "x_min": 17,
      "x_max": 732,
      "o": "m 132 -197 q 168 -201 150 -200 q 196 -203 186 -203 q 226 -195 213 -203 q 252 -165 239 -187 q 282 -103 265 -143 q 324 0 299 -64 l 17 725 l 143 725 l 390 110 l 615 725 l 732 725 l 379 -190 q 315 -276 360 -239 q 190 -312 269 -312 q 165 -311 178 -312 q 132 -306 151 -310 l 132 -197 m 476 871 q 422 880 444 871 q 378 900 399 889 q 339 920 358 911 q 297 929 319 929 q 260 919 274 929 q 240 898 247 910 q 231 875 233 886 q 229 863 229 864 l 157 863 q 163 894 157 871 q 185 943 169 918 q 226 987 200 968 q 294 1006 253 1006 q 346 997 324 1006 q 388 976 368 988 q 428 955 408 964 q 474 946 449 946 q 515 956 500 946 q 539 978 531 965 q 549 1001 547 990 q 551 1014 551 1011 l 624 1014 q 617 983 624 1006 q 594 935 611 960 q 549 890 578 910 q 476 871 521 871 z "
    },
    "z": {
      "ha": 685,
      "x_min": 42,
      "x_max": 638,
      "o": "m 42 79 l 506 636 l 54 636 l 54 725 l 636 725 l 636 646 l 175 89 l 638 89 l 638 0 l 42 0 l 42 79 z "
    },
    "ź": {
      "ha": 685,
      "x_min": 42,
      "x_max": 638,
      "o": "m 375 846 l 294 874 l 375 1014 l 497 1014 l 375 846 m 42 79 l 506 636 l 54 636 l 54 725 l 636 725 l 636 646 l 175 89 l 638 89 l 638 0 l 42 0 l 42 79 z "
    },
    "ž": {
      "ha": 685,
      "x_min": 42,
      "x_max": 638,
      "o": "m 235 1014 l 353 926 l 471 1014 l 538 981 l 397 856 l 308 856 l 168 981 l 235 1014 m 42 79 l 506 636 l 54 636 l 54 725 l 636 725 l 636 646 l 175 89 l 638 89 l 638 0 l 42 0 l 42 79 z "
    },
    "ż": {
      "ha": 685,
      "x_min": 42,
      "x_max": 638,
      "o": "m 42 79 l 506 636 l 54 636 l 54 725 l 636 725 l 636 646 l 175 89 l 638 89 l 638 0 l 42 0 l 42 79 m 297 867 l 297 1014 l 408 1014 l 408 867 l 297 867 z "
    },
    "₀": {
      "ha": 649,
      "x_min": 50,
      "x_max": 599,
      "o": "m 325 -118 q 206 -92 257 -118 q 119 -24 154 -65 q 67 69 85 18 q 50 167 50 119 q 69 269 50 218 q 124 360 89 319 q 210 427 160 401 q 325 453 261 453 q 444 426 393 453 q 529 356 494 399 q 581 263 564 314 q 599 167 599 213 q 580 65 599 115 q 526 -27 561 14 q 440 -93 490 -68 q 325 -118 389 -118 m 129 167 q 142 93 129 131 q 179 26 154 56 q 240 -23 204 -4 q 325 -42 276 -42 q 412 -22 375 -42 q 473 30 449 -1 q 509 97 497 61 q 521 167 521 133 q 508 241 521 204 q 469 308 494 278 q 408 358 444 339 q 325 376 372 376 q 238 356 275 376 q 177 305 201 336 q 141 237 153 274 q 129 167 129 200 z "
    },
    "⁰": {
      "ha": 649,
      "x_min": 50,
      "x_max": 599,
      "o": "m 325 554 q 206 581 257 554 q 119 649 154 607 q 67 741 85 690 q 50 839 50 792 q 69 941 50 890 q 124 1033 89 992 q 210 1099 160 1074 q 325 1125 261 1125 q 444 1098 393 1125 q 529 1028 494 1071 q 581 935 564 986 q 599 839 599 885 q 580 737 599 788 q 526 645 561 686 q 440 579 490 604 q 325 554 389 554 m 129 839 q 142 765 129 803 q 179 698 154 728 q 240 649 204 668 q 325 631 276 631 q 412 651 375 631 q 473 702 449 671 q 509 769 497 733 q 521 839 521 806 q 508 913 521 876 q 469 981 494 950 q 408 1030 444 1011 q 325 1049 372 1049 q 238 1028 275 1049 q 177 977 201 1008 q 141 909 153 946 q 129 839 129 872 z "
    },
    " ": {
      "ha": 1278,
      "x_min": 0,
      "x_max": 0,
      "o": ""
    },
    " ": {
      "ha": 814,
      "x_min": 0,
      "x_max": 0,
      "o": ""
    },
    "₤": {
      "ha": 694,
      "x_min": 71,
      "x_max": 653,
      "o": "m 71 561 l 171 561 q 125 653 146 607 q 104 753 104 700 q 125 847 104 803 q 181 923 146 890 q 265 974 217 956 q 367 993 313 993 q 515 954 446 993 q 629 847 585 915 l 561 772 q 474 859 528 826 q 364 892 419 892 q 306 880 332 892 q 259 849 279 868 q 228 801 239 829 q 217 743 217 774 q 239 653 217 696 q 286 561 261 610 l 556 561 l 556 489 l 319 489 q 340 407 335 449 l 556 407 l 556 335 l 340 335 q 304 222 335 276 q 207 96 274 167 q 310 110 258 110 q 410 97 365 110 q 504 85 456 85 q 559 91 532 85 q 622 110 586 97 l 653 17 q 577 -11 617 -1 q 499 -21 538 -21 q 438 -15 467 -21 q 381 -3 410 -10 q 322 8 351 3 q 260 14 292 14 q 182 7 225 14 q 101 -11 139 0 l 71 78 q 190 214 151 154 q 235 335 228 274 l 71 335 l 71 407 l 232 407 q 222 449 229 429 q 207 489 215 469 l 71 489 l 71 561 z "
    },
    "₦": {
      "ha": 1186,
      "x_min": 51,
      "x_max": 1133,
      "o": "m 1133 522 l 1011 522 l 1011 440 l 1133 440 l 1133 368 l 1011 368 l 1011 0 l 906 0 l 610 368 l 303 368 l 303 0 l 178 0 l 178 368 l 51 368 l 51 440 l 178 440 l 178 522 l 51 522 l 51 594 l 178 594 l 178 986 l 275 986 l 586 594 l 886 594 l 886 985 l 1011 985 l 1011 594 l 1133 594 l 1133 522 m 303 440 l 553 440 l 488 522 l 303 522 l 303 440 m 710 440 l 886 440 l 886 522 l 644 522 l 710 440 m 303 594 l 429 594 l 303 753 l 303 594 m 886 218 l 886 368 l 767 368 l 886 218 z "
    },
    "₩": {
      "ha": 1578,
      "x_min": 53,
      "x_max": 1524,
      "o": "m 53 496 l 276 496 l 236 592 l 53 592 l 53 664 l 206 664 l 72 986 l 207 986 l 335 664 l 665 664 l 539 981 l 657 981 l 788 638 l 919 981 l 1038 981 l 911 664 l 1242 664 l 1369 986 l 1506 986 l 1371 664 l 1524 664 l 1524 592 l 1340 592 l 1300 496 l 1524 496 l 1524 424 l 1269 424 l 1093 0 l 985 0 l 789 465 l 592 0 l 483 0 l 306 424 l 53 424 l 53 496 m 1036 144 l 1146 424 l 919 424 l 1036 144 m 542 144 l 657 424 l 431 424 l 542 144 m 867 551 l 889 496 l 1175 496 l 1213 592 l 882 592 l 867 551 m 693 592 l 364 592 l 401 496 l 686 496 l 710 551 l 693 592 z "
    },
    "₣": {
      "ha": 850,
      "x_min": 40,
      "x_max": 818,
      "o": "m 167 0 l 167 176 l 40 176 l 40 271 l 167 271 l 167 986 l 818 986 l 818 875 l 292 875 l 292 546 l 735 546 l 735 442 l 292 442 l 292 271 l 456 271 l 456 176 l 292 176 l 292 0 l 167 0 z "
    },
    "₡": {
      "ha": 774,
      "x_min": 53,
      "x_max": 732,
      "o": "m 317 0 q 208 52 257 17 q 125 135 160 88 q 72 242 90 183 q 53 364 53 300 q 71 485 53 428 q 124 591 89 543 q 207 673 158 639 q 317 724 256 707 l 317 896 l 378 896 l 378 735 q 399 737 389 736 q 421 738 410 738 q 441 738 432 738 q 461 735 450 738 l 461 896 l 522 896 l 522 725 q 644 663 593 706 q 726 561 696 621 l 607 524 q 529 603 579 575 q 418 632 479 632 q 324 612 368 632 q 247 556 279 592 q 197 471 215 519 q 178 364 178 422 q 197 257 178 307 q 249 170 217 207 q 326 113 282 133 q 419 92 369 92 q 483 101 451 92 q 540 125 514 110 q 585 160 565 140 q 613 204 604 181 l 732 168 q 652 63 707 107 q 522 -1 597 18 l 522 -167 l 461 -167 l 461 -11 q 442 -13 451 -12 q 422 -14 432 -14 q 400 -13 411 -14 q 378 -11 389 -12 l 378 -167 l 317 -167 l 317 0 z "
    },
    "̏": {
      "ha": 469,
      "x_min": 44,
      "x_max": 414,
      "o": "m 233 1014 l 339 1014 l 414 874 l 350 846 l 233 1014 m 44 1014 l 150 1014 l 225 874 l 161 846 l 44 1014 z "
    },
    "̑": {
      "ha": 411,
      "x_min": 56,
      "x_max": 356,
      "o": "m 206 954 q 150 926 174 954 q 126 860 126 897 l 56 860 q 67 921 56 893 q 99 969 79 949 q 147 1002 119 990 q 206 1014 174 1014 q 265 1002 238 1014 q 312 969 292 990 q 344 921 332 949 q 356 860 356 893 l 286 860 q 259 927 282 900 q 206 954 236 954 z "
    },
    "¤": {
      "ha": 747,
      "x_min": 67,
      "x_max": 681,
      "o": "m 222 675 q 291 711 253 699 q 374 724 329 724 q 456 711 418 724 q 525 675 493 699 l 624 775 l 681 718 l 581 618 q 626 468 626 553 q 579 318 626 385 l 681 218 l 631 168 l 528 264 q 458 227 497 240 q 374 214 419 214 q 289 227 328 214 q 218 264 250 240 l 117 168 l 67 218 l 167 318 q 133 388 144 350 q 121 468 121 426 q 165 618 121 554 l 67 718 l 124 775 l 222 675 m 221 467 q 233 400 221 431 q 265 347 244 369 q 314 312 286 325 q 374 299 342 299 q 433 312 406 299 q 482 348 461 325 q 515 402 503 371 q 526 469 526 433 q 515 536 526 506 q 482 590 503 567 q 433 625 461 613 q 374 638 406 638 q 314 624 342 638 q 265 588 286 611 q 233 534 244 565 q 221 467 221 503 z "
    },
    "№": {
      "ha": 1607,
      "x_min": 118,
      "x_max": 1582,
      "o": "m 243 753 l 243 0 l 118 0 l 118 986 l 215 986 l 826 218 l 826 985 l 951 985 l 951 0 l 846 0 l 243 753 m 1329 478 q 1226 499 1272 478 q 1146 554 1179 519 q 1094 635 1113 589 q 1076 732 1076 682 q 1094 830 1076 783 q 1146 912 1113 876 q 1226 967 1179 947 q 1329 988 1272 988 q 1433 967 1386 988 q 1513 912 1479 947 q 1564 830 1546 876 q 1582 732 1582 783 q 1564 635 1582 682 q 1513 554 1546 589 q 1433 499 1479 519 q 1329 478 1386 478 m 1176 731 q 1188 664 1176 694 q 1221 611 1200 633 q 1269 576 1242 589 q 1329 563 1297 563 q 1389 576 1361 563 q 1438 612 1417 589 q 1470 666 1458 635 q 1482 733 1482 697 q 1470 800 1482 769 q 1438 853 1458 831 q 1389 889 1417 876 q 1329 901 1361 901 q 1269 888 1297 901 q 1221 852 1242 875 q 1188 798 1200 829 q 1176 731 1176 767 z "
    },
    "₹": {
      "ha": 693,
      "x_min": 58,
      "x_max": 642,
      "o": "m 642 746 l 494 746 q 501 708 499 726 q 504 671 504 690 q 490 572 504 619 q 448 485 475 524 q 383 418 421 446 q 297 378 344 390 l 536 0 l 394 0 l 100 465 l 207 465 q 277 482 246 465 q 331 527 308 499 q 365 593 353 556 q 378 671 378 631 q 364 746 378 707 l 58 746 l 58 818 l 321 818 q 265 860 297 844 q 199 875 233 875 l 58 875 l 58 986 l 642 986 l 642 914 l 392 914 q 434 869 415 893 q 467 818 453 846 l 642 818 l 642 746 z "
    },
    "℠": {
      "ha": 1026,
      "x_min": 71,
      "x_max": 931,
      "o": "m 811 986 l 931 986 l 931 583 l 847 583 l 847 872 l 739 642 l 671 642 l 563 872 l 563 583 l 479 583 l 479 986 l 597 986 l 704 739 l 811 986 m 363 878 q 315 907 347 893 q 244 921 283 921 q 169 881 169 921 q 186 850 169 863 q 261 825 203 838 q 374 782 332 810 q 415 692 415 754 q 368 605 415 632 q 250 578 321 578 q 71 636 149 578 l 110 699 q 166 666 128 681 q 251 651 204 651 q 326 686 326 651 q 306 721 326 708 q 225 749 285 733 q 119 790 154 765 q 83 872 83 815 q 129 962 83 931 q 246 993 175 993 q 328 981 292 993 q 394 947 365 968 l 363 878 z "
    },
    "Ə": {
      "ha": 1022,
      "x_min": 38,
      "x_max": 967,
      "o": "m 506 -7 q 323 32 408 -7 q 174 138 238 71 q 74 294 111 204 q 38 485 38 383 q 38 519 38 503 q 42 544 39 536 l 829 544 q 793 676 822 615 q 720 783 764 738 q 619 853 676 828 q 499 878 563 878 q 406 864 450 878 q 324 826 361 850 q 260 767 288 801 q 219 693 232 733 l 101 747 q 172 847 128 801 q 269 925 215 893 q 385 975 324 957 q 510 993 446 993 q 689 954 606 993 q 834 847 772 915 q 931 688 896 779 q 967 490 967 596 q 931 295 967 386 q 833 137 896 204 q 687 31 771 69 q 506 -7 603 -7 m 508 106 q 631 131 574 106 q 731 199 688 156 q 801 304 774 243 q 832 436 828 365 l 172 436 q 204 306 176 367 q 278 201 232 246 q 383 131 324 157 q 508 106 442 106 z "
    },
    "≈": {
      "ha": 604,
      "x_min": 88,
      "x_max": 517,
      "o": "m 517 465 q 467 420 497 439 q 389 401 436 401 q 334 410 357 401 q 291 431 311 419 q 251 451 271 442 q 210 460 232 460 q 166 449 182 460 q 143 424 150 438 l 88 485 q 133 531 104 511 q 207 550 161 550 q 258 541 236 550 q 301 520 281 532 q 341 499 321 508 q 386 490 361 490 q 435 500 418 490 q 464 521 453 510 l 517 465 m 517 275 q 467 235 497 251 q 389 218 436 218 q 334 227 357 218 q 291 247 311 236 q 251 267 271 258 q 210 276 232 276 q 166 265 182 276 q 143 240 150 254 l 88 301 q 133 347 104 328 q 207 367 161 367 q 258 358 236 367 q 301 337 281 349 q 341 316 321 325 q 386 307 361 307 q 435 316 418 307 q 464 338 453 325 l 517 275 z "
    },
    "≠": {
      "ha": 668,
      "x_min": 122,
      "x_max": 546,
      "o": "m 122 518 l 372 518 l 465 688 l 518 657 l 442 518 l 546 518 l 546 435 l 397 435 l 340 332 l 546 332 l 546 249 l 294 249 l 203 79 l 150 110 l 225 249 l 122 249 l 122 332 l 271 332 l 328 435 l 122 435 l 122 518 z "
    },
    "≤": {
      "ha": 626,
      "x_min": 78,
      "x_max": 540,
      "o": "m 79 71 l 79 171 l 540 171 l 540 71 l 79 71 m 78 542 l 536 768 l 536 651 l 256 513 l 536 378 l 536 256 l 78 478 l 78 542 z "
    },
    "≥": {
      "ha": 626,
      "x_min": 86,
      "x_max": 549,
      "o": "m 86 71 l 86 171 l 547 171 l 547 71 l 86 71 m 549 478 l 90 256 l 90 378 l 371 513 l 90 651 l 90 768 l 549 542 l 549 478 z "
    },
    "Ǳ": {
      "ha": 1853,
      "x_min": 118,
      "x_max": 1803,
      "o": "m 118 0 l 118 986 l 460 986 q 667 947 578 986 q 817 842 757 908 q 906 685 876 775 q 936 494 936 596 q 903 291 936 382 q 807 135 869 200 q 656 35 744 71 q 460 0 568 0 l 118 0 m 810 494 q 787 648 810 578 q 719 768 764 718 q 608 847 674 818 q 460 875 543 875 l 243 875 l 243 111 l 460 111 q 610 140 544 111 q 720 221 676 169 q 787 342 764 272 q 810 494 810 413 m 1021 97 l 1657 875 l 1033 875 l 1033 986 l 1803 986 l 1803 889 l 1178 111 l 1803 111 l 1803 0 l 1021 0 l 1021 97 z "
    },
    "ǲ": {
      "ha": 1679,
      "x_min": 118,
      "x_max": 1632,
      "o": "m 118 0 l 118 986 l 460 986 q 667 947 578 986 q 817 842 757 908 q 906 685 876 775 q 936 494 936 596 q 903 291 936 382 q 807 135 869 200 q 656 35 744 71 q 460 0 568 0 l 118 0 m 810 494 q 787 648 810 578 q 719 768 764 718 q 608 847 674 818 q 460 875 543 875 l 243 875 l 243 111 l 460 111 q 610 140 544 111 q 720 221 676 169 q 787 342 764 272 q 810 494 810 413 m 1036 79 l 1500 636 l 1049 636 l 1049 725 l 1631 725 l 1631 646 l 1169 89 l 1632 89 l 1632 0 l 1036 0 l 1036 79 z "
    },
    "ǳ": {
      "ha": 1558,
      "x_min": 51,
      "x_max": 1511,
      "o": "m 397 -14 q 258 17 322 -14 q 149 99 194 47 q 77 218 103 150 q 51 361 51 286 q 76 506 51 438 q 144 626 100 575 q 248 708 188 678 q 381 738 308 738 q 537 692 468 738 q 646 581 606 646 l 646 1014 l 768 1014 l 768 150 q 807 106 768 107 l 807 0 q 776 -4 788 -3 q 753 -6 764 -6 q 690 19 717 -6 q 663 75 663 43 l 663 136 q 548 26 619 65 q 397 -14 476 -14 m 426 92 q 495 104 460 92 q 562 139 531 117 q 616 191 593 161 q 646 254 639 221 l 646 463 q 608 528 633 497 q 552 583 583 560 q 485 619 521 606 q 415 632 450 632 q 317 609 361 632 q 242 548 274 586 q 194 460 211 510 q 178 360 178 411 q 197 256 178 306 q 250 171 217 207 q 328 113 283 135 q 426 92 374 92 m 915 79 l 1379 636 l 928 636 l 928 725 l 1510 725 l 1510 646 l 1049 89 l 1511 89 l 1511 0 l 915 0 l 915 79 z "
    },
    "Ǉ": {
      "ha": 1485,
      "x_min": 118,
      "x_max": 1378,
      "o": "m 118 0 l 118 986 l 243 986 l 243 111 l 793 111 l 793 0 l 118 0 m 860 147 q 935 113 888 128 q 1042 97 982 97 q 1154 122 1113 97 q 1217 197 1196 147 q 1246 318 1239 246 q 1253 485 1253 390 l 1253 986 l 1378 986 l 1378 485 q 1367 280 1378 372 q 1322 122 1357 188 q 1220 21 1286 57 q 1042 -15 1154 -15 q 828 46 917 -15 l 860 147 z "
    },
    "ǈ": {
      "ha": 1140,
      "x_min": 118,
      "x_max": 1042,
      "o": "m 118 0 l 118 986 l 243 986 l 243 111 l 793 111 l 793 0 l 118 0 m 817 -258 q 726 -244 768 -258 q 650 -200 683 -231 l 707 -118 q 752 -143 726 -136 q 803 -150 778 -150 q 846 -141 825 -150 q 883 -117 867 -132 q 910 -79 900 -101 q 919 -32 919 -57 l 919 725 l 1042 725 l 1042 -24 q 1023 -118 1042 -75 q 973 -192 1004 -161 q 901 -241 942 -224 q 817 -258 861 -258 m 919 861 l 919 1014 l 1042 1014 l 1042 861 l 919 861 z "
    },
    "ǉ": {
      "ha": 726,
      "x_min": 101,
      "x_max": 628,
      "o": "m 101 1014 l 224 1014 l 224 188 q 245 124 224 147 q 306 101 267 101 q 342 106 321 101 q 381 118 363 111 l 400 19 q 328 -1 369 7 q 254 -10 286 -10 q 142 31 183 -10 q 101 143 101 71 l 101 1014 m 403 -258 q 312 -244 354 -258 q 236 -200 269 -231 l 293 -118 q 338 -143 313 -136 q 389 -150 364 -150 q 432 -141 411 -150 q 469 -117 453 -132 q 496 -79 486 -101 q 506 -32 506 -57 l 506 725 l 628 725 l 628 -24 q 609 -118 628 -75 q 559 -192 590 -161 q 488 -241 528 -224 q 403 -258 447 -258 m 506 861 l 506 1014 l 628 1014 l 628 861 l 506 861 z "
    },
    "Ǌ": {
      "ha": 1743,
      "x_min": 118,
      "x_max": 1636,
      "o": "m 243 753 l 243 0 l 118 0 l 118 986 l 215 986 l 826 218 l 826 985 l 951 985 l 951 0 l 846 0 l 243 753 m 1118 147 q 1193 113 1146 128 q 1300 97 1240 97 q 1413 122 1371 97 q 1476 197 1454 147 q 1504 318 1497 246 q 1511 485 1511 390 l 1511 986 l 1636 986 l 1636 485 q 1626 280 1636 372 q 1580 122 1615 188 q 1478 21 1544 57 q 1300 -15 1413 -15 q 1086 46 1175 -15 l 1118 147 z "
    },
    "ǋ": {
      "ha": 1399,
      "x_min": 118,
      "x_max": 1300,
      "o": "m 243 753 l 243 0 l 118 0 l 118 986 l 215 986 l 826 218 l 826 985 l 951 985 l 951 0 l 846 0 l 243 753 m 1075 -258 q 984 -244 1026 -258 q 908 -200 942 -231 l 965 -118 q 1010 -143 985 -136 q 1061 -150 1036 -150 q 1104 -141 1083 -150 q 1142 -117 1125 -132 q 1168 -79 1158 -101 q 1178 -32 1178 -57 l 1178 725 l 1300 725 l 1300 -24 q 1281 -118 1300 -75 q 1231 -192 1263 -161 q 1160 -241 1200 -224 q 1075 -258 1119 -258 m 1178 861 l 1178 1014 l 1300 1014 l 1300 861 l 1178 861 z "
    },
    "ǌ": {
      "ha": 1149,
      "x_min": 99,
      "x_max": 1050,
      "o": "m 728 0 l 606 0 l 606 406 q 570 575 606 522 q 463 628 535 628 q 388 613 425 628 q 317 574 350 599 q 258 514 283 549 q 221 438 233 479 l 221 0 l 99 0 l 99 725 l 210 725 l 210 569 q 334 692 253 646 q 511 738 415 738 q 615 715 574 738 q 682 651 657 692 q 717 554 707 610 q 728 433 728 499 l 728 0 m 825 -258 q 734 -244 776 -258 q 658 -200 692 -231 l 715 -118 q 760 -143 735 -136 q 811 -150 786 -150 q 854 -141 833 -150 q 892 -117 875 -132 q 918 -79 908 -101 q 928 -32 928 -57 l 928 725 l 1050 725 l 1050 -24 q 1031 -118 1050 -75 q 981 -192 1013 -161 q 910 -241 950 -224 q 825 -258 869 -258 m 928 861 l 928 1014 l 1050 1014 l 1050 861 l 928 861 z "
    },
    "Ǆ": {
      "ha": 1871,
      "x_min": 118,
      "x_max": 1821,
      "o": "m 118 0 l 118 986 l 460 986 q 667 947 578 986 q 817 842 757 908 q 906 685 876 775 q 936 494 936 596 q 903 291 936 382 q 807 135 869 200 q 656 35 744 71 q 460 0 568 0 l 118 0 m 810 494 q 787 648 810 578 q 719 768 764 718 q 608 847 674 818 q 460 875 543 875 l 243 875 l 243 111 l 460 111 q 610 140 544 111 q 720 221 676 169 q 787 342 764 272 q 810 494 810 413 m 1336 1272 l 1454 1185 l 1572 1272 l 1639 1239 l 1499 1114 l 1410 1114 l 1269 1239 l 1336 1272 m 1039 97 l 1675 875 l 1051 875 l 1051 986 l 1821 986 l 1821 889 l 1196 111 l 1821 111 l 1821 0 l 1039 0 l 1039 97 z "
    },
    "ǅ": {
      "ha": 1679,
      "x_min": 118,
      "x_max": 1632,
      "o": "m 118 0 l 118 986 l 460 986 q 667 947 578 986 q 817 842 757 908 q 906 685 876 775 q 936 494 936 596 q 903 291 936 382 q 807 135 869 200 q 656 35 744 71 q 460 0 568 0 l 118 0 m 810 494 q 787 648 810 578 q 719 768 764 718 q 608 847 674 818 q 460 875 543 875 l 243 875 l 243 111 l 460 111 q 610 140 544 111 q 720 221 676 169 q 787 342 764 272 q 810 494 810 413 m 1229 1014 l 1347 926 l 1465 1014 l 1532 981 l 1392 856 l 1303 856 l 1163 981 l 1229 1014 m 1036 79 l 1500 636 l 1049 636 l 1049 725 l 1631 725 l 1631 646 l 1169 89 l 1632 89 l 1632 0 l 1036 0 l 1036 79 z "
    },
    "ǆ": {
      "ha": 1558,
      "x_min": 51,
      "x_max": 1511,
      "o": "m 397 -14 q 258 17 322 -14 q 149 99 194 47 q 77 218 103 150 q 51 361 51 286 q 76 506 51 438 q 144 626 100 575 q 248 708 188 678 q 381 738 308 738 q 537 692 468 738 q 646 581 606 646 l 646 1014 l 768 1014 l 768 150 q 807 106 768 107 l 807 0 q 776 -4 788 -3 q 753 -6 764 -6 q 690 19 717 -6 q 663 75 663 43 l 663 136 q 548 26 619 65 q 397 -14 476 -14 m 426 92 q 495 104 460 92 q 562 139 531 117 q 616 191 593 161 q 646 254 639 221 l 646 463 q 608 528 633 497 q 552 583 583 560 q 485 619 521 606 q 415 632 450 632 q 317 609 361 632 q 242 548 274 586 q 194 460 211 510 q 178 360 178 411 q 197 256 178 306 q 250 171 217 207 q 328 113 283 135 q 426 92 374 92 m 1108 1014 l 1226 926 l 1344 1014 l 1411 981 l 1271 856 l 1182 856 l 1042 981 l 1108 1014 m 915 79 l 1379 636 l 928 636 l 928 725 l 1510 725 l 1510 646 l 1049 89 l 1511 89 l 1511 0 l 915 0 l 915 79 z "
    },
    "Ȁ": {
      "ha": 940,
      "x_min": 14,
      "x_max": 926,
      "o": "m 418 986 l 524 986 l 926 0 l 793 0 l 676 289 l 263 289 l 147 0 l 14 0 l 418 986 m 649 386 l 471 842 l 288 386 l 649 386 m 426 1275 l 532 1275 l 607 1135 l 543 1107 l 426 1275 m 238 1275 l 343 1275 l 418 1135 l 354 1107 l 238 1275 z "
    },
    "Ȃ": {
      "ha": 940,
      "x_min": 14,
      "x_max": 926,
      "o": "m 418 986 l 524 986 l 926 0 l 793 0 l 676 289 l 263 289 l 147 0 l 14 0 l 418 986 m 649 386 l 471 842 l 288 386 l 649 386 m 471 1213 q 415 1184 439 1213 q 392 1118 392 1156 l 321 1118 q 333 1179 321 1151 q 365 1228 344 1207 q 412 1260 385 1249 q 471 1272 439 1272 q 530 1260 503 1272 q 577 1228 557 1249 q 609 1179 597 1207 q 621 1118 621 1151 l 551 1118 q 524 1185 547 1158 q 471 1213 501 1213 z "
    },
    "Ḍ": {
      "ha": 994,
      "x_min": 118,
      "x_max": 936,
      "o": "m 118 0 l 118 986 l 460 986 q 667 947 578 986 q 817 842 757 908 q 906 685 876 775 q 936 494 936 596 q 903 291 936 382 q 807 135 869 200 q 656 35 744 71 q 460 0 568 0 l 118 0 m 810 494 q 787 648 810 578 q 719 768 764 718 q 608 847 674 818 q 460 875 543 875 l 243 875 l 243 111 l 460 111 q 610 140 544 111 q 720 221 676 169 q 787 342 764 272 q 810 494 810 413 m 414 -253 l 414 -106 l 525 -106 l 525 -253 l 414 -253 z "
    },
    "Ẹ": {
      "ha": 840,
      "x_min": 118,
      "x_max": 788,
      "o": "m 788 111 l 788 0 l 118 0 l 118 986 l 775 986 l 775 875 l 243 875 l 243 556 l 706 556 l 706 451 l 243 451 l 243 111 l 788 111 m 390 -253 l 390 -106 l 501 -106 l 501 -253 l 390 -253 z "
    },
    "Ȅ": {
      "ha": 840,
      "x_min": 118,
      "x_max": 788,
      "o": "m 788 111 l 788 0 l 118 0 l 118 986 l 775 986 l 775 875 l 243 875 l 243 556 l 706 556 l 706 451 l 243 451 l 243 111 l 788 111 m 425 1275 l 531 1275 l 606 1135 l 542 1107 l 425 1275 m 236 1275 l 342 1275 l 417 1135 l 353 1107 l 236 1275 z "
    },
    "Ȇ": {
      "ha": 840,
      "x_min": 118,
      "x_max": 788,
      "o": "m 788 111 l 788 0 l 118 0 l 118 986 l 775 986 l 775 875 l 243 875 l 243 556 l 706 556 l 706 451 l 243 451 l 243 111 l 788 111 m 463 1213 q 407 1184 431 1213 q 383 1118 383 1156 l 313 1118 q 324 1179 313 1151 q 356 1228 336 1207 q 403 1260 376 1249 q 463 1272 431 1272 q 522 1260 494 1272 q 569 1228 549 1249 q 601 1179 589 1207 q 613 1118 613 1151 l 543 1118 q 516 1185 539 1158 q 463 1213 493 1213 z "
    },
    "Ǵ": {
      "ha": 992,
      "x_min": 54,
      "x_max": 919,
      "o": "m 814 133 q 514 -7 683 -7 q 331 36 415 -7 q 186 149 247 79 q 90 310 125 219 q 54 496 54 400 q 89 685 54 596 q 185 844 124 775 q 331 953 246 913 q 514 993 415 993 q 749 933 657 993 q 890 778 842 874 l 794 711 q 676 839 750 797 q 511 881 603 881 q 375 848 436 881 q 271 762 314 815 q 204 638 228 708 q 181 493 181 568 q 207 344 181 414 q 279 220 233 274 q 388 136 325 167 q 524 106 450 106 q 814 261 685 106 l 814 397 l 601 397 l 601 492 l 919 492 l 919 0 l 814 0 l 814 133 m 542 1104 l 461 1132 l 542 1272 l 664 1272 l 542 1104 z "
    },
    "Ḥ": {
      "ha": 1029,
      "x_min": 118,
      "x_max": 911,
      "o": "m 911 986 l 911 0 l 786 0 l 786 449 l 243 449 l 243 0 l 118 0 l 118 986 l 243 986 l 243 560 l 786 560 l 786 986 l 911 986 m 458 -253 l 458 -106 l 569 -106 l 569 -253 l 458 -253 z "
    },
    "Ị": {
      "ha": 361,
      "x_min": 118,
      "x_max": 243,
      "o": "m 118 0 l 118 986 l 243 986 l 243 0 l 118 0 m 121 -253 l 121 -106 l 232 -106 l 232 -253 l 121 -253 z "
    },
    "Ȉ": {
      "ha": 361,
      "x_min": -33,
      "x_max": 336,
      "o": "m 118 0 l 118 986 l 243 986 l 243 0 l 118 0 m 156 1275 l 261 1275 l 336 1135 l 272 1107 l 156 1275 m -33 1275 l 72 1275 l 147 1135 l 83 1107 l -33 1275 z "
    },
    "Ȋ": {
      "ha": 361,
      "x_min": 26,
      "x_max": 326,
      "o": "m 118 0 l 118 986 l 243 986 l 243 0 l 118 0 m 176 1213 q 121 1184 144 1213 q 97 1118 97 1156 l 26 1118 q 38 1179 26 1151 q 70 1228 50 1207 q 117 1260 90 1249 q 176 1272 144 1272 q 235 1260 208 1272 q 283 1228 263 1249 q 315 1179 303 1207 q 326 1118 326 1151 l 257 1118 q 230 1185 253 1158 q 176 1213 207 1213 z "
    },
    "Ọ": {
      "ha": 1039,
      "x_min": 54,
      "x_max": 983,
      "o": "m 518 -7 q 328 35 414 -7 q 182 148 243 78 q 88 308 121 218 q 54 493 54 399 q 90 682 54 592 q 188 842 125 772 q 335 952 250 911 q 521 993 421 993 q 710 949 625 993 q 856 835 794 906 q 950 674 917 764 q 983 492 983 585 q 948 303 983 393 q 851 144 913 213 q 703 34 789 75 q 518 -7 618 -7 m 181 493 q 205 348 181 418 q 274 224 229 278 q 381 138 318 169 q 519 106 443 106 q 661 140 599 106 q 767 228 724 174 q 834 353 811 283 q 857 493 857 422 q 833 638 857 568 q 763 762 808 708 q 656 847 718 815 q 519 879 594 879 q 378 846 440 879 q 272 758 315 813 q 204 635 228 704 q 181 493 181 565 m 463 -253 l 463 -106 l 574 -106 l 574 -253 l 463 -253 z "
    },
    "Ȍ": {
      "ha": 1039,
      "x_min": 54,
      "x_max": 983,
      "o": "m 518 -7 q 328 35 414 -7 q 182 148 243 78 q 88 308 121 218 q 54 493 54 399 q 90 682 54 592 q 188 842 125 772 q 335 952 250 911 q 521 993 421 993 q 710 949 625 993 q 856 835 794 906 q 950 674 917 764 q 983 492 983 585 q 948 303 983 393 q 851 144 913 213 q 703 34 789 75 q 518 -7 618 -7 m 181 493 q 205 348 181 418 q 274 224 229 278 q 381 138 318 169 q 519 106 443 106 q 661 140 599 106 q 767 228 724 174 q 834 353 811 283 q 857 493 857 422 q 833 638 857 568 q 763 762 808 708 q 656 847 718 815 q 519 879 594 879 q 378 846 440 879 q 272 758 315 813 q 204 635 228 704 q 181 493 181 565 m 475 1275 l 581 1275 l 656 1135 l 592 1107 l 475 1275 m 286 1275 l 392 1275 l 467 1135 l 403 1107 l 286 1275 z "
    },
    "Ȏ": {
      "ha": 1039,
      "x_min": 54,
      "x_max": 983,
      "o": "m 518 -7 q 328 35 414 -7 q 182 148 243 78 q 88 308 121 218 q 54 493 54 399 q 90 682 54 592 q 188 842 125 772 q 335 952 250 911 q 521 993 421 993 q 710 949 625 993 q 856 835 794 906 q 950 674 917 764 q 983 492 983 585 q 948 303 983 393 q 851 144 913 213 q 703 34 789 75 q 518 -7 618 -7 m 181 493 q 205 348 181 418 q 274 224 229 278 q 381 138 318 169 q 519 106 443 106 q 661 140 599 106 q 767 228 724 174 q 834 353 811 283 q 857 493 857 422 q 833 638 857 568 q 763 762 808 708 q 656 847 718 815 q 519 879 594 879 q 378 846 440 879 q 272 758 315 813 q 204 635 228 704 q 181 493 181 565 m 521 1213 q 465 1184 489 1213 q 442 1118 442 1156 l 371 1118 q 383 1179 371 1151 q 415 1228 394 1207 q 462 1260 435 1249 q 521 1272 489 1272 q 580 1260 553 1272 q 627 1228 607 1249 q 659 1179 647 1207 q 671 1118 671 1151 l 601 1118 q 574 1185 597 1158 q 521 1213 551 1213 z "
    },
    "Ṛ": {
      "ha": 913,
      "x_min": 118,
      "x_max": 871,
      "o": "m 118 0 l 118 986 l 540 986 q 660 959 606 986 q 755 887 715 932 q 817 785 794 842 q 839 671 839 729 q 824 572 839 619 q 783 485 810 524 q 717 418 756 446 q 632 378 679 390 l 871 0 l 729 0 l 504 354 l 243 354 l 243 0 l 118 0 m 243 465 l 542 465 q 612 482 581 465 q 665 527 643 499 q 700 593 688 556 q 713 671 713 631 q 698 749 713 713 q 659 815 683 786 q 602 859 635 843 q 533 875 569 875 l 243 875 l 243 465 m 400 -253 l 400 -106 l 511 -106 l 511 -253 l 400 -253 z "
    },
    "Ȑ": {
      "ha": 913,
      "x_min": 118,
      "x_max": 871,
      "o": "m 118 0 l 118 986 l 540 986 q 660 959 606 986 q 755 887 715 932 q 817 785 794 842 q 839 671 839 729 q 824 572 839 619 q 783 485 810 524 q 717 418 756 446 q 632 378 679 390 l 871 0 l 729 0 l 504 354 l 243 354 l 243 0 l 118 0 m 243 465 l 542 465 q 612 482 581 465 q 665 527 643 499 q 700 593 688 556 q 713 671 713 631 q 698 749 713 713 q 659 815 683 786 q 602 859 635 843 q 533 875 569 875 l 243 875 l 243 465 m 408 1275 l 514 1275 l 589 1135 l 525 1107 l 408 1275 m 219 1275 l 325 1275 l 400 1135 l 336 1107 l 219 1275 z "
    },
    "Ȓ": {
      "ha": 913,
      "x_min": 118,
      "x_max": 871,
      "o": "m 118 0 l 118 986 l 540 986 q 660 959 606 986 q 755 887 715 932 q 817 785 794 842 q 839 671 839 729 q 824 572 839 619 q 783 485 810 524 q 717 418 756 446 q 632 378 679 390 l 871 0 l 729 0 l 504 354 l 243 354 l 243 0 l 118 0 m 243 465 l 542 465 q 612 482 581 465 q 665 527 643 499 q 700 593 688 556 q 713 671 713 631 q 698 749 713 713 q 659 815 683 786 q 602 859 635 843 q 533 875 569 875 l 243 875 l 243 465 m 449 1213 q 393 1184 417 1213 q 369 1118 369 1156 l 299 1118 q 310 1179 299 1151 q 342 1228 322 1207 q 390 1260 363 1249 q 449 1272 417 1272 q 508 1260 481 1272 q 555 1228 535 1249 q 587 1179 575 1207 q 599 1118 599 1151 l 529 1118 q 502 1185 525 1158 q 449 1213 479 1213 z "
    },
    "Ṣ": {
      "ha": 846,
      "x_min": 40,
      "x_max": 800,
      "o": "m 697 779 q 653 817 681 799 q 590 849 625 835 q 515 873 556 864 q 429 882 474 882 q 260 839 314 882 q 207 721 207 796 q 222 654 207 681 q 270 609 238 628 q 351 576 303 590 q 467 547 400 563 q 605 509 543 531 q 710 456 667 488 q 777 378 754 424 q 800 265 800 332 q 772 142 800 194 q 697 56 744 90 q 583 6 649 22 q 442 -10 518 -10 q 226 26 328 -10 q 40 129 124 61 l 100 235 q 158 188 122 211 q 238 145 193 164 q 335 115 283 126 q 444 103 388 103 q 608 140 550 103 q 667 253 667 178 q 648 323 667 294 q 593 372 629 351 q 503 409 557 393 q 382 442 450 425 q 250 481 307 460 q 155 531 193 501 q 97 601 117 560 q 78 701 78 643 q 104 826 78 772 q 178 918 131 881 q 290 974 225 956 q 432 993 356 993 q 613 963 532 993 q 756 881 693 932 l 697 779 m 367 -253 l 367 -106 l 478 -106 l 478 -253 l 367 -253 z "
    },
    "Ṭ": {
      "ha": 853,
      "x_min": 24,
      "x_max": 829,
      "o": "m 829 875 l 489 875 l 489 0 l 364 0 l 364 875 l 24 875 l 24 986 l 829 986 l 829 875 m 368 -253 l 368 -106 l 479 -106 l 479 -253 l 368 -253 z "
    },
    "Ụ": {
      "ha": 1049,
      "x_min": 104,
      "x_max": 944,
      "o": "m 524 106 q 667 139 610 106 q 758 226 724 172 q 806 348 792 279 q 819 488 819 417 l 819 986 l 944 986 l 944 488 q 922 298 944 388 q 849 140 899 208 q 719 33 799 72 q 525 -7 639 -7 q 326 35 407 -7 q 197 145 246 76 q 126 303 147 214 q 104 488 104 393 l 104 986 l 229 986 l 229 488 q 244 345 229 414 q 292 224 258 276 q 383 138 326 171 q 524 106 439 106 m 471 -253 l 471 -106 l 582 -106 l 582 -253 l 471 -253 z "
    },
    "Ȕ": {
      "ha": 1049,
      "x_min": 104,
      "x_max": 944,
      "o": "m 524 106 q 667 139 610 106 q 758 226 724 172 q 806 348 792 279 q 819 488 819 417 l 819 986 l 944 986 l 944 488 q 922 298 944 388 q 849 140 899 208 q 719 33 799 72 q 525 -7 639 -7 q 326 35 407 -7 q 197 145 246 76 q 126 303 147 214 q 104 488 104 393 l 104 986 l 229 986 l 229 488 q 244 345 229 414 q 292 224 258 276 q 383 138 326 171 q 524 106 439 106 m 485 1275 l 590 1275 l 665 1135 l 601 1107 l 485 1275 m 296 1275 l 401 1275 l 476 1135 l 413 1107 l 296 1275 z "
    },
    "Ȗ": {
      "ha": 1049,
      "x_min": 104,
      "x_max": 944,
      "o": "m 524 106 q 667 139 610 106 q 758 226 724 172 q 806 348 792 279 q 819 488 819 417 l 819 986 l 944 986 l 944 488 q 922 298 944 388 q 849 140 899 208 q 719 33 799 72 q 525 -7 639 -7 q 326 35 407 -7 q 197 145 246 76 q 126 303 147 214 q 104 488 104 393 l 104 986 l 229 986 l 229 488 q 244 345 229 414 q 292 224 258 276 q 383 138 326 171 q 524 106 439 106 m 524 1213 q 468 1184 492 1213 q 444 1118 444 1156 l 374 1118 q 385 1179 374 1151 q 417 1228 397 1207 q 465 1260 438 1249 q 524 1272 492 1272 q 583 1260 556 1272 q 630 1228 610 1249 q 662 1179 650 1207 q 674 1118 674 1151 l 604 1118 q 577 1185 600 1158 q 524 1213 554 1213 z "
    },
    "Ẓ": {
      "ha": 876,
      "x_min": 44,
      "x_max": 826,
      "o": "m 44 97 l 681 875 l 57 875 l 57 986 l 826 986 l 826 889 l 201 111 l 826 111 l 826 0 l 44 0 l 44 97 m 397 -253 l 397 -106 l 508 -106 l 508 -253 l 397 -253 z "
    },
    "ȁ": {
      "ha": 769,
      "x_min": 42,
      "x_max": 711,
      "o": "m 285 -14 q 189 3 233 -14 q 112 51 144 21 q 60 123 79 82 q 42 213 42 164 q 64 303 42 263 q 127 374 86 344 q 224 419 168 403 q 347 436 281 436 q 454 426 400 436 q 550 400 508 417 l 550 458 q 500 598 550 547 q 358 649 450 649 q 128 564 249 649 l 88 643 q 369 738 228 738 q 592 661 513 738 q 672 446 672 585 l 672 150 q 711 106 672 107 l 711 0 q 679 -4 692 -3 q 653 -6 667 -6 q 595 16 617 -6 q 569 68 574 38 l 567 119 q 444 20 518 54 q 285 -14 369 -14 m 317 78 q 438 102 382 78 q 524 167 494 126 q 550 221 550 193 l 550 328 q 365 363 461 363 q 216 324 274 363 q 158 222 158 285 q 170 165 158 192 q 203 119 182 139 q 254 89 225 100 q 317 78 283 78 m 358 1014 l 464 1014 l 539 874 l 475 846 l 358 1014 m 169 1014 l 275 1014 l 350 874 l 286 846 l 169 1014 z "
    },
    "ȃ": {
      "ha": 769,
      "x_min": 42,
      "x_max": 711,
      "o": "m 285 -14 q 189 3 233 -14 q 112 51 144 21 q 60 123 79 82 q 42 213 42 164 q 64 303 42 263 q 127 374 86 344 q 224 419 168 403 q 347 436 281 436 q 454 426 400 436 q 550 400 508 417 l 550 458 q 500 598 550 547 q 358 649 450 649 q 128 564 249 649 l 88 643 q 369 738 228 738 q 592 661 513 738 q 672 446 672 585 l 672 150 q 711 106 672 107 l 711 0 q 679 -4 692 -3 q 653 -6 667 -6 q 595 16 617 -6 q 569 68 574 38 l 567 119 q 444 20 518 54 q 285 -14 369 -14 m 317 78 q 438 102 382 78 q 524 167 494 126 q 550 221 550 193 l 550 328 q 365 363 461 363 q 216 324 274 363 q 158 222 158 285 q 170 165 158 192 q 203 119 182 139 q 254 89 225 100 q 317 78 283 78 m 379 954 q 324 926 347 954 q 300 860 300 897 l 229 860 q 241 921 229 893 q 273 969 253 949 q 320 1002 293 990 q 379 1014 347 1014 q 438 1002 411 1014 q 485 969 465 990 q 517 921 506 949 q 529 860 529 893 l 460 860 q 433 927 456 900 q 379 954 410 954 z "
    },
    "ḍ": {
      "ha": 874,
      "x_min": 51,
      "x_max": 807,
      "o": "m 397 -14 q 258 17 322 -14 q 149 99 194 47 q 77 218 103 150 q 51 361 51 286 q 76 506 51 438 q 144 626 100 575 q 248 708 188 678 q 381 738 308 738 q 537 692 468 738 q 646 581 606 646 l 646 1014 l 768 1014 l 768 150 q 807 106 768 107 l 807 0 q 776 -4 788 -3 q 753 -6 764 -6 q 690 19 717 -6 q 663 75 663 43 l 663 136 q 548 26 619 65 q 397 -14 476 -14 m 426 92 q 495 104 460 92 q 562 139 531 117 q 616 191 593 161 q 646 254 639 221 l 646 463 q 608 528 633 497 q 552 583 583 560 q 485 619 521 606 q 415 632 450 632 q 317 609 361 632 q 242 548 274 586 q 194 460 211 510 q 178 360 178 411 q 197 256 178 306 q 250 171 217 207 q 328 113 283 135 q 426 92 374 92 m 361 -253 l 361 -106 l 472 -106 l 472 -253 l 361 -253 z "
    },
    "ẹ": {
      "ha": 821,
      "x_min": 50,
      "x_max": 783,
      "o": "m 419 -14 q 269 16 338 -14 q 153 97 201 46 q 77 217 104 149 q 50 363 50 286 q 77 507 50 439 q 153 626 104 575 q 271 708 203 678 q 421 738 339 738 q 570 707 503 738 q 685 626 638 676 q 758 508 732 575 q 783 368 783 440 q 783 340 783 353 q 781 321 782 328 l 179 321 q 204 222 183 267 q 258 146 225 178 q 334 96 292 114 q 424 78 376 78 q 489 87 457 78 q 549 111 521 96 q 598 149 576 126 q 631 199 619 171 l 736 169 q 687 96 718 129 q 615 38 656 63 q 524 0 574 14 q 419 -14 474 -14 m 668 411 q 642 506 664 463 q 588 581 621 550 q 513 628 556 611 q 421 646 469 646 q 329 628 372 646 q 253 580 286 611 q 201 506 221 549 q 176 411 181 463 l 668 411 m 368 -253 l 368 -106 l 479 -106 l 479 -253 l 368 -253 z "
    },
    "ȅ": {
      "ha": 821,
      "x_min": 50,
      "x_max": 783,
      "o": "m 419 -14 q 269 16 338 -14 q 153 97 201 46 q 77 217 104 149 q 50 363 50 286 q 77 507 50 439 q 153 626 104 575 q 271 708 203 678 q 421 738 339 738 q 570 707 503 738 q 685 626 638 676 q 758 508 732 575 q 783 368 783 440 q 783 340 783 353 q 781 321 782 328 l 179 321 q 204 222 183 267 q 258 146 225 178 q 334 96 292 114 q 424 78 376 78 q 489 87 457 78 q 549 111 521 96 q 598 149 576 126 q 631 199 619 171 l 736 169 q 687 96 718 129 q 615 38 656 63 q 524 0 574 14 q 419 -14 474 -14 m 668 411 q 642 506 664 463 q 588 581 621 550 q 513 628 556 611 q 421 646 469 646 q 329 628 372 646 q 253 580 286 611 q 201 506 221 549 q 176 411 181 463 l 668 411 m 386 1014 l 492 1014 l 567 874 l 503 846 l 386 1014 m 197 1014 l 303 1014 l 378 874 l 314 846 l 197 1014 z "
    },
    "ȇ": {
      "ha": 821,
      "x_min": 50,
      "x_max": 783,
      "o": "m 419 -14 q 269 16 338 -14 q 153 97 201 46 q 77 217 104 149 q 50 363 50 286 q 77 507 50 439 q 153 626 104 575 q 271 708 203 678 q 421 738 339 738 q 570 707 503 738 q 685 626 638 676 q 758 508 732 575 q 783 368 783 440 q 783 340 783 353 q 781 321 782 328 l 179 321 q 204 222 183 267 q 258 146 225 178 q 334 96 292 114 q 424 78 376 78 q 489 87 457 78 q 549 111 521 96 q 598 149 576 126 q 631 199 619 171 l 736 169 q 687 96 718 129 q 615 38 656 63 q 524 0 574 14 q 419 -14 474 -14 m 668 411 q 642 506 664 463 q 588 581 621 550 q 513 628 556 611 q 421 646 469 646 q 329 628 372 646 q 253 580 286 611 q 201 506 221 549 q 176 411 181 463 l 668 411 m 421 954 q 365 926 389 954 q 342 860 342 897 l 271 860 q 283 921 271 893 q 315 969 294 949 q 362 1002 335 990 q 421 1014 389 1014 q 480 1002 453 1014 q 527 969 507 990 q 559 921 547 949 q 571 860 571 893 l 501 860 q 474 927 497 900 q 421 954 451 954 z "
    },
    "ǵ": {
      "ha": 865,
      "x_min": 51,
      "x_max": 767,
      "o": "m 386 -8 q 251 22 313 -8 q 144 104 189 53 q 76 222 100 156 q 51 361 51 289 q 76 506 51 438 q 144 626 100 575 q 251 708 189 678 q 388 738 313 738 q 546 693 479 738 q 658 581 613 649 l 658 725 l 767 725 l 767 8 q 738 -128 767 -69 q 658 -228 708 -187 q 541 -289 608 -268 q 397 -310 474 -310 q 197 -267 274 -310 q 68 -150 119 -225 l 139 -87 q 250 -183 182 -151 q 397 -215 318 -215 q 492 -201 447 -215 q 571 -160 538 -187 q 624 -90 604 -132 q 644 8 644 -49 l 644 136 q 595 76 624 103 q 533 30 567 49 q 463 1 500 11 q 386 -8 425 -8 m 424 92 q 499 106 463 92 q 565 142 535 119 q 617 194 596 165 q 644 254 638 224 l 644 463 q 605 531 629 500 q 550 584 581 561 q 484 619 519 607 q 413 632 449 632 q 313 608 357 632 q 239 546 269 585 q 192 458 208 507 q 175 358 175 408 q 194 256 175 304 q 247 171 214 207 q 326 113 281 135 q 424 92 371 92 m 450 846 l 369 874 l 450 1014 l 572 1014 l 450 846 z "
    },
    "ḥ": {
      "ha": 819,
      "x_min": 99,
      "x_max": 728,
      "o": "m 728 0 l 606 0 l 606 406 q 567 573 606 518 q 453 628 528 628 q 381 613 417 628 q 313 574 344 599 q 258 514 282 549 q 221 438 233 479 l 221 0 l 99 0 l 99 1014 l 221 1014 l 221 569 q 338 693 264 649 q 499 738 411 738 q 607 714 563 738 q 678 650 651 690 q 716 553 704 610 q 728 433 728 497 l 728 0 m 363 -253 l 363 -106 l 474 -106 l 474 -253 l 363 -253 z "
    },
    "ị": {
      "ha": 319,
      "x_min": 99,
      "x_max": 221,
      "o": "m 99 0 l 99 725 l 221 725 l 221 0 l 99 0 m 99 861 l 99 1014 l 221 1014 l 221 861 l 99 861 m 103 -253 l 103 -106 l 214 -106 l 214 -253 l 103 -253 z "
    },
    "ȉ": {
      "ha": 319,
      "x_min": -50,
      "x_max": 319,
      "o": "m 99 0 l 99 725 l 221 725 l 221 0 l 99 0 m 139 1014 l 244 1014 l 319 874 l 256 846 l 139 1014 m -50 1014 l 56 1014 l 131 874 l 67 846 l -50 1014 z "
    },
    "ȋ": {
      "ha": 319,
      "x_min": 11,
      "x_max": 311,
      "o": "m 99 0 l 99 725 l 221 725 l 221 0 l 99 0 m 161 954 q 106 926 129 954 q 82 860 82 897 l 11 860 q 23 921 11 893 q 55 969 35 949 q 102 1002 75 990 q 161 1014 129 1014 q 220 1002 193 1014 q 267 969 247 990 q 299 921 288 949 q 311 860 311 893 l 242 860 q 215 927 238 900 q 161 954 192 954 z "
    },
    "ọ": {
      "ha": 832,
      "x_min": 50,
      "x_max": 782,
      "o": "m 415 -14 q 266 17 333 -14 q 151 99 199 47 q 76 218 103 150 q 50 361 50 286 q 77 506 50 438 q 152 625 104 574 q 267 707 200 676 q 415 738 335 738 q 564 707 496 738 q 680 625 632 676 q 755 506 728 574 q 782 361 782 438 q 756 218 782 286 q 681 99 729 150 q 565 17 632 47 q 415 -14 497 -14 m 175 360 q 194 254 175 303 q 245 169 213 206 q 322 113 278 133 q 415 92 365 92 q 509 113 465 92 q 586 170 553 133 q 638 256 619 207 q 657 363 657 306 q 638 467 657 418 q 586 553 619 517 q 509 611 553 590 q 415 632 465 632 q 322 610 365 632 q 245 552 278 589 q 194 466 213 515 q 175 360 175 417 m 363 -253 l 363 -106 l 474 -106 l 474 -253 l 363 -253 z "
    },
    "ȍ": {
      "ha": 832,
      "x_min": 50,
      "x_max": 782,
      "o": "m 415 -14 q 266 17 333 -14 q 151 99 199 47 q 76 218 103 150 q 50 361 50 286 q 77 506 50 438 q 152 625 104 574 q 267 707 200 676 q 415 738 335 738 q 564 707 496 738 q 680 625 632 676 q 755 506 728 574 q 782 361 782 438 q 756 218 782 286 q 681 99 729 150 q 565 17 632 47 q 415 -14 497 -14 m 175 360 q 194 254 175 303 q 245 169 213 206 q 322 113 278 133 q 415 92 365 92 q 509 113 465 92 q 586 170 553 133 q 638 256 619 207 q 657 363 657 306 q 638 467 657 418 q 586 553 619 517 q 509 611 553 590 q 415 632 465 632 q 322 610 365 632 q 245 552 278 589 q 194 466 213 515 q 175 360 175 417 m 376 1014 l 482 1014 l 557 874 l 493 846 l 376 1014 m 188 1014 l 293 1014 l 368 874 l 304 846 l 188 1014 z "
    },
    "ȏ": {
      "ha": 832,
      "x_min": 50,
      "x_max": 782,
      "o": "m 415 -14 q 266 17 333 -14 q 151 99 199 47 q 76 218 103 150 q 50 361 50 286 q 77 506 50 438 q 152 625 104 574 q 267 707 200 676 q 415 738 335 738 q 564 707 496 738 q 680 625 632 676 q 755 506 728 574 q 782 361 782 438 q 756 218 782 286 q 681 99 729 150 q 565 17 632 47 q 415 -14 497 -14 m 175 360 q 194 254 175 303 q 245 169 213 206 q 322 113 278 133 q 415 92 365 92 q 509 113 465 92 q 586 170 553 133 q 638 256 619 207 q 657 363 657 306 q 638 467 657 418 q 586 553 619 517 q 509 611 553 590 q 415 632 465 632 q 322 610 365 632 q 245 552 278 589 q 194 466 213 515 q 175 360 175 417 m 415 954 q 360 926 383 954 q 336 860 336 897 l 265 860 q 277 921 265 893 q 309 969 289 949 q 356 1002 329 990 q 415 1014 383 1014 q 474 1002 447 1014 q 522 969 501 990 q 553 921 542 949 q 565 860 565 893 l 496 860 q 469 927 492 900 q 415 954 446 954 z "
    },
    "ṛ": {
      "ha": 504,
      "x_min": 99,
      "x_max": 482,
      "o": "m 482 618 q 320 571 390 615 q 221 447 250 526 l 221 0 l 99 0 l 99 725 l 213 725 l 213 557 q 311 678 250 632 q 442 731 372 725 q 465 731 456 731 q 482 729 475 731 l 482 618 m 106 -253 l 106 -106 l 217 -106 l 217 -253 l 106 -253 z "
    },
    "ȑ": {
      "ha": 504,
      "x_min": 76,
      "x_max": 482,
      "o": "m 482 618 q 320 571 390 615 q 221 447 250 526 l 221 0 l 99 0 l 99 725 l 213 725 l 213 557 q 311 678 250 632 q 442 731 372 725 q 465 731 456 731 q 482 729 475 731 l 482 618 m 265 1014 l 371 1014 l 446 874 l 382 846 l 265 1014 m 76 1014 l 182 1014 l 257 874 l 193 846 l 76 1014 z "
    },
    "ȓ": {
      "ha": 504,
      "x_min": 99,
      "x_max": 482,
      "o": "m 482 618 q 320 571 390 615 q 221 447 250 526 l 221 0 l 99 0 l 99 725 l 213 725 l 213 557 q 311 678 250 632 q 442 731 372 725 q 465 731 456 731 q 482 729 475 731 l 482 618 m 289 954 q 233 926 257 954 q 210 860 210 897 l 139 860 q 151 921 139 893 q 183 969 163 949 q 230 1002 203 990 q 289 1014 257 1014 q 348 1002 321 1014 q 395 969 375 990 q 427 921 415 949 q 439 860 439 893 l 369 860 q 342 927 365 900 q 289 954 319 954 z "
    },
    "ṣ": {
      "ha": 686,
      "x_min": 35,
      "x_max": 640,
      "o": "m 353 -14 q 181 13 265 -14 q 35 92 96 40 l 88 174 q 215 101 151 125 q 350 76 279 76 q 476 108 429 76 q 522 196 522 139 q 510 241 522 222 q 472 274 497 260 q 408 299 447 288 q 318 322 369 310 q 206 354 253 339 q 128 390 158 369 q 83 440 97 411 q 69 513 69 469 q 91 609 69 567 q 150 680 113 651 q 238 723 188 708 q 347 738 289 738 q 500 711 429 738 q 619 642 571 685 l 564 568 q 461 628 518 608 q 344 649 404 649 q 231 620 278 649 q 185 529 185 592 q 194 488 185 504 q 224 458 203 471 q 277 436 244 446 q 356 415 310 426 q 481 381 428 399 q 570 340 535 364 q 623 285 606 317 q 640 207 640 253 q 563 46 640 106 q 353 -14 485 -14 m 285 -253 l 285 -106 l 396 -106 l 396 -253 l 285 -253 z "
    },
    "ṭ": {
      "ha": 489,
      "x_min": 35,
      "x_max": 474,
      "o": "m 474 36 q 444 23 463 31 q 403 8 426 15 q 353 -5 381 0 q 297 -10 326 -10 q 182 27 231 -10 q 133 142 133 64 l 133 629 l 35 629 l 35 725 l 133 725 l 133 967 l 256 967 l 256 725 l 418 725 l 418 629 l 256 629 l 256 179 q 282 121 258 139 q 338 103 306 103 q 403 115 374 103 q 444 133 433 126 l 474 36 m 233 -253 l 233 -106 l 344 -106 l 344 -253 l 233 -253 z "
    },
    "ụ": {
      "ha": 835,
      "x_min": 92,
      "x_max": 768,
      "o": "m 322 -14 q 150 63 208 -14 q 92 290 92 139 l 92 725 l 214 725 l 214 314 q 368 92 214 92 q 509 140 443 92 q 607 271 575 188 l 607 725 l 729 725 l 729 150 q 768 106 729 107 l 768 0 q 735 -3 747 -3 q 713 -4 724 -4 q 652 17 676 -4 q 626 71 628 39 l 624 156 q 496 30 575 74 q 322 -14 417 -14 m 344 -253 l 344 -106 l 456 -106 l 456 -253 l 344 -253 z "
    },
    "ȕ": {
      "ha": 835,
      "x_min": 92,
      "x_max": 768,
      "o": "m 322 -14 q 150 63 208 -14 q 92 290 92 139 l 92 725 l 214 725 l 214 314 q 368 92 214 92 q 509 140 443 92 q 607 271 575 188 l 607 725 l 729 725 l 729 150 q 768 106 729 107 l 768 0 q 735 -3 747 -3 q 713 -4 724 -4 q 652 17 676 -4 q 626 71 628 39 l 624 156 q 496 30 575 74 q 322 -14 417 -14 m 376 1014 l 482 1014 l 557 874 l 493 846 l 376 1014 m 188 1014 l 293 1014 l 368 874 l 304 846 l 188 1014 z "
    },
    "ȗ": {
      "ha": 835,
      "x_min": 92,
      "x_max": 768,
      "o": "m 322 -14 q 150 63 208 -14 q 92 290 92 139 l 92 725 l 214 725 l 214 314 q 368 92 214 92 q 509 140 443 92 q 607 271 575 188 l 607 725 l 729 725 l 729 150 q 768 106 729 107 l 768 0 q 735 -3 747 -3 q 713 -4 724 -4 q 652 17 676 -4 q 626 71 628 39 l 624 156 q 496 30 575 74 q 322 -14 417 -14 m 407 954 q 351 926 375 954 q 328 860 328 897 l 257 860 q 269 921 257 893 q 301 969 281 949 q 348 1002 321 990 q 407 1014 375 1014 q 466 1002 439 1014 q 513 969 493 990 q 545 921 533 949 q 557 860 557 893 l 488 860 q 460 927 483 900 q 407 954 438 954 z "
    },
    "ẓ": {
      "ha": 685,
      "x_min": 42,
      "x_max": 638,
      "o": "m 42 79 l 506 636 l 54 636 l 54 725 l 636 725 l 636 646 l 175 89 l 638 89 l 638 0 l 42 0 l 42 79 m 282 -253 l 282 -106 l 393 -106 l 393 -253 l 282 -253 z "
    },
    "∆": {
      "ha": 858,
      "x_min": 11,
      "x_max": 847,
      "o": "m 847 93 l 847 0 l 11 0 l 11 93 l 379 986 l 482 986 l 847 93 m 710 111 l 431 842 l 150 111 l 710 111 z "
    },
    "Δ": {
      "ha": 899,
      "x_min": 31,
      "x_max": 867,
      "o": "m 867 93 l 867 0 l 31 0 l 31 93 l 399 986 l 501 986 l 867 93 m 729 111 l 450 842 l 169 111 l 729 111 z "
    },
    "∏": {
      "ha": 1007,
      "x_min": 44,
      "x_max": 963,
      "o": "m 733 875 l 274 875 l 274 -125 l 156 -125 l 156 875 l 44 875 l 44 986 l 963 986 l 963 875 l 851 875 l 851 -125 l 733 -125 l 733 875 z "
    },
    "∑": {
      "ha": 758,
      "x_min": 44,
      "x_max": 711,
      "o": "m 690 885 l 221 885 l 221 879 l 486 513 l 192 117 l 192 111 l 711 111 l 711 0 l 44 0 l 44 88 l 354 494 l 54 908 l 54 986 l 690 986 l 690 885 z "
    },
    "√": {
      "ha": 644,
      "x_min": 14,
      "x_max": 592,
      "o": "m 14 507 l 232 507 l 319 107 l 475 1097 l 592 1097 l 381 0 l 250 0 l 131 418 l 14 418 l 14 507 z "
    },
    "∞": {
      "ha": 953,
      "x_min": 60,
      "x_max": 892,
      "o": "m 282 718 q 351 708 321 718 q 403 680 381 697 q 444 640 426 663 q 476 590 461 617 q 509 640 492 617 q 549 680 526 663 q 601 708 572 697 q 671 718 631 718 q 762 700 721 718 q 832 651 803 682 q 876 577 861 619 q 892 488 892 535 q 875 399 892 440 q 828 326 858 357 q 758 276 799 294 q 669 258 717 258 q 551 292 594 258 q 479 374 508 326 q 407 292 451 326 q 282 258 363 258 q 200 276 240 258 q 128 326 160 294 q 78 399 97 357 q 60 489 60 442 q 76 578 60 536 q 123 651 93 619 q 194 700 153 682 q 282 718 235 718 m 282 356 q 334 366 311 356 q 376 394 357 376 q 409 436 394 413 q 438 486 424 460 q 409 537 424 513 q 376 580 394 561 q 335 609 358 599 q 282 619 313 619 q 238 612 260 619 q 197 589 215 604 q 168 549 179 574 q 157 489 157 524 q 168 428 157 453 q 197 387 179 403 q 238 363 215 371 q 282 356 260 356 m 671 356 q 715 363 693 356 q 755 387 738 371 q 783 428 772 403 q 794 489 794 453 q 783 549 794 524 q 755 589 772 574 q 715 612 738 604 q 671 619 693 619 q 616 608 639 619 q 576 578 593 597 q 544 534 558 560 q 518 481 531 508 q 578 392 544 429 q 671 356 613 356 z "
    },
    "∂": {
      "ha": 781,
      "x_min": 36,
      "x_max": 713,
      "o": "m 340 -14 q 218 8 274 -14 q 122 69 163 31 q 58 159 81 107 q 36 271 36 211 q 63 397 36 336 q 138 503 90 457 q 246 576 185 549 q 376 603 307 603 q 513 567 456 603 q 592 472 571 532 q 596 531 594 503 q 597 582 597 558 q 583 726 597 668 q 543 820 569 785 q 479 871 517 856 q 396 886 442 886 q 283 866 338 886 q 201 814 229 846 l 133 888 q 251 966 178 939 q 407 993 324 993 q 635 890 558 993 q 713 554 713 788 q 685 308 713 414 q 609 130 658 201 q 492 22 560 58 q 340 -14 424 -14 m 343 92 q 430 110 389 92 q 502 159 471 128 q 551 231 533 190 q 569 317 569 272 q 555 390 569 356 q 515 450 540 425 q 454 490 489 475 q 379 504 419 504 q 294 486 335 504 q 222 438 253 468 q 172 367 190 407 q 153 281 153 326 q 167 206 153 240 q 208 147 182 172 q 268 106 233 121 q 343 92 303 92 z "
    },
    "π": {
      "ha": 846,
      "x_min": 35,
      "x_max": 810,
      "o": "m 264 614 l 264 0 l 146 0 l 146 614 l 35 614 l 35 725 l 786 725 l 786 614 l 633 614 l 633 188 q 655 124 633 147 q 715 101 676 101 q 751 106 731 101 q 790 118 772 111 l 810 19 q 738 -1 779 7 q 664 -10 696 -10 q 556 31 596 -10 q 515 143 515 71 l 515 614 l 264 614 z "
    },
    "Ω": {
      "ha": 1056,
      "x_min": 61,
      "x_max": 994,
      "o": "m 61 110 l 310 110 q 138 274 201 171 q 75 507 75 378 q 110 691 75 603 q 205 846 144 779 q 348 953 265 913 q 528 993 431 993 q 708 953 625 993 q 851 846 790 913 q 946 691 911 779 q 981 507 981 603 q 917 274 981 378 q 746 110 854 171 l 994 110 l 994 0 l 593 0 l 593 110 q 701 170 653 129 q 784 265 750 211 q 836 382 818 319 q 854 507 854 444 q 831 643 854 576 q 766 763 808 710 q 663 847 724 815 q 528 879 603 879 q 392 847 453 879 q 290 763 332 815 q 224 643 247 710 q 201 507 201 576 q 219 382 201 444 q 272 265 238 319 q 354 170 306 211 q 463 110 403 129 l 463 0 l 61 0 l 61 110 z "
    },
    "Ω": {
      "ha": 1056,
      "x_min": 61,
      "x_max": 994,
      "o": "m 61 110 l 310 110 q 138 274 201 171 q 75 507 75 378 q 110 691 75 603 q 205 846 144 779 q 348 953 265 913 q 528 993 431 993 q 708 953 625 993 q 851 846 790 913 q 946 691 911 779 q 981 507 981 603 q 917 274 981 378 q 746 110 854 171 l 994 110 l 994 0 l 593 0 l 593 110 q 701 170 653 129 q 784 265 750 211 q 836 382 818 319 q 854 507 854 444 q 831 643 854 576 q 766 763 808 710 q 663 847 724 815 q 528 879 603 879 q 392 847 453 879 q 290 763 332 815 q 224 643 247 710 q 201 507 201 576 q 219 382 201 444 q 272 265 238 319 q 354 170 306 211 q 463 110 403 129 l 463 0 l 61 0 l 61 110 z "
    },
    "℮": {
      "ha": 832,
      "x_min": 58,
      "x_max": 790,
      "o": "m 424 38 q 583 68 519 38 q 686 140 646 99 l 722 101 q 601 19 674 53 q 424 -14 528 -14 q 274 17 342 -14 q 159 99 207 47 q 85 218 111 150 q 58 361 58 286 q 85 506 58 438 q 160 625 113 574 q 276 707 208 676 q 424 738 343 738 q 572 707 504 738 q 688 624 640 676 q 763 503 736 572 q 790 354 790 433 l 207 354 l 207 146 q 303 67 247 96 q 424 38 358 38 m 424 686 q 303 656 358 686 q 207 575 247 626 l 207 410 l 643 410 l 643 574 q 547 656 603 626 q 424 686 490 686 z "
    },
    "∫": {
      "ha": 439,
      "x_min": 11,
      "x_max": 429,
      "o": "m 135 986 q 170 1095 132 1051 q 282 1139 208 1139 q 356 1131 314 1139 q 429 1110 397 1122 l 400 1025 q 360 1037 381 1032 q 324 1042 339 1042 q 265 1019 288 1042 q 246 956 243 996 l 303 -79 q 268 -192 307 -151 q 157 -232 229 -232 q 84 -224 125 -232 q 11 -203 43 -215 l 40 -118 q 80 -130 60 -125 q 115 -135 100 -135 q 174 -112 151 -135 q 193 -49 196 -89 l 135 986 z "
    },
    "◊": {
      "ha": 725,
      "x_min": 39,
      "x_max": 686,
      "o": "m 428 1014 l 686 508 l 428 0 l 297 0 l 39 508 l 297 1014 l 428 1014 m 576 492 l 361 919 l 160 521 l 374 90 l 576 492 z "
    },
    "ˉ": {
      "ha": 560,
      "x_min": 78,
      "x_max": 483,
      "o": "m 78 908 l 78 989 l 483 989 l 483 908 l 78 908 z "
    },
    "ℓ": {
      "ha": 457,
      "x_min": 94,
      "x_max": 457,
      "o": "m 296 101 q 333 106 313 101 q 374 118 354 111 l 393 19 q 321 -1 363 7 q 247 -10 279 -10 q 135 31 175 -10 q 94 143 94 71 l 94 847 q 109 919 94 886 q 149 976 124 951 q 208 1014 174 1000 q 282 1028 242 1028 q 409 978 361 1028 q 457 847 457 928 q 435 723 457 793 q 378 582 414 653 q 297 446 343 511 q 203 335 251 381 l 203 188 q 228 124 203 147 q 296 101 253 101 m 358 839 q 339 908 358 883 q 283 932 319 932 q 225 908 247 932 q 203 847 203 885 l 203 463 q 261 549 233 500 q 310 651 289 599 q 345 752 332 703 q 358 839 358 801 z "
    },
    "Ђ": {
      "ha": 988,
      "x_min": 24,
      "x_max": 950,
      "o": "m 281 875 l 24 875 l 24 986 l 788 986 l 788 875 l 406 875 l 406 539 q 517 601 453 579 q 653 624 581 624 q 872 540 793 624 q 950 296 950 457 q 879 66 950 146 q 665 -14 808 -14 q 500 17 579 -14 l 536 124 q 606 99 576 106 q 664 92 636 92 q 781 142 743 92 q 818 297 818 193 q 775 460 818 408 q 636 513 732 513 q 406 417 510 513 l 406 0 l 281 0 l 281 875 z "
    },
    "Ѓ": {
      "ha": 713,
      "x_min": 121,
      "x_max": 689,
      "o": "m 436 1104 l 356 1132 l 436 1272 l 558 1272 l 436 1104 m 689 875 l 246 875 l 246 0 l 121 0 l 121 986 l 689 986 l 689 875 z "
    },
    "Є": {
      "ha": 974,
      "x_min": 56,
      "x_max": 938,
      "o": "m 938 221 q 872 123 913 165 q 780 51 832 81 q 665 7 728 22 q 532 -8 601 -8 q 334 36 422 -8 q 184 152 246 81 q 89 315 122 224 q 56 500 56 406 q 86 677 56 589 q 177 835 117 765 q 328 949 238 906 q 539 992 419 992 q 672 976 613 992 q 778 931 732 960 q 860 863 825 903 q 919 776 896 824 l 821 713 q 765 792 797 760 q 694 843 732 824 q 614 871 656 863 q 533 879 572 879 q 390 852 451 879 q 286 780 329 825 q 219 676 243 735 q 186 556 194 618 l 676 556 l 676 451 l 183 451 q 218 318 190 381 q 292 208 246 256 q 399 132 338 160 q 538 104 461 104 q 621 114 578 104 q 703 145 664 124 q 777 199 743 167 q 833 278 811 232 l 938 221 z "
    },
    "Ѕ": {
      "ha": 846,
      "x_min": 40,
      "x_max": 800,
      "o": "m 697 779 q 653 817 681 799 q 590 849 625 835 q 515 873 556 864 q 429 882 474 882 q 260 839 314 882 q 207 721 207 796 q 222 654 207 681 q 270 609 238 628 q 351 576 303 590 q 467 547 400 563 q 605 509 543 531 q 710 456 667 488 q 777 378 754 424 q 800 265 800 332 q 772 142 800 194 q 697 56 744 90 q 583 6 649 22 q 442 -10 518 -10 q 226 26 328 -10 q 40 129 124 61 l 100 235 q 158 188 122 211 q 238 145 193 164 q 335 115 283 126 q 444 103 388 103 q 608 140 550 103 q 667 253 667 178 q 648 323 667 294 q 593 372 629 351 q 503 409 557 393 q 382 442 450 425 q 250 481 307 460 q 155 531 193 501 q 97 601 117 560 q 78 701 78 643 q 104 826 78 772 q 178 918 131 881 q 290 974 225 956 q 432 993 356 993 q 613 963 532 993 q 756 881 693 932 l 697 779 z "
    },
    "І": {
      "ha": 367,
      "x_min": 121,
      "x_max": 246,
      "o": "m 121 0 l 121 986 l 246 986 l 246 0 l 121 0 z "
    },
    "Ї": {
      "ha": 367,
      "x_min": 19,
      "x_max": 347,
      "o": "m 121 0 l 121 986 l 246 986 l 246 0 l 121 0 m 19 1126 l 19 1268 l 122 1268 l 122 1126 l 19 1126 m 244 1126 l 244 1268 l 347 1268 l 347 1126 l 244 1126 z "
    },
    "Ј": {
      "ha": 676,
      "x_min": 17,
      "x_max": 567,
      "o": "m 49 147 q 124 113 76 128 q 231 97 171 97 q 343 122 301 97 q 406 197 385 147 q 435 318 428 246 q 442 485 442 390 l 442 986 l 567 986 l 567 485 q 556 280 567 372 q 510 122 546 188 q 409 21 475 57 q 231 -15 343 -15 q 17 46 106 -15 l 49 147 z "
    },
    "Љ": {
      "ha": 1392,
      "x_min": 10,
      "x_max": 1353,
      "o": "m 10 111 q 65 122 39 113 q 114 154 92 131 q 156 220 136 178 q 192 329 175 263 q 222 491 208 396 q 246 717 235 586 l 268 986 l 790 986 l 790 581 l 1064 581 q 1176 562 1124 581 q 1267 507 1228 543 q 1330 416 1307 471 q 1353 290 1353 361 q 1330 165 1353 219 q 1267 74 1307 110 q 1176 19 1228 38 q 1064 0 1124 0 l 665 0 l 665 875 l 385 875 l 371 711 q 329 383 354 519 q 264 160 304 247 q 167 31 224 72 q 32 -10 111 -10 l 10 111 m 1064 108 q 1185 158 1143 108 q 1226 290 1226 207 q 1185 423 1226 374 q 1064 472 1143 472 l 790 472 l 790 108 l 1064 108 z "
    },
    "Њ": {
      "ha": 1446,
      "x_min": 121,
      "x_max": 1407,
      "o": "m 121 986 l 246 986 l 246 581 l 719 581 l 719 986 l 844 986 l 844 581 l 1118 581 q 1230 562 1178 581 q 1322 507 1282 543 q 1384 416 1361 471 q 1407 290 1407 361 q 1384 165 1407 219 q 1322 74 1361 110 q 1230 19 1282 38 q 1118 0 1178 0 l 719 0 l 719 469 l 246 469 l 246 0 l 121 0 l 121 986 m 1118 108 q 1239 158 1197 108 q 1281 290 1281 207 q 1239 423 1281 374 q 1118 472 1197 472 l 844 472 l 844 108 l 1118 108 z "
    },
    "Ћ": {
      "ha": 996,
      "x_min": 24,
      "x_max": 940,
      "o": "m 818 332 q 781 472 818 431 q 657 513 743 513 q 520 487 583 513 q 406 417 457 461 l 406 0 l 281 0 l 281 875 l 24 875 l 24 986 l 788 986 l 788 875 l 406 875 l 406 538 q 524 601 454 578 q 671 624 593 624 q 867 559 794 624 q 940 360 940 494 l 940 0 l 818 0 l 818 332 z "
    },
    "Ќ": {
      "ha": 865,
      "x_min": 121,
      "x_max": 869,
      "o": "m 246 557 l 371 557 l 694 986 l 838 986 l 486 510 l 869 0 l 726 0 l 385 446 l 246 446 l 246 0 l 121 0 l 121 986 l 246 986 l 246 557 m 478 1104 l 397 1132 l 478 1272 l 600 1272 l 478 1104 z "
    },
    "Ѝ": {
      "ha": 1006,
      "x_min": 121,
      "x_max": 919,
      "o": "m 246 190 l 817 986 l 919 986 l 919 0 l 794 0 l 794 782 l 233 0 l 121 0 l 121 986 l 246 986 l 246 190 m 364 1274 l 485 1274 l 567 1133 l 488 1106 l 364 1274 z "
    },
    "Ў": {
      "ha": 865,
      "x_min": 26,
      "x_max": 844,
      "o": "m 236 -10 q 178 -5 210 -10 q 124 10 146 0 l 124 117 q 176 103 147 107 q 226 99 204 99 q 273 105 251 99 q 313 128 294 111 q 349 172 332 144 q 385 243 367 200 l 26 986 l 158 986 l 443 379 l 713 986 l 844 986 l 497 236 q 438 123 467 169 q 378 47 408 76 q 313 3 347 17 q 236 -10 278 -10 m 443 1110 q 292 1152 350 1110 q 232 1272 235 1194 l 306 1272 q 346 1206 306 1235 q 444 1178 386 1178 q 538 1205 500 1178 q 582 1272 575 1232 l 654 1272 q 594 1152 651 1194 q 443 1110 536 1110 z "
    },
    "Џ": {
      "ha": 968,
      "x_min": 122,
      "x_max": 846,
      "o": "m 122 986 l 247 986 l 247 111 l 721 111 l 721 986 l 846 986 l 846 0 l 546 0 l 546 -257 l 421 -257 l 421 0 l 122 0 l 122 986 z "
    },
    "А": {
      "ha": 940,
      "x_min": 14,
      "x_max": 926,
      "o": "m 418 986 l 524 986 l 926 0 l 793 0 l 676 289 l 263 289 l 147 0 l 14 0 l 418 986 m 649 386 l 471 842 l 288 386 l 649 386 z "
    },
    "Б": {
      "ha": 914,
      "x_min": 121,
      "x_max": 864,
      "o": "m 121 986 l 814 986 l 814 875 l 246 875 l 246 581 l 575 581 q 687 562 635 581 q 778 507 739 543 q 841 416 818 471 q 864 290 864 361 q 841 165 864 219 q 779 74 818 110 q 688 19 740 38 q 575 0 635 0 l 121 0 l 121 986 m 575 108 q 696 158 654 108 q 738 290 738 207 q 697 423 738 374 q 575 472 656 472 l 246 472 l 246 108 l 575 108 z "
    },
    "В": {
      "ha": 935,
      "x_min": 93,
      "x_max": 850,
      "o": "m 850 254 q 827 150 850 197 q 765 69 804 103 q 673 18 725 36 q 561 0 621 0 l 93 0 l 93 986 l 583 986 q 676 964 635 986 q 747 906 718 942 q 792 826 776 871 q 808 735 808 781 q 772 599 808 661 q 667 506 735 536 q 801 413 751 481 q 850 254 850 346 m 724 276 q 712 341 724 310 q 680 396 700 372 q 632 433 660 419 q 571 447 604 447 l 218 447 l 218 108 l 561 108 q 625 122 596 108 q 676 159 654 136 q 711 213 699 182 q 724 276 724 243 m 218 878 l 218 549 l 532 549 q 593 562 565 549 q 641 597 621 575 q 673 649 661 619 q 685 713 685 679 q 674 778 685 747 q 644 831 663 808 q 598 865 625 853 q 540 878 571 878 l 218 878 z "
    },
    "Г": {
      "ha": 713,
      "x_min": 121,
      "x_max": 689,
      "o": "m 689 875 l 246 875 l 246 0 l 121 0 l 121 986 l 689 986 l 689 875 z "
    },
    "Д": {
      "ha": 994,
      "x_min": 25,
      "x_max": 971,
      "o": "m 25 111 l 38 111 q 93 122 67 113 q 142 154 119 131 q 183 220 164 178 q 219 329 203 263 q 249 491 236 396 q 274 717 263 586 l 296 986 l 818 986 l 818 111 l 971 111 l 971 -258 l 860 -258 l 860 0 l 136 0 l 136 -258 l 25 -258 l 25 111 m 693 111 l 693 875 l 413 875 l 399 711 q 340 319 378 463 q 238 111 301 175 l 693 111 z "
    },
    "Е": {
      "ha": 842,
      "x_min": 121,
      "x_max": 790,
      "o": "m 790 111 l 790 0 l 121 0 l 121 986 l 778 986 l 778 875 l 246 875 l 246 556 l 708 556 l 708 451 l 246 451 l 246 111 l 790 111 z "
    },
    "Ж": {
      "ha": 1350,
      "x_min": 3,
      "x_max": 1347,
      "o": "m 331 510 l 35 986 l 178 986 l 439 557 l 606 557 l 606 986 l 744 986 l 744 557 l 911 557 l 1172 986 l 1315 986 l 1019 510 l 1347 0 l 1204 0 l 931 446 l 744 446 l 744 0 l 606 0 l 606 446 l 419 446 l 146 0 l 3 0 l 331 510 z "
    },
    "З": {
      "ha": 721,
      "x_min": 31,
      "x_max": 664,
      "o": "m 58 869 q 170 963 106 932 q 331 993 235 993 q 544 933 468 993 q 619 760 619 874 q 578 615 619 675 q 461 536 536 554 q 608 463 553 525 q 664 300 664 400 q 638 177 664 233 q 567 80 613 121 q 458 16 521 39 q 322 -7 396 -7 q 147 33 224 -7 q 31 147 71 74 l 131 221 q 210 138 163 168 q 328 107 257 107 q 412 121 374 107 q 478 159 450 135 q 522 217 506 183 q 538 292 538 251 q 467 430 538 379 q 272 481 397 481 l 197 481 l 197 592 l 272 592 q 436 633 376 592 q 496 750 496 675 q 449 851 496 818 q 332 885 403 885 q 219 860 269 885 q 142 792 169 836 l 58 869 z "
    },
    "И": {
      "ha": 1040,
      "x_min": 121,
      "x_max": 919,
      "o": "m 246 190 l 817 986 l 919 986 l 919 0 l 794 0 l 794 782 l 233 0 l 121 0 l 121 986 l 246 986 l 246 190 z "
    },
    "Й": {
      "ha": 1040,
      "x_min": 121,
      "x_max": 919,
      "o": "m 754 1272 q 694 1152 751 1194 q 543 1110 636 1110 q 392 1152 450 1110 q 332 1272 335 1194 l 406 1272 q 446 1206 406 1235 q 544 1178 486 1178 q 638 1205 600 1178 q 682 1272 675 1232 l 754 1272 m 246 190 l 817 986 l 919 986 l 919 0 l 794 0 l 794 782 l 233 0 l 121 0 l 121 986 l 246 986 l 246 190 z "
    },
    "К": {
      "ha": 865,
      "x_min": 121,
      "x_max": 869,
      "o": "m 246 557 l 371 557 l 694 986 l 838 986 l 486 510 l 869 0 l 726 0 l 385 446 l 246 446 l 246 0 l 121 0 l 121 986 l 246 986 l 246 557 z "
    },
    "Л": {
      "ha": 913,
      "x_min": 10,
      "x_max": 790,
      "o": "m 371 711 q 329 383 354 519 q 264 160 304 247 q 167 31 224 72 q 32 -10 111 -10 l 10 111 q 65 122 39 113 q 114 154 92 131 q 156 220 136 178 q 192 329 175 263 q 222 491 208 396 q 246 717 235 586 l 268 986 l 790 986 l 790 0 l 665 0 l 665 875 l 385 875 l 371 711 z "
    },
    "М": {
      "ha": 1219,
      "x_min": 121,
      "x_max": 1099,
      "o": "m 974 0 l 974 763 l 646 178 l 575 178 l 246 763 l 246 0 l 121 0 l 121 986 l 253 986 l 610 346 l 968 986 l 1099 986 l 1099 0 l 974 0 z "
    },
    "Н": {
      "ha": 1035,
      "x_min": 121,
      "x_max": 914,
      "o": "m 914 986 l 914 0 l 789 0 l 789 449 l 246 449 l 246 0 l 121 0 l 121 986 l 246 986 l 246 560 l 789 560 l 789 986 l 914 986 z "
    },
    "О": {
      "ha": 1039,
      "x_min": 56,
      "x_max": 985,
      "o": "m 519 -7 q 330 35 415 -7 q 183 148 244 78 q 89 308 122 218 q 56 493 56 399 q 91 682 56 592 q 189 842 126 772 q 337 952 251 911 q 522 993 422 993 q 711 949 626 993 q 857 835 796 906 q 951 674 918 764 q 985 492 985 585 q 949 303 985 393 q 852 144 914 213 q 705 34 790 75 q 519 -7 619 -7 m 182 493 q 206 348 182 418 q 275 224 231 278 q 382 138 319 169 q 521 106 444 106 q 663 140 600 106 q 769 228 725 174 q 835 353 813 283 q 858 493 858 422 q 834 638 858 568 q 765 762 810 708 q 658 847 719 815 q 521 879 596 879 q 379 846 442 879 q 273 758 317 813 q 206 635 229 704 q 182 493 182 565 z "
    },
    "П": {
      "ha": 1028,
      "x_min": 121,
      "x_max": 907,
      "o": "m 121 986 l 907 986 l 907 0 l 782 0 l 782 875 l 246 875 l 246 0 l 121 0 l 121 986 z "
    },
    "Р": {
      "ha": 868,
      "x_min": 121,
      "x_max": 831,
      "o": "m 121 0 l 121 986 l 532 986 q 652 959 597 986 q 747 887 707 932 q 808 785 786 842 q 831 671 831 729 q 810 553 831 610 q 751 451 789 496 q 659 381 713 407 q 540 354 606 354 l 246 354 l 246 0 l 121 0 m 246 465 l 533 465 q 603 481 572 465 q 657 526 635 497 q 692 592 679 554 q 704 671 704 629 q 690 751 704 714 q 651 817 675 789 q 594 860 626 844 q 525 875 561 875 l 246 875 l 246 465 z "
    },
    "С": {
      "ha": 946,
      "x_min": 54,
      "x_max": 908,
      "o": "m 54 500 q 85 677 54 589 q 177 835 117 765 q 325 949 238 906 q 524 992 413 992 q 750 932 656 992 q 890 776 844 872 l 792 713 q 738 792 769 760 q 670 843 707 824 q 594 871 633 863 q 518 879 556 879 q 373 845 436 879 q 267 756 310 811 q 202 633 224 701 q 181 494 181 564 q 206 347 181 417 q 278 222 232 276 q 386 136 324 168 q 522 104 449 104 q 602 114 561 104 q 681 145 643 124 q 751 199 718 167 q 804 278 783 232 l 908 221 q 842 123 885 165 q 747 51 800 81 q 633 7 693 22 q 517 -8 574 -8 q 331 36 415 -8 q 184 152 246 81 q 88 315 122 224 q 54 500 54 406 z "
    },
    "Т": {
      "ha": 853,
      "x_min": 24,
      "x_max": 829,
      "o": "m 829 875 l 489 875 l 489 0 l 364 0 l 364 875 l 24 875 l 24 986 l 829 986 l 829 875 z "
    },
    "У": {
      "ha": 865,
      "x_min": 26,
      "x_max": 844,
      "o": "m 236 -10 q 178 -5 210 -10 q 124 10 146 0 l 124 117 q 176 103 147 107 q 228 99 204 99 q 312 128 275 99 q 385 243 349 157 l 26 986 l 158 986 l 443 379 l 713 986 l 844 986 l 497 236 q 438 123 467 169 q 378 47 408 76 q 313 3 347 17 q 236 -10 278 -10 z "
    },
    "Ф": {
      "ha": 1036,
      "x_min": 47,
      "x_max": 986,
      "o": "m 461 76 q 155 203 263 92 q 47 501 47 314 q 156 803 47 692 q 461 932 264 915 l 461 1056 l 586 1056 l 586 932 q 881 803 776 915 q 986 501 986 690 q 881 203 986 314 q 586 76 776 92 l 586 -56 l 461 -56 l 461 76 m 586 189 q 790 284 721 204 q 860 507 860 364 q 790 725 860 647 q 586 817 721 803 l 586 189 m 461 817 q 174 507 174 789 q 247 283 174 363 q 461 189 319 204 l 461 817 z "
    },
    "Х": {
      "ha": 885,
      "x_min": 4,
      "x_max": 881,
      "o": "m 143 986 l 443 575 l 743 986 l 881 986 l 510 486 l 869 0 l 732 0 l 443 397 l 154 0 l 15 0 l 375 486 l 4 986 l 143 986 z "
    },
    "Ц": {
      "ha": 1022,
      "x_min": 122,
      "x_max": 999,
      "o": "m 888 0 l 122 0 l 122 986 l 247 986 l 247 111 l 721 111 l 721 986 l 846 986 l 846 111 l 999 111 l 999 -258 l 888 -258 l 888 0 z "
    },
    "Ч": {
      "ha": 854,
      "x_min": 60,
      "x_max": 733,
      "o": "m 607 986 l 733 986 l 733 0 l 607 0 l 607 417 q 560 401 583 408 q 508 390 536 394 q 447 383 481 385 q 369 381 413 381 q 224 406 283 381 q 128 478 164 432 q 76 585 92 524 q 60 719 60 647 l 60 986 l 186 986 l 186 743 q 196 626 186 674 q 230 549 206 578 q 294 506 254 519 q 393 493 333 493 q 526 508 472 493 q 607 544 579 522 l 607 986 z "
    },
    "Ш": {
      "ha": 1314,
      "x_min": 121,
      "x_max": 1193,
      "o": "m 1193 986 l 1193 0 l 121 0 l 121 986 l 246 986 l 246 111 l 594 111 l 594 986 l 719 986 l 719 111 l 1068 111 l 1068 986 l 1193 986 z "
    },
    "Щ": {
      "ha": 1371,
      "x_min": 122,
      "x_max": 1346,
      "o": "m 1236 0 l 122 0 l 122 986 l 247 986 l 247 111 l 596 111 l 596 986 l 721 986 l 721 111 l 1069 111 l 1069 986 l 1194 986 l 1194 111 l 1346 111 l 1346 -258 l 1236 -258 l 1236 0 z "
    },
    "Ъ": {
      "ha": 1042,
      "x_min": 24,
      "x_max": 1003,
      "o": "m 24 986 l 461 986 l 461 622 l 672 622 q 802 602 742 622 q 907 543 863 582 q 977 446 951 504 q 1003 311 1003 388 q 976 176 1003 235 q 905 79 950 118 q 799 20 860 40 q 672 0 739 0 l 336 0 l 336 875 l 24 875 l 24 986 m 461 108 l 672 108 q 826 163 775 108 q 876 311 876 218 q 824 459 876 404 q 672 514 771 514 l 461 514 l 461 108 z "
    },
    "Ы": {
      "ha": 1149,
      "x_min": 121,
      "x_max": 1026,
      "o": "m 121 986 l 246 986 l 246 622 l 457 622 q 587 602 526 622 q 692 543 647 582 q 762 446 736 504 q 788 311 788 388 q 761 176 788 235 q 690 79 735 118 q 584 20 644 40 q 457 0 524 0 l 121 0 l 121 986 m 246 108 l 457 108 q 610 163 560 108 q 661 311 661 218 q 608 459 661 404 q 457 514 556 514 l 246 514 l 246 108 m 901 0 l 901 985 l 1026 985 l 1026 0 l 901 0 z "
    },
    "Ь": {
      "ha": 826,
      "x_min": 121,
      "x_max": 788,
      "o": "m 121 986 l 246 986 l 246 622 l 457 622 q 587 602 526 622 q 692 543 647 582 q 762 446 736 504 q 788 311 788 388 q 761 176 788 235 q 690 79 735 118 q 584 20 644 40 q 457 0 524 0 l 121 0 l 121 986 m 246 108 l 457 108 q 610 163 560 108 q 661 311 661 218 q 608 459 661 404 q 457 514 556 514 l 246 514 l 246 108 z "
    },
    "Э": {
      "ha": 974,
      "x_min": 36,
      "x_max": 918,
      "o": "m 442 -8 q 309 7 372 -8 q 194 51 246 22 q 101 123 142 81 q 36 221 61 165 l 140 278 q 197 199 163 232 q 270 145 231 167 q 353 114 310 124 q 436 104 396 104 q 574 132 513 104 q 682 208 636 160 q 755 318 728 256 q 789 451 782 381 l 297 451 l 297 556 l 788 556 q 754 676 779 618 q 687 780 729 735 q 583 852 644 825 q 440 879 521 879 q 359 871 400 879 q 280 843 318 863 q 208 792 242 824 q 153 713 175 760 l 54 776 q 194 931 101 871 q 435 992 288 992 q 645 949 554 992 q 797 835 736 906 q 888 677 857 765 q 918 500 918 589 q 885 315 918 406 q 790 152 851 224 q 640 36 728 81 q 442 -8 551 -8 z "
    },
    "Ю": {
      "ha": 1369,
      "x_min": 122,
      "x_max": 1311,
      "o": "m 860 -7 q 692 26 768 -7 q 558 117 615 58 q 467 259 501 176 q 425 442 432 342 l 247 442 l 247 0 l 122 0 l 122 986 l 247 986 l 247 553 l 426 553 q 471 735 435 654 q 565 874 507 817 q 699 962 624 931 q 863 993 775 993 q 1045 956 963 993 q 1187 851 1128 918 q 1278 692 1246 783 q 1311 492 1311 600 q 1277 285 1311 378 q 1183 128 1243 193 q 1040 28 1122 64 q 860 -7 957 -7 m 550 493 q 572 330 550 401 q 635 208 594 258 q 733 132 676 158 q 861 106 790 106 q 997 133 936 106 q 1099 213 1057 161 q 1163 335 1140 264 q 1185 493 1185 406 q 1161 656 1185 585 q 1094 777 1138 728 q 992 853 1051 826 q 861 879 933 879 q 731 851 789 879 q 633 774 674 824 q 572 652 593 724 q 550 493 550 581 z "
    },
    "Я": {
      "ha": 885,
      "x_min": 39,
      "x_max": 764,
      "o": "m 639 0 l 639 382 l 411 382 l 185 0 l 39 0 l 283 400 q 203 444 240 415 q 140 510 167 472 q 99 592 114 547 q 85 685 85 636 q 107 794 85 740 q 169 891 129 849 q 263 960 208 933 q 383 986 318 986 l 764 986 l 764 0 l 639 0 m 639 875 l 390 875 q 322 860 354 875 q 265 819 289 844 q 226 758 240 793 q 211 685 211 724 q 224 613 211 647 q 258 551 236 578 q 312 509 281 525 q 382 493 343 493 l 639 493 l 639 875 z "
    },
    "а": {
      "ha": 771,
      "x_min": 42,
      "x_max": 711,
      "o": "m 285 -14 q 189 3 233 -14 q 112 51 144 21 q 60 123 79 82 q 42 213 42 164 q 64 303 42 263 q 127 374 86 344 q 224 419 168 403 q 347 436 281 436 q 454 426 400 436 q 550 400 508 417 l 550 458 q 500 598 550 547 q 358 649 450 649 q 128 564 249 649 l 88 643 q 369 738 228 738 q 592 661 513 738 q 672 446 672 585 l 672 150 q 711 106 672 107 l 711 0 q 679 -4 692 -3 q 653 -6 667 -6 q 595 16 617 -6 q 569 68 574 38 l 567 119 q 444 20 518 54 q 285 -14 369 -14 m 317 78 q 438 102 382 78 q 524 167 494 126 q 550 221 550 193 l 550 328 q 365 363 461 363 q 216 324 274 363 q 158 222 158 285 q 170 165 158 192 q 203 119 182 139 q 254 89 225 100 q 317 78 283 78 z "
    },
    "б": {
      "ha": 819,
      "x_min": 75,
      "x_max": 765,
      "o": "m 450 869 q 279 774 342 842 q 197 578 217 706 q 308 666 246 636 q 443 696 371 696 q 572 669 513 696 q 674 593 631 642 q 741 478 717 544 q 765 336 765 413 q 740 194 765 258 q 668 83 714 129 q 558 12 622 38 q 414 -14 493 -14 q 161 103 247 -14 q 75 443 75 219 q 169 799 75 669 q 442 974 263 929 l 671 1029 l 693 929 l 450 869 m 200 344 q 217 242 200 289 q 263 160 233 194 q 334 106 293 125 q 424 86 375 86 q 511 104 471 86 q 580 155 551 122 q 624 233 608 188 q 640 333 640 279 q 624 435 640 389 q 578 515 607 482 q 507 567 549 549 q 415 585 465 585 q 327 567 367 585 q 260 518 288 550 q 216 442 232 486 q 200 344 200 399 z "
    },
    "в": {
      "ha": 732,
      "x_min": 104,
      "x_max": 681,
      "o": "m 469 725 q 542 712 508 725 q 600 675 575 699 q 639 619 625 651 q 653 547 653 586 q 647 499 653 524 q 630 452 642 475 q 599 410 618 429 q 551 379 579 390 q 646 317 611 363 q 681 204 681 272 q 664 120 681 158 q 617 56 647 82 q 547 15 588 29 q 456 0 506 0 l 104 0 l 104 725 l 469 725 m 421 415 q 503 445 474 415 q 533 528 533 475 q 510 603 533 572 q 431 635 486 635 l 224 635 l 224 415 l 421 415 m 442 90 q 530 126 497 90 q 563 210 563 161 q 532 290 563 256 q 444 325 501 325 l 224 325 l 224 90 l 442 90 z "
    },
    "г": {
      "ha": 589,
      "x_min": 101,
      "x_max": 563,
      "o": "m 563 633 l 221 633 l 221 0 l 101 0 l 101 725 l 563 725 l 563 633 z "
    },
    "д": {
      "ha": 822,
      "x_min": 25,
      "x_max": 776,
      "o": "m 25 106 l 67 106 q 123 136 100 114 q 163 205 146 158 q 192 328 179 251 q 217 522 204 406 l 239 725 l 690 725 l 690 106 l 776 106 l 776 -228 l 671 -228 l 671 0 l 126 0 l 126 -228 l 25 -228 l 25 106 m 571 106 l 571 629 l 351 629 l 331 472 q 287 235 311 322 q 228 106 263 149 l 571 106 z "
    },
    "е": {
      "ha": 821,
      "x_min": 50,
      "x_max": 783,
      "o": "m 419 -14 q 269 16 338 -14 q 153 97 201 46 q 77 217 104 149 q 50 363 50 286 q 77 507 50 439 q 153 626 104 575 q 271 708 203 678 q 421 738 339 738 q 570 707 503 738 q 685 626 638 676 q 758 508 732 575 q 783 368 783 440 q 783 340 783 353 q 781 321 782 328 l 179 321 q 204 222 183 267 q 258 146 225 178 q 334 96 292 114 q 424 78 376 78 q 489 87 457 78 q 549 111 521 96 q 598 149 576 126 q 631 199 619 171 l 736 169 q 687 96 718 129 q 615 38 656 63 q 524 0 574 14 q 419 -14 474 -14 m 668 411 q 642 506 664 463 q 588 581 621 550 q 513 628 556 611 q 421 646 469 646 q 329 628 372 646 q 253 580 286 611 q 201 506 221 549 q 176 411 181 463 l 668 411 z "
    },
    "ж": {
      "ha": 1057,
      "x_min": 17,
      "x_max": 1042,
      "o": "m 172 725 l 353 403 l 468 403 l 468 725 l 590 725 l 590 403 l 706 403 l 886 725 l 1021 725 l 810 372 l 1042 0 l 906 0 l 726 311 l 590 311 l 590 0 l 468 0 l 468 311 l 332 311 l 153 0 l 17 0 l 247 372 l 36 725 l 172 725 z "
    },
    "з": {
      "ha": 569,
      "x_min": 36,
      "x_max": 521,
      "o": "m 58 650 q 265 738 139 738 q 419 690 361 738 q 478 561 478 642 q 444 453 478 497 q 351 403 410 410 q 476 342 431 393 q 521 213 521 292 q 502 121 521 163 q 449 49 483 79 q 366 3 414 19 q 260 -14 318 -14 q 36 92 121 -14 l 101 176 q 172 112 133 132 q 264 92 211 92 q 367 123 331 92 q 403 213 403 154 q 356 315 403 279 q 218 350 308 350 l 169 350 l 169 443 l 218 443 q 326 472 286 443 q 365 551 365 501 q 336 617 365 593 q 257 642 307 642 q 118 581 185 642 l 58 650 z "
    },
    "и": {
      "ha": 817,
      "x_min": 101,
      "x_max": 714,
      "o": "m 221 172 l 615 725 l 714 725 l 714 0 l 594 0 l 594 542 l 207 0 l 101 0 l 101 725 l 221 725 l 221 172 z "
    },
    "й": {
      "ha": 815,
      "x_min": 101,
      "x_max": 714,
      "o": "m 636 1014 q 574 898 631 936 q 424 860 517 860 q 274 898 331 860 q 211 1014 217 936 l 285 1014 q 324 938 288 957 q 424 919 361 919 q 523 938 486 919 q 563 1014 560 957 l 636 1014 m 221 172 l 615 725 l 714 725 l 714 0 l 594 0 l 594 542 l 207 0 l 101 0 l 101 725 l 221 725 l 221 172 z "
    },
    "к": {
      "ha": 694,
      "x_min": 101,
      "x_max": 689,
      "o": "m 533 725 l 669 725 l 385 372 l 689 0 l 554 0 l 306 318 l 221 318 l 221 0 l 101 0 l 101 725 l 221 725 l 221 410 l 292 410 l 533 725 z "
    },
    "л": {
      "ha": 767,
      "x_min": 6,
      "x_max": 665,
      "o": "m 6 100 q 80 122 50 104 q 130 184 110 139 q 164 310 150 229 q 192 522 178 392 l 214 725 l 665 725 l 665 0 l 546 0 l 546 629 l 326 629 l 306 472 q 265 240 286 331 q 211 95 243 149 q 135 19 179 42 q 26 -7 90 -3 l 6 100 z "
    },
    "м": {
      "ha": 938,
      "x_min": 101,
      "x_max": 836,
      "o": "m 469 265 l 715 725 l 836 725 l 836 0 l 717 0 l 717 511 l 504 118 l 435 118 l 221 511 l 221 0 l 101 0 l 101 725 l 224 725 l 469 265 z "
    },
    "н": {
      "ha": 808,
      "x_min": 101,
      "x_max": 707,
      "o": "m 221 424 l 588 424 l 588 725 l 707 725 l 707 0 l 588 0 l 588 322 l 221 322 l 221 0 l 101 0 l 101 725 l 221 725 l 221 424 z "
    },
    "о": {
      "ha": 832,
      "x_min": 50,
      "x_max": 782,
      "o": "m 415 -14 q 266 17 333 -14 q 151 99 199 47 q 76 218 103 150 q 50 361 50 286 q 77 506 50 438 q 152 625 104 574 q 267 707 200 676 q 415 738 335 738 q 564 707 496 738 q 680 625 632 676 q 755 506 728 574 q 782 361 782 438 q 756 218 782 286 q 681 99 729 150 q 565 17 632 47 q 415 -14 497 -14 m 175 360 q 194 254 175 303 q 245 169 213 206 q 322 113 278 133 q 415 92 365 92 q 509 113 465 92 q 586 170 553 133 q 638 256 619 207 q 657 363 657 306 q 638 467 657 418 q 586 553 619 517 q 509 611 553 590 q 415 632 465 632 q 322 610 365 632 q 245 552 278 589 q 194 466 213 515 q 175 360 175 417 z "
    },
    "п": {
      "ha": 788,
      "x_min": 101,
      "x_max": 686,
      "o": "m 686 0 l 567 0 l 567 619 l 221 619 l 221 0 l 101 0 l 101 725 l 686 725 l 686 0 z "
    },
    "р": {
      "ha": 868,
      "x_min": 101,
      "x_max": 817,
      "o": "m 492 -14 q 333 31 401 -14 q 224 143 264 75 l 224 -296 l 101 -296 l 101 725 l 210 725 l 210 589 q 322 697 253 656 q 474 738 390 738 q 611 707 549 738 q 719 624 674 676 q 791 504 765 572 q 817 363 817 436 q 793 216 817 285 q 726 97 769 147 q 624 16 683 46 q 492 -14 564 -14 m 454 92 q 552 115 508 92 q 627 176 596 138 q 675 263 658 214 q 692 363 692 311 q 672 466 692 417 q 619 552 653 515 q 541 610 586 589 q 443 632 496 632 q 374 619 410 632 q 308 584 339 606 q 253 533 276 563 q 224 469 231 503 l 224 263 q 263 195 239 226 q 317 141 286 164 q 382 105 347 118 q 454 92 417 92 z "
    },
    "с": {
      "ha": 769,
      "x_min": 50,
      "x_max": 729,
      "o": "m 50 364 q 76 508 50 440 q 151 627 103 576 q 267 708 200 678 q 418 738 335 738 q 605 690 526 738 q 724 561 683 642 l 604 524 q 526 603 576 575 q 415 632 476 632 q 321 612 365 632 q 244 556 276 592 q 194 471 213 519 q 175 364 175 422 q 194 257 175 307 q 247 170 214 207 q 323 113 279 133 q 417 92 367 92 q 480 101 449 92 q 537 125 511 110 q 582 160 563 140 q 610 204 601 181 l 729 168 q 683 94 713 128 q 613 38 653 61 q 523 0 572 14 q 419 -14 474 -14 q 269 17 338 -14 q 153 99 201 47 q 77 219 104 150 q 50 364 50 288 z "
    },
    "т": {
      "ha": 664,
      "x_min": 29,
      "x_max": 635,
      "o": "m 392 0 l 272 0 l 272 619 l 29 619 l 29 725 l 635 725 l 635 619 l 392 619 l 392 0 z "
    },
    "у": {
      "ha": 757,
      "x_min": 17,
      "x_max": 732,
      "o": "m 97 -165 q 144 -194 121 -186 q 192 -203 167 -203 q 260 -158 228 -203 q 324 0 292 -114 l 17 725 l 143 725 l 390 110 l 615 725 l 732 725 l 415 -100 q 369 -201 392 -161 q 320 -266 346 -242 q 265 -300 294 -290 q 201 -310 236 -310 q 141 -301 165 -310 q 97 -272 117 -293 l 97 -165 z "
    },
    "ф": {
      "ha": 942,
      "x_min": 50,
      "x_max": 892,
      "o": "m 535 733 q 685 694 619 725 q 797 613 751 663 q 867 499 843 564 q 892 358 892 435 q 867 218 892 282 q 797 106 843 154 q 685 28 751 58 q 535 -10 619 -1 l 535 -296 l 413 -296 l 413 -11 q 259 27 326 -3 q 145 105 192 57 q 74 217 99 153 q 50 358 50 282 q 74 501 50 436 q 145 616 99 567 q 259 696 192 665 q 413 735 326 726 l 413 1014 l 535 1014 l 535 733 m 413 619 q 176 364 176 594 q 236 181 176 247 q 413 101 296 115 l 413 619 m 535 101 q 706 183 647 117 q 765 364 765 249 q 707 541 765 476 q 535 619 649 606 l 535 101 z "
    },
    "х": {
      "ha": 713,
      "x_min": 17,
      "x_max": 696,
      "o": "m 146 725 l 344 458 l 356 436 l 368 458 l 565 725 l 694 725 l 424 361 l 696 0 l 567 0 l 368 265 l 356 286 l 344 265 l 146 0 l 17 0 l 289 361 l 18 725 l 146 725 z "
    },
    "ц": {
      "ha": 801,
      "x_min": 101,
      "x_max": 785,
      "o": "m 101 725 l 221 725 l 221 106 l 533 106 l 533 725 l 653 725 l 653 106 l 785 106 l 785 -228 l 679 -228 l 679 0 l 101 0 l 101 725 z "
    },
    "ч": {
      "ha": 671,
      "x_min": 56,
      "x_max": 569,
      "o": "m 569 0 l 449 0 l 449 289 q 419 281 433 285 q 385 274 404 276 q 342 271 367 272 q 285 269 318 269 q 175 290 219 269 q 104 347 131 311 q 67 427 78 382 q 56 522 56 472 l 56 725 l 176 725 l 176 546 q 213 413 176 450 q 311 376 249 376 q 401 386 369 376 q 449 411 433 396 l 449 725 l 569 725 l 569 0 z "
    },
    "ш": {
      "ha": 1029,
      "x_min": 101,
      "x_max": 928,
      "o": "m 101 0 l 101 725 l 221 725 l 221 106 l 454 106 l 454 725 l 574 725 l 574 106 l 808 106 l 808 725 l 928 725 l 928 0 l 101 0 z "
    },
    "щ": {
      "ha": 1076,
      "x_min": 101,
      "x_max": 1060,
      "o": "m 101 725 l 221 725 l 221 106 l 454 106 l 454 725 l 574 725 l 574 106 l 808 106 l 808 725 l 928 725 l 928 106 l 1060 106 l 1060 -228 l 954 -228 l 954 0 l 101 0 l 101 725 z "
    },
    "ъ": {
      "ha": 806,
      "x_min": 29,
      "x_max": 768,
      "o": "m 378 475 l 515 475 q 608 460 563 475 q 688 416 653 446 q 746 341 724 386 q 768 235 768 296 q 746 129 768 174 q 688 56 724 85 q 607 14 653 28 q 514 0 561 0 l 258 0 l 258 619 l 29 619 l 29 725 l 378 725 l 378 475 m 514 103 q 610 135 574 103 q 647 235 647 168 q 608 338 647 303 q 515 372 568 372 l 378 372 l 378 103 l 514 103 z "
    },
    "ы": {
      "ha": 903,
      "x_min": 101,
      "x_max": 801,
      "o": "m 101 725 l 221 725 l 221 475 l 358 475 q 451 460 406 475 q 531 416 496 446 q 589 341 567 386 q 611 235 611 296 q 589 129 611 174 q 531 56 567 85 q 450 14 496 28 q 357 0 404 0 l 101 0 l 101 725 m 682 725 l 801 725 l 801 0 l 682 0 l 682 725 m 357 103 q 453 135 417 103 q 490 235 490 168 q 451 338 490 303 q 358 372 411 372 l 221 372 l 221 103 l 357 103 z "
    },
    "ь": {
      "ha": 649,
      "x_min": 101,
      "x_max": 611,
      "o": "m 101 725 l 221 725 l 221 475 l 358 475 q 451 460 406 475 q 531 416 496 446 q 589 341 567 386 q 611 235 611 296 q 589 129 611 174 q 531 56 567 85 q 450 14 496 28 q 357 0 404 0 l 101 0 l 101 725 m 357 103 q 453 135 417 103 q 490 235 490 168 q 451 338 490 303 q 358 372 411 372 l 221 372 l 221 103 l 357 103 z "
    },
    "э": {
      "ha": 751,
      "x_min": 35,
      "x_max": 701,
      "o": "m 336 -12 q 151 33 232 -12 q 35 164 69 79 l 128 207 q 167 153 143 176 q 219 114 190 129 q 279 90 247 99 q 342 82 311 82 q 428 99 388 82 q 502 147 469 115 q 556 222 535 178 q 583 319 578 265 l 222 319 l 222 417 l 581 417 q 552 506 572 464 q 501 578 532 547 q 428 626 469 608 q 338 643 388 643 q 280 637 310 643 q 222 617 250 631 q 170 581 194 603 q 128 526 146 558 l 47 575 q 156 691 83 643 q 336 739 228 739 q 489 708 421 739 q 604 624 557 676 q 676 503 651 571 q 701 363 701 435 q 676 222 701 290 q 605 102 651 154 q 490 19 558 50 q 336 -12 422 -12 z "
    },
    "ю": {
      "ha": 1033,
      "x_min": 100,
      "x_max": 981,
      "o": "m 319 418 q 355 551 328 492 q 425 653 382 611 q 524 717 468 694 q 646 740 581 740 q 783 712 721 740 q 888 632 844 683 q 956 511 932 581 q 981 361 981 442 q 955 206 981 275 q 885 88 929 136 q 778 13 840 39 q 643 -14 715 -14 q 519 9 575 -14 q 420 75 463 32 q 351 178 378 118 q 318 313 325 239 l 219 313 l 219 0 l 100 0 l 100 725 l 219 725 l 219 418 l 319 418 m 438 363 q 493 163 438 232 q 644 93 549 93 q 804 165 749 93 q 860 363 860 236 q 801 561 860 490 q 644 632 743 632 q 491 558 544 632 q 438 363 438 485 z "
    },
    "я": {
      "ha": 692,
      "x_min": 36,
      "x_max": 590,
      "o": "m 215 283 q 114 357 154 306 q 74 492 74 408 q 92 586 74 543 q 144 660 111 629 q 222 708 178 692 q 319 725 267 725 l 590 725 l 590 0 l 471 0 l 471 263 l 333 263 l 175 0 l 36 0 l 215 283 m 471 368 l 471 619 l 326 619 q 279 611 303 619 q 237 586 256 603 q 206 546 218 569 q 194 492 194 522 q 232 401 194 433 q 319 368 269 368 l 471 368 z "
    },
    "ђ": {
      "ha": 825,
      "x_min": 0,
      "x_max": 731,
      "o": "m 731 -24 q 713 -117 731 -74 q 665 -191 696 -160 q 591 -240 633 -222 q 500 -258 549 -258 q 412 -243 454 -258 q 339 -200 369 -228 l 396 -118 q 435 -142 411 -133 q 486 -150 460 -150 q 573 -116 538 -150 q 608 -32 608 -82 l 608 360 q 569 526 608 469 q 458 582 531 582 q 379 565 417 582 q 311 517 342 547 q 258 446 281 486 q 224 358 235 406 l 224 0 l 101 0 l 101 817 l 0 817 l 0 906 l 101 906 l 101 1014 l 224 1014 l 224 906 l 538 906 l 538 817 l 224 817 l 224 504 q 333 642 258 593 q 503 692 407 692 q 673 615 615 692 q 731 388 731 538 l 731 -24 z "
    },
    "ѓ": {
      "ha": 592,
      "x_min": 101,
      "x_max": 563,
      "o": "m 335 846 l 254 874 l 335 1014 l 457 1014 l 335 846 m 563 633 l 221 633 l 221 0 l 101 0 l 101 725 l 563 725 l 563 633 z "
    },
    "є": {
      "ha": 753,
      "x_min": 50,
      "x_max": 717,
      "o": "m 415 -12 q 261 19 329 -12 q 146 102 193 50 q 74 222 99 154 q 50 363 50 290 q 75 503 50 435 q 147 624 100 571 q 262 708 194 676 q 415 739 329 739 q 596 691 524 739 q 704 575 668 643 l 624 526 q 581 581 606 558 q 529 617 557 603 q 472 637 501 631 q 414 643 442 643 q 323 626 364 643 q 251 578 282 608 q 199 506 219 547 q 169 417 178 464 l 529 417 l 529 319 l 167 319 q 194 222 172 265 q 249 147 217 178 q 322 99 281 115 q 410 82 364 82 q 472 90 440 82 q 533 114 504 99 q 585 153 561 129 q 624 207 608 176 l 717 164 q 601 33 682 79 q 415 -12 519 -12 z "
    },
    "ѕ": {
      "ha": 686,
      "x_min": 35,
      "x_max": 640,
      "o": "m 353 -14 q 181 13 265 -14 q 35 92 96 40 l 88 174 q 215 101 151 125 q 350 76 279 76 q 476 108 429 76 q 522 196 522 139 q 510 241 522 222 q 472 274 497 260 q 408 299 447 288 q 318 322 369 310 q 206 354 253 339 q 128 390 158 369 q 83 440 97 411 q 69 513 69 469 q 91 609 69 567 q 150 680 113 651 q 238 723 188 708 q 347 738 289 738 q 500 711 429 738 q 619 642 571 685 l 564 568 q 461 628 518 608 q 344 649 404 649 q 231 620 278 649 q 185 529 185 592 q 194 488 185 504 q 224 458 203 471 q 277 436 244 446 q 356 415 310 426 q 481 381 428 399 q 570 340 535 364 q 623 285 606 317 q 640 207 640 253 q 563 46 640 106 q 353 -14 485 -14 z "
    },
    "і": {
      "ha": 325,
      "x_min": 101,
      "x_max": 224,
      "o": "m 101 0 l 101 725 l 224 725 l 224 0 l 101 0 m 101 861 l 101 1014 l 224 1014 l 224 861 l 101 861 z "
    },
    "ј": {
      "ha": 333,
      "x_min": -160,
      "x_max": 232,
      "o": "m 7 -258 q -84 -244 -42 -258 q -160 -200 -126 -231 l -103 -118 q -58 -143 -83 -136 q -7 -150 -32 -150 q 36 -141 15 -150 q 74 -117 57 -132 q 100 -79 90 -101 q 110 -32 110 -57 l 110 725 l 232 725 l 232 -24 q 213 -118 232 -75 q 163 -192 194 -161 q 92 -241 132 -224 q 7 -258 51 -258 m 110 861 l 110 1014 l 232 1014 l 232 861 l 110 861 z "
    },
    "љ": {
      "ha": 1122,
      "x_min": 6,
      "x_max": 1078,
      "o": "m 6 100 q 80 122 50 104 q 130 184 110 139 q 164 310 150 229 q 192 522 178 392 l 214 725 l 665 725 l 665 447 l 867 447 q 944 433 906 447 q 1012 391 982 419 q 1060 320 1042 363 q 1078 221 1078 278 q 1060 122 1078 164 q 1011 53 1042 81 q 942 13 981 26 q 865 0 904 0 l 546 0 l 546 629 l 326 629 l 306 472 q 265 240 286 331 q 211 95 243 149 q 135 19 179 42 q 26 -7 90 -3 l 6 100 m 865 103 q 931 133 906 103 q 957 221 957 163 q 930 313 957 282 q 867 344 903 344 l 665 344 l 665 103 l 865 103 z "
    },
    "њ": {
      "ha": 1111,
      "x_min": 101,
      "x_max": 1067,
      "o": "m 101 725 l 221 725 l 221 447 l 543 447 l 543 725 l 663 725 l 663 447 l 856 447 q 933 433 894 447 q 1001 391 971 419 q 1049 320 1031 363 q 1067 221 1067 278 q 1049 122 1067 164 q 1000 53 1031 81 q 931 13 969 26 q 854 0 893 0 l 543 0 l 543 342 l 221 342 l 221 0 l 101 0 l 101 725 m 854 103 q 920 133 894 103 q 946 221 946 163 q 919 313 946 282 q 856 344 892 344 l 663 344 l 663 103 l 854 103 z "
    },
    "ћ": {
      "ha": 824,
      "x_min": -1,
      "x_max": 731,
      "o": "m 608 360 q 456 582 608 582 q 378 566 415 582 q 311 522 342 550 q 258 453 281 493 q 224 364 236 413 l 224 0 l 101 0 l 101 817 l -1 817 l -1 906 l 101 906 l 101 1014 l 224 1014 l 224 906 l 538 906 l 538 817 l 224 817 l 224 510 q 330 643 256 594 q 501 692 404 692 q 673 615 615 692 q 731 388 731 539 l 731 0 l 608 0 l 608 360 z "
    },
    "ќ": {
      "ha": 694,
      "x_min": 101,
      "x_max": 689,
      "o": "m 533 725 l 669 725 l 385 372 l 689 0 l 554 0 l 306 318 l 221 318 l 221 0 l 101 0 l 101 725 l 221 725 l 221 410 l 292 410 l 533 725 m 381 846 l 300 874 l 381 1014 l 503 1014 l 381 846 z "
    },
    "ѝ": {
      "ha": 783,
      "x_min": 101,
      "x_max": 714,
      "o": "m 221 172 l 615 725 l 714 725 l 714 0 l 594 0 l 594 542 l 207 0 l 101 0 l 101 725 l 221 725 l 221 172 m 236 1014 l 357 1014 l 439 874 l 360 846 l 236 1014 z "
    },
    "ў": {
      "ha": 757,
      "x_min": 17,
      "x_max": 732,
      "o": "m 389 821 q 281 858 322 821 q 240 947 240 894 l 306 947 q 331 898 306 921 q 389 875 356 875 q 444 897 421 875 q 474 947 467 918 l 538 947 q 496 858 538 894 q 389 821 454 821 m 129 -194 q 168 -203 153 -201 q 199 -204 183 -204 q 224 -201 211 -204 q 250 -177 236 -197 q 282 -116 264 -157 q 324 0 300 -75 l 17 725 l 143 725 l 390 110 l 615 725 l 732 725 l 376 -190 q 312 -281 353 -253 q 204 -310 271 -310 q 129 -300 169 -310 l 129 -194 z "
    },
    "џ": {
      "ha": 754,
      "x_min": 101,
      "x_max": 653,
      "o": "m 317 0 l 101 0 l 101 726 l 221 726 l 221 106 l 533 106 l 533 726 l 653 726 l 653 0 l 436 0 l 436 -228 l 317 -228 l 317 0 z "
    },
    "Ґ": {
      "ha": 714,
      "x_min": 122,
      "x_max": 690,
      "o": "m 122 986 l 583 986 l 593 1214 l 690 1214 l 690 875 l 247 875 l 247 0 l 122 0 l 122 986 z "
    },
    "ґ": {
      "ha": 590,
      "x_min": 101,
      "x_max": 563,
      "o": "m 101 725 l 472 725 l 482 953 l 563 953 l 563 629 l 221 629 l 221 0 l 101 0 l 101 725 z "
    },
    "Ұ": {
      "ha": 853,
      "x_min": -8,
      "x_max": 861,
      "o": "m 696 321 l 696 238 l 489 238 l 489 0 l 364 0 l 364 238 l 160 238 l 160 321 l 364 321 l 364 363 l -8 986 l 131 986 l 429 472 l 728 986 l 861 986 l 489 367 l 489 321 l 696 321 z "
    },
    "ұ": {
      "ha": 753,
      "x_min": 1,
      "x_max": 751,
      "o": "m 311 0 l 107 0 l 107 83 l 311 83 l 311 89 l 1 725 l 140 725 l 376 199 l 618 725 l 751 725 l 436 89 l 436 83 l 643 83 l 643 0 l 436 0 l 436 -296 l 311 -296 l 311 0 z "
    },
    "Ѐ": {
      "ha": 842,
      "x_min": 121,
      "x_max": 790,
      "o": "m 790 111 l 790 0 l 121 0 l 121 986 l 778 986 l 778 875 l 246 875 l 246 556 l 708 556 l 708 451 l 246 451 l 246 111 l 790 111 m 322 1274 l 443 1274 l 525 1133 l 446 1106 l 322 1274 z "
    },
    "Ё": {
      "ha": 842,
      "x_min": 121,
      "x_max": 790,
      "o": "m 303 1126 l 303 1268 l 406 1268 l 406 1126 l 303 1126 m 528 1126 l 528 1268 l 631 1268 l 631 1126 l 528 1126 m 790 111 l 790 0 l 121 0 l 121 986 l 778 986 l 778 875 l 246 875 l 246 556 l 708 556 l 708 451 l 246 451 l 246 111 l 790 111 z "
    },
    "ї": {
      "ha": 325,
      "x_min": -1,
      "x_max": 326,
      "o": "m -1 867 l -1 1008 l 101 1008 l 101 867 l -1 867 m 224 867 l 224 1008 l 326 1008 l 326 867 l 224 867 m 101 0 l 101 725 l 224 725 l 224 0 l 101 0 z "
    },
    "ѐ": {
      "ha": 821,
      "x_min": 50,
      "x_max": 783,
      "o": "m 419 -14 q 269 16 338 -14 q 153 97 201 46 q 77 217 104 149 q 50 363 50 286 q 77 507 50 439 q 153 626 104 575 q 271 708 203 678 q 421 738 339 738 q 570 707 503 738 q 685 626 638 676 q 758 508 732 575 q 783 368 783 440 q 783 340 783 353 q 781 321 782 328 l 179 321 q 204 222 183 267 q 258 146 225 178 q 334 96 292 114 q 424 78 376 78 q 489 87 457 78 q 549 111 521 96 q 598 149 576 126 q 631 199 619 171 l 736 169 q 687 96 718 129 q 615 38 656 63 q 524 0 574 14 q 419 -14 474 -14 m 668 411 q 642 506 664 463 q 588 581 621 550 q 513 628 556 611 q 421 646 469 646 q 329 628 372 646 q 253 580 286 611 q 201 506 221 549 q 176 411 181 463 l 668 411 m 271 1014 l 392 1014 l 474 874 l 394 846 l 271 1014 z "
    },
    "ё": {
      "ha": 821,
      "x_min": 50,
      "x_max": 783,
      "o": "m 251 867 l 251 1008 l 354 1008 l 354 867 l 251 867 m 476 867 l 476 1008 l 579 1008 l 579 867 l 476 867 m 419 -14 q 269 16 338 -14 q 153 97 201 46 q 77 217 104 149 q 50 363 50 286 q 77 507 50 439 q 153 626 104 575 q 271 708 203 678 q 421 738 339 738 q 570 707 503 738 q 685 626 638 676 q 758 508 732 575 q 783 368 783 440 q 783 340 783 353 q 781 321 782 328 l 179 321 q 204 222 183 267 q 258 146 225 178 q 334 96 292 114 q 424 78 376 78 q 489 87 457 78 q 549 111 521 96 q 598 149 576 126 q 631 199 619 171 l 736 169 q 687 96 718 129 q 615 38 656 63 q 524 0 574 14 q 419 -14 474 -14 m 668 411 q 642 506 664 463 q 588 581 621 550 q 513 628 556 611 q 421 646 469 646 q 329 628 372 646 q 253 580 286 611 q 201 506 221 549 q 176 411 181 463 l 668 411 z "
    }
  },
  "familyName": "Raleway Medium",
  "ascender": 1306,
  "descender": -325,
  "underlinePosition": -104,
  "underlineThickness": 69,
  "boundingBox": {
    "yMin": -312,
    "xMin": -294,
    "yMax": 1292,
    "xMax": 1821
  },
  "resolution": 1000,
  "original_font_information": {
    "format": 0,
    "copyright": "Copyright (c) 2010 - 2013, Matt McInerney (matt@pixelspread.com), Pablo Impallari (impallari@gmail.com), Rodrigo Fuenzalida (hello@rfuenzalida.com) with Reserved Font Name \"Raleway\"",
    "fontFamily": "Raleway Medium",
    "fontSubfamily": "Regular",
    "uniqueID": "MattMcInerney,PabloImpallari,RodrigoFuenzalida: Raleway Medium: 2013",
    "fullName": "Raleway Medium",
    "version": "Version 3.000g; ttfautohint (v1.5) -l 8 -r 28 -G 28 -x 14 -D latn -f cyrl -w G -c -X \"\"",
    "postScriptName": "Raleway-Medium",
    "trademark": "Raleway is a trademark of Matt McInerney.",
    "manufacturer": "Matt McInerney, Pablo Impallari, Rodrigo Fuenzalida",
    "designer": "Matt McInerney, Pablo Impallari, Rodrigo Fuenzalida",
    "description": "Raleway is an elegant sans-serif typeface family. Initially designed by Matt McInerney as a single thin weight, it was expanded into a 9 weight family by Pablo Impallari and Rodrigo Fuenzalida in 2012 and iKerned by Igino Marini. It is a display face and the download features both old style and lining numerals, standard and discretionary ligatures, a pretty complete set of diacritics, as well as a stylistic alternate inspired by more geometric sans-serif typefaces than its neo-grotesque inspired default character set.",
    "manufacturerURL": "http://theleagueofmoveabletype.com",
    "designerURL": "http://pixelspread.com",
    "licence": "This Font Software is licensed under the SIL Open Font License, Version 1.1. This license is available with a FAQ at: http://scripts.sil.org/OFL",
    "licenceURL": "http://scripts.sil.org/OFL",
    "preferredFamily": "Raleway",
    "preferredSubfamily": "Medium"
  },
  "cssFontWeight": "normal",
  "cssFontStyle": "normal"
};
},{}],"js/script.js":[function(require,module,exports) {
"use strict";

var _three = require("three");

var _animeEs = _interopRequireDefault(require("animejs/lib/anime.es.js"));

var _engine3d = _interopRequireDefault(require("./utils/engine3d"));

var _paths = require("./utils/paths");

var _Raleway_Medium_Regular = _interopRequireDefault(require("./data/Raleway_Medium_Regular.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import Engine from './utils/engine';
var WIDTH = 480;
var HEIGHT = 480; // const el = document.getElementById('canvas');

var el = document.getElementById('container');
var app = new _engine3d.default(el, {
  debug: false,
  width: WIDTH,
  height: HEIGHT,
  postProcessing: true
});
app.setCamera(_engine3d.default.ORTHOPGRAPHIC_CAMERA(WIDTH, HEIGHT));

var getBox = function getBox() {
  var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0xFF0000;
  var geo = new _three.BoxBufferGeometry(1, 2, 2);
  var wireframe = new _three.EdgesGeometry(geo);
  var mat = new _three.LineBasicMaterial({
    color: color,
    linewidth: 5
  });
  return new _three.LineSegments(wireframe, mat); // const geo = new BoxGeometry(1, 1, 1);
  // const mat = new MeshBasicMaterial({
  //   color
  // });
  // return new Mesh(geo, mat);
};

var getText = function getText() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$color = _ref.color,
      color = _ref$color === void 0 ? 0xFFFFFF : _ref$color,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? 1 : _ref$size;

  var loader = new _three.FontLoader();
  var font = loader.parse(_Raleway_Medium_Regular.default);
  var geo = new _three.TextGeometry(text, {
    font: font,
    size: size,
    height: 1,
    bevelEnabled: false
  });
  var mat = new _three.MeshBasicMaterial({
    color: color
  });
  return new _three.Mesh(geo, mat);
};

var colors = [0xFFFF00, 0x00FFFF, 0xFF00FF];
var total = 3;
var boxes = new Array(total).fill(0).map(function (c, idx) {
  var box = getBox(colors[idx % colors.length]);
  app.scene.add(box);
  var perc = idx / total;
  var starting = Math.PI * 2 * perc;
  var variables = {
    position: starting
  };
  var animation = (0, _animeEs.default)({
    targets: variables,
    position: Math.PI * 2 + starting,
    duration: 10000,
    easing: 'linear',
    loop: true,
    round: 8
  });
  (0, _animeEs.default)({
    targets: box.rotation,
    x: Math.PI * 2,
    y: Math.PI * 2,
    duration: 10000,
    easing: 'linear',
    loop: true,
    round: 10
  });
  return {
    box: box,
    variables: variables,
    animation: animation
  };
});
var text = new _three.Group();
var mainLogo = getText("FreeTech", {
  color: 0xFFFFFF,
  size: 1.4
});
mainLogo.position.set(0, 0, 0);
text.add(mainLogo);
var subtitle = getText("Industries", {
  color: 0x0000FF,
  size: 0.5
});
subtitle.position.set(0, -0.8, 0);
text.add(subtitle);
text.position.set(-4.8, -3.8, 0);
app.scene.add(text);
var offset = false;
app.onRender(function (_ref2) {
  var frame = _ref2.frame,
      width = _ref2.width,
      height = _ref2.height,
      debug = _ref2.debug;
  boxes.forEach(function (_ref3) {
    var box = _ref3.box,
        variables = _ref3.variables;

    var _getPointOnArc = (0, _paths.getPointOnArc)(0, 0, variables.position, 2.5),
        x = _getPointOnArc.x,
        y = _getPointOnArc.y;

    box.position.set(x - 0.4, 0.75, y);
  });

  if (frame % 60 === 0 && Math.random() > 0.5) {
    offset = !offset;

    if (offset) {
      text.position.x -= 0.3;
      text.position.y -= 0.5;
    } else {
      text.position.x += 0.3;
      text.position.y += 0.5;
    }
  }
});
app.start();
},{"three":"../node_modules/three/build/three.module.js","animejs/lib/anime.es.js":"../node_modules/animejs/lib/anime.es.js","./utils/engine3d":"js/utils/engine3d.js","./utils/paths":"js/utils/paths.js","./data/Raleway_Medium_Regular.json":"js/data/Raleway_Medium_Regular.json"}],"../node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "59487" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else {
        window.location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["../node_modules/parcel-bundler/src/builtins/hmr-runtime.js","js/script.js"], null)
//# sourceMappingURL=/script.d573be0b.js.map